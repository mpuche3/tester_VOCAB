[
    {
        "Question": "What is the name for a step-by-step procedure designed to perform a specific task or solve a particular problem in computer science?",
        "RightAnswer": "Algorithm",
        "WrongAnswers": [
            "Framework",
            "Protocol",
            "Variable",
            "Interface",
            "Compiler"
        ],
        "Explanation": "An algorithm is a precise sequence of instructions or rules that defines a process to be followed to solve a specific problem or accomplish a defined task in computer science. Think of it as a recipe that tells a computer exactly what steps to take to reach a desired outcome. Algorithms can be expressed in natural language, pseudocode, flowcharts, or programming languages. The quality of an algorithm is typically judged by its efficiency, which relates to how quickly it can complete its task and how much computational resources it requires. From simple sorting procedures to complex machine learning systems, algorithms form the backbone of computing and are fundamental to everything from search engines to social media recommendation systems. Computer scientists design, analyze, and optimize algorithms to solve increasingly complex problems with greater efficiency.",
        "trans_Question": "wɒt ɪz ðə néjm fɔr ə stɛ́p-baj-stɛ́p prəsíjdʒər dəzájnd tə pərfɔ́rm ə spəsɪ́fɪk tǽsk ɔr sɒ́lv ə pərtɪ́kjələr prɒ́bləm ɪn kəmpjúwtər sájəns?",
        "trans_RightAnswer": "ǽlɡərɪ̀ðəm",
        "trans_WrongAnswers": [
            "fréjmwɜ̀rk",
            "prówtəkɒ̀l",
            "vɛ́ərijəbəl",
            "ɪ́ntərfèjs",
            "kəmpájlər"
        ],
        "trans_Explanation": "ən ǽlɡərɪ̀ðəm ɪz ə prəsájs síjkwəns əv ɪnstrʌ́kʃənz ɔr rúwlz ðət dəfájnz ə prɒ́sɛs tə bij fɒ́lowd tə sɒ́lv ə spəsɪ́fɪk prɒ́bləm ɔr əkɒ́mplɪʃ ə dəfájnd tǽsk ɪn kəmpjúwtər sájəns. θɪ́ŋk əv ɪt æz ə rɛ́sɪpij ðət tɛ́lz ə kəmpjúwtər əɡzǽktlij wɒt stɛ́ps tə téjk tə ríjtʃ ə dəzájərd áwtkʌ̀m. ǽlɡərɪ̀ðəmz kən bij əksprɛ́st ɪn nǽtʃərəl lǽŋɡwədʒ, súwdəkowd, flówtʃɑ̀rts, ɔr prówɡræ̀mɪŋ lǽŋɡwədʒɪz. ðə kwɑ́lɪtij əv ən ǽlɡərɪ̀ðəm ɪz tɪ́pɪkəlij dʒʌ́dʒd baj ɪts əfɪ́ʃənsij, wɪ́tʃ rəléjts tə háw kwɪ́klij ɪt kən kəmplíjt ɪts tǽsk ənd háw mʌtʃ kɒ̀mpjuwtéjʃənəl ríjsɔrsɪz ɪt rəkwájərz. frəm sɪ́mpəl sɔ́rtɪŋ prəsíjdʒərz tə kɒ́mplɛks məʃíjn lɜ́rnɪŋ sɪ́stəmz, ǽlɡərɪ̀ðəmz fɔ́rm ðə bǽkbòwn əv kəmpjúwtɪŋ ənd ɑr fʌ̀ndəmɛ́ntəl tə ɛ́vrijθɪ̀ŋ frəm sɜ́rtʃ ɛ́ndʒɪnz tə sówʃəl míjdijə rɛ̀kəməndéjʃən sɪ́stəmz. kəmpjúwtər sájəntɪsts dəzájn, ǽnəlàjz, ənd ɒ́ptɪmàjz ǽlɡərɪ̀ðəmz tə sɒ́lv ɪnkríjsɪŋɡlij kɒ́mplɛks prɒ́bləmz wɪð ɡréjtər əfɪ́ʃənsij."
    },
    {
        "Question": "What is the name for an organized collection of data and associated operations designed for efficient storage, access, and manipulation of information in computer memory?",
        "RightAnswer": "Data Structure",
        "WrongAnswers": [
            "Algorithm Matrix",
            "Memory Protocol",
            "Code Framework",
            "Execution Pattern",
            "Storage Routine"
        ],
        "Explanation": "A Data Structure is a specialized format for organizing, processing, retrieving, and storing data in computer science. Think of it as a container that holds information in a way that makes operations on that information efficient. Just as you might organize books on shelves by genre or author for easy finding, data structures organize digital information using various patterns. Common examples include arrays, linked lists, stacks, queues, trees, and hash tables. Each structure has unique properties that make it suitable for specific tasks. For instance, arrays allow quick access to elements by their position, while hash tables excel at rapid lookups. The choice of data structure significantly impacts program performance, memory usage, and code readability. Understanding data structures is fundamental to computer science because they form the building blocks for constructing efficient algorithms and solving complex computational problems.",
        "trans_Question": "wɒt ɪz ðə néjm fɔr ən ɔ́rɡənàjzd kəlɛ́kʃən əv déjtə ənd əsówsijèjtɪd ɒ̀pəréjʃənz dəzájnd fɔr əfɪ́ʃənt stɔ́rɪdʒ, ǽksɛ̀s, ənd mənɪ̀pjəléjʃən əv ɪnfərméjʃən ɪn kəmpjúwtər mɛ́mərij?",
        "trans_RightAnswer": "déjtə strʌ́ktʃər",
        "trans_WrongAnswers": [
            "ǽlɡərɪ̀ðəm méjtrɪks",
            "mɛ́mərij prówtəkɒ̀l",
            "kówd fréjmwɜ̀rk",
            "ɛ̀ksəkjúwʃən pǽtərn",
            "stɔ́rɪdʒ ruwtíjn"
        ],
        "trans_Explanation": "ə déjtə strʌ́ktʃər ɪz ə spɛ́ʃəlàjzd fɔ́rmæ̀t fɔr ɔ́rɡənàjzɪŋ, prɒ́sɛsɪŋ, rətríjvɪŋ, ənd stɔ́rɪŋ déjtə ɪn kəmpjúwtər sájəns. θɪ́ŋk əv ɪt æz ə kəntéjnər ðət hówldz ɪnfərméjʃən ɪn ə wej ðət méjks ɒ̀pəréjʃənz ɒn ðət ɪnfərméjʃən əfɪ́ʃənt. dʒəst æz juw majt ɔ́rɡənàjz bʊ́ks ɒn ʃɛ́lvz baj ʒɒ́nrə ɔr ɔ́θər fɔr íjzij fájndɪŋ, déjtə strʌ́ktʃərz ɔ́rɡənàjz dɪ́dʒɪtəl ɪnfərméjʃən júwzɪŋ vɛ́ərijəs pǽtərnz. kɒ́mən əɡzǽmpəlz ɪnklúwd əréjz, lɪ́ŋkt lɪ́sts, stǽks, kjúwz, tríjz, ənd hǽʃ téjbəlz. ijtʃ strʌ́ktʃər həz juwnɪ́k prɒ́pərtijz ðət méjk ɪt súwtəbəl fɔr spəsɪ́fɪk tǽsks. fɔr ɪ́nstəns, əréjz əláw kwɪ́k ǽksɛ̀s tə ɛ́ləmənts baj ðɛər pəzɪ́ʃən, wájl hǽʃ téjbəlz əksɛ́l æt rǽpɪd lʊ́kəps. ðə tʃɔ́js əv déjtə strʌ́ktʃər sɪɡnɪ́fɪkəntlij ɪ́mpækts prówɡræ̀m pərfɔ́rməns, mɛ́mərij júwsɪdʒ, ənd kówd rìjdəbɪ́lɪtij. ʌ̀ndərstǽndɪŋ déjtə strʌ́ktʃərz ɪz fʌ̀ndəmɛ́ntəl tə kəmpjúwtər sájəns bəkɒ́z ðej fɔ́rm ðə bɪ́ldɪŋ blɒ́ks fɔr kənstrʌ́ktɪŋ əfɪ́ʃənt ǽlɡərɪ̀ðəmz ənd sɒ́lvɪŋ kɒ́mplɛks kɒ̀mpjuwtéjʃənəl prɒ́bləmz."
    },
    {
        "Question": "Which branch of computer science is primarily concerned with classifying computational problems according to their inherent difficulty and the resources required to solve them?",
        "RightAnswer": "Complexity Theory",
        "WrongAnswers": [
            "Algorithm Design Theory",
            "Automata Theory",
            "Computational Logic",
            "Information Retrieval Theory",
            "Machine Learning Paradigms"
        ],
        "Explanation": "Complexity Theory is a central branch of theoretical computer science that studies the resources required to solve computational problems, particularly focusing on time and space requirements. It categorizes problems into complexity classes such as P (problems solvable in polynomial time), NP (problems verifiable in polynomial time), and others like PSPACE and EXPTIME. The theory helps computer scientists understand fundamental limits of computation, establishing which problems are tractable (practically solvable) versus intractable (likely impossible to solve efficiently). One of its most famous aspects is the P versus NP problem, which asks whether every problem whose solution can be quickly verified can also be quickly solved—a question with profound implications for cryptography, optimization, and artificial intelligence. Complexity Theory provides the theoretical foundation for analyzing algorithm efficiency and understanding why certain computational problems resist efficient solutions despite significant technological advances.",
        "trans_Question": "wɪ́tʃ brǽntʃ əv kəmpjúwtər sájəns ɪz prajmɛ́ərɪlij kənsɜ́rnd wɪð klǽsɪfàjɪŋ kɒ̀mpjuwtéjʃənəl prɒ́bləmz əkɔ́rdɪŋ tə ðɛər ɪnhɛ́ərənt dɪ́fɪkəltij ənd ðə ríjsɔrsɪz rəkwájərd tə sɒ́lv ðɛm?",
        "trans_RightAnswer": "kəmplɛ́ksɪtij θíjərij",
        "trans_WrongAnswers": [
            "ǽlɡərɪ̀ðəm dəzájn θíjərij",
            "ɔtɒ́mətə θíjərij",
            "kɒ̀mpjuwtéjʃənəl lɒ́dʒɪk",
            "ɪnfərméjʃən rətríjvəl θíjərij",
            "məʃíjn lɜ́rnɪŋ pǽrədàjmz"
        ],
        "trans_Explanation": "kəmplɛ́ksɪtij θíjərij ɪz ə sɛ́ntrəl brǽntʃ əv θìjərɛ́tɪkəl kəmpjúwtər sájəns ðət stʌ́dijz ðə ríjsɔrsɪz rəkwájərd tə sɒ́lv kɒ̀mpjuwtéjʃənəl prɒ́bləmz, pərtɪ́kjələrlij fówkəsɪŋ ɒn tájm ənd spéjs rəkwájərmənts. ɪt kǽtəɡəràjzɪz prɒ́bləmz ɪntə kəmplɛ́ksɪtij klǽsɪz sʌtʃ æz P (prɒ́bləmz sɒ́lvəbəl ɪn pɒ̀lijnówmijəl tájm), NP (prɒ́bləmz vɛ́ərɪfajəbəl ɪn pɒ̀lijnówmijəl tájm), ənd ʌ́ðərz lájk PSPACE ənd EXPTIME. ðə θíjərij hɛ́lps kəmpjúwtər sájəntɪsts ʌ̀ndərstǽnd fʌ̀ndəmɛ́ntəl lɪ́mɪts əv kɒ̀mpjətéjʃən, əstǽblɪʃɪŋ wɪ́tʃ prɒ́bləmz ɑr trǽktəbəl (prǽktɪkəlij sɒ́lvəbəl) vɜ́rsəs ɪ̀ntrǽktəbəl (lájklij ɪ̀mpɒ́sɪbəl tə sɒ́lv əfɪ́ʃəntlij). wʌ́n əv ɪts mówst féjməs ǽspɛkts ɪz ðə P vɜ́rsəs NP prɒ́bləm, wɪ́tʃ ǽsks wɛ́ðər ɛvərij prɒ́bləm húwz səlúwʃən kən bij kwɪ́klij vɛ́ərɪfajd kən ɔ́lsow bij kwɪ́klij sɒ́lvd—ə kwɛ́stʃən wɪð prowfáwnd ɪ̀mplɪkéjʃənz fɔr krɪptɒ́ɡrəfij, ɒptɪmɪzéjʃən, ənd ɑ̀rtɪfɪ́ʃəl ɪntɛ́lɪdʒəns. kəmplɛ́ksɪtij θíjərij prəvájdz ðə θìjərɛ́tɪkəl fawndéjʃən fɔr ǽnəlàjzɪŋ ǽlɡərɪ̀ðəm əfɪ́ʃənsij ənd ʌ̀ndərstǽndɪŋ wáj sɜ́rtən kɒ̀mpjuwtéjʃənəl prɒ́bləmz rəzɪ́st əfɪ́ʃənt səlúwʃənz dəspájt sɪɡnɪ́fɪkənt tɛ̀knəlɒ́dʒɪkəl ədvǽnsɪz."
    },
    {
        "Question": "Which branch of computer science focuses on classifying computational problems according to their inherent difficulty and determining what problems can or cannot be solved algorithmically?",
        "RightAnswer": "Computability Theory",
        "WrongAnswers": [
            "Algorithm Design",
            "Information Entropy",
            "Parallel Processing",
            "Database Normalization",
            "Network Flow Theory"
        ],
        "Explanation": "Computability Theory is a fundamental branch of computer science that explores the boundaries of what computers can and cannot compute. It addresses the profound question: What problems are solvable by algorithms? The field was established by pioneers like Alan Turing and Alonzo Church in the 1930s, before physical computers even existed. At its core, Computability Theory introduces formal models of computation such as Turing machines to rigorously define what it means for a function to be computable. It establishes that certain problems, called undecidable problems, cannot be solved by any algorithm regardless of resources or time available. A classic example is the Halting Problem, which asks whether a given program will eventually terminate or run forever. Computability Theory provides the theoretical foundation for understanding computational limits and serves as a bridge to complexity theory, which further classifies solvable problems according to their resource requirements. This area of study remains vital in contemporary computer science as it helps researchers understand fundamental limitations in artificial intelligence, automated verification, and algorithm design.",
        "trans_Question": "wɪ́tʃ brǽntʃ əv kəmpjúwtər sájəns fówkəsɪz ɒn klǽsɪfàjɪŋ kɒ̀mpjuwtéjʃənəl prɒ́bləmz əkɔ́rdɪŋ tə ðɛər ɪnhɛ́ərənt dɪ́fɪkəltij ənd dətɜ́rmɪnɪŋ wɒt prɒ́bləmz kən ɔr kǽnɒt bij sɒ́lvd æ̀lɡərɪ́θmɪklij?",
        "trans_RightAnswer": "kəmpjuwtəbɪ́lɪtij θíjərij",
        "trans_WrongAnswers": [
            "ǽlɡərɪ̀ðəm dəzájn",
            "ɪnfərméjʃən ɛ́ntrəpij",
            "pǽrəlɛ̀l prɒ́sɛsɪŋ",
            "déjtəbèjs nɔ̀rməlɪzéjʃən",
            "nɛ́twɜ̀rk flów θíjərij"
        ],
        "trans_Explanation": "kəmpjuwtəbɪ́lɪtij θíjərij ɪz ə fʌ̀ndəmɛ́ntəl brǽntʃ əv kəmpjúwtər sájəns ðət əksplɔ́rz ðə báwndərijz əv wɒt kəmpjúwtərz kən ənd kǽnɒt kəmpjúwt. ɪt ǽdrɛ́sɪz ðə prowfáwnd kwɛ́stʃən: wɒt prɒ́bləmz ɑr sɒ́lvəbəl baj ǽlɡərɪ̀ðəmz? ðə fíjld wɒz əstǽblɪʃt baj pàjənɪ́ərz lájk ǽlən tjʊ́ərɪŋ ənd əlɒ́nzow tʃɜ́rtʃ ɪn ðə 1930s, bəfɔ́r fɪ́zɪkəl kəmpjúwtərz íjvən əɡzɪ́stɪd. æt ɪts kɔ́r, kəmpjuwtəbɪ́lɪtij θíjərij ɪntrədúwsɪz fɔ́rməl mɒ́dəlz əv kɒ̀mpjətéjʃən sʌtʃ æz tjʊ́ərɪŋ məʃíjnz tə rɪ́ɡərəslij dəfájn wɒt ɪt míjnz fɔr ə fʌ́ŋkʃən tə bij kəmpjúwtəbəl. ɪt əstǽblɪʃɪz ðət sɜ́rtən prɒ́bləmz, kɔ́ld ʌ̀ndəsájdəbəl prɒ́bləmz, kǽnɒt bij sɒ́lvd baj ɛ́nij ǽlɡərɪ̀ðəm rəɡɑ́rdləs əv ríjsɔrsɪz ɔr tájm əvéjləbəl. ə klǽsɪk əɡzǽmpəl ɪz ðə hɔ́ltɪŋ prɒ́bləm, wɪ́tʃ ǽsks wɛ́ðər ə ɡɪ́vən prówɡræ̀m wɪl əvɛ́ntʃuwəlij tɜ́rmɪnèjt ɔr rʌ́n fərɛ́vər. kəmpjuwtəbɪ́lɪtij θíjərij prəvájdz ðə θìjərɛ́tɪkəl fawndéjʃən fɔr ʌ̀ndərstǽndɪŋ kɒ̀mpjuwtéjʃənəl lɪ́mɪts ənd sɜ́rvz æz ə brɪ́dʒ tə kəmplɛ́ksɪtij θíjərij, wɪ́tʃ fɜ́rðər klǽsɪfàjz sɒ́lvəbəl prɒ́bləmz əkɔ́rdɪŋ tə ðɛər ríjsɔrs rəkwájərmənts. ðɪs ɛ́ərijə əv stʌ́dij rəméjnz vájtəl ɪn kəntɛ́mpərɛ̀ərij kəmpjúwtər sájəns æz ɪt hɛ́lps ríjsərtʃərz ʌ̀ndərstǽnd fʌ̀ndəmɛ́ntəl lɪ̀mɪtéjʃənz ɪn ɑ̀rtɪfɪ́ʃəl ɪntɛ́lɪdʒəns, ɔ́təmèjtɪd vɛ̀ərɪfɪkéjʃən, ənd ǽlɡərɪ̀ðəm dəzájn."
    },
    {
        "Question": "What theoretical computing model, described by Alan Turing in 1936, consists of an infinite tape divided into cells, a read/write head, and a finite set of rules that determine how the machine processes information?",
        "RightAnswer": "Turing Machine",
        "WrongAnswers": [
            "Von Neumann Architecture",
            "Lambda Calculus",
            "Finite State Automaton",
            "Boolean Algebra Model",
            "Church Algorithm"
        ],
        "Explanation": "A Turing Machine is a mathematical model of computation introduced by Alan Turing in 1936. It provides a formal definition of what it means for a function to be computable. Conceptually, a Turing Machine consists of an infinitely long tape divided into discrete cells, a read/write head that can move along the tape, and a finite set of rules that determine the machine's behavior based on the current state and symbol being read. What makes Turing Machines so powerful in computer science is their theoretical ability to simulate any computer algorithm, no matter how complex. While impractical to build physically due to the infinite tape requirement, Turing Machines established the theoretical foundation for modern computers and computational complexity theory. The concept of 'Turing completeness' derives from this model, referring to any system capable of performing the same computational tasks as a Turing Machine, which effectively means it can compute anything that is algorithmically computable.",
        "trans_Question": "wɒt θìjərɛ́tɪkəl kəmpjúwtɪŋ mɒ́dəl, dəskrájbd baj ǽlən tjʊ́ərɪŋ ɪn 1936, kənsɪ́sts əv ən ɪ́nfɪnɪt téjp dɪvájdɪd ɪntə sɛ́lz, ə rɛ́d/rájt hɛ́d, ənd ə fájnàjt sɛ́t əv rúwlz ðət dətɜ́rmɪn háw ðə məʃíjn prɒ́sɛsɪz ɪnfərméjʃən?",
        "trans_RightAnswer": "tjʊ́ərɪŋ məʃíjn",
        "trans_WrongAnswers": [
            "vɒn nɔ́jmən ɑ́rkɪtɛ̀ktʃər",
            "lǽmdə kǽlkjələs",
            "fájnàjt stéjt ɔtɒ́mətən",
            "buwlíjən ǽldʒəbrə mɒ́dəl",
            "tʃɜ́rtʃ ǽlɡərɪ̀ðəm"
        ],
        "trans_Explanation": "ə tjʊ́ərɪŋ məʃíjn ɪz ə mæ̀θəmǽtɪkəl mɒ́dəl əv kɒ̀mpjətéjʃən ɪntrədúwst baj ǽlən tjʊ́ərɪŋ ɪn 1936. ɪt prəvájdz ə fɔ́rməl dɛ̀fɪnɪ́ʃən əv wɒt ɪt míjnz fɔr ə fʌ́ŋkʃən tə bij kəmpjúwtəbəl. kənsɛ́ptʃuwəlij, ə tjʊ́ərɪŋ məʃíjn kənsɪ́sts əv ən ɪ́nfɪnɪtlij lɔ́ŋ téjp dɪvájdɪd ɪntə dɪskríjt sɛ́lz, ə rɛ́d/rájt hɛ́d ðət kən múwv əlɔ́ŋ ðə téjp, ənd ə fájnàjt sɛ́t əv rúwlz ðət dətɜ́rmɪn ðə məʃíjn'z bəhéjvjər béjst ɒn ðə kɑ́rənt stéjt ənd sɪ́mbəl bíjɪŋ rɛ́d. wɒt méjks tjʊ́ərɪŋ məʃíjnz sow páwərfəl ɪn kəmpjúwtər sájəns ɪz ðɛər θìjərɛ́tɪkəl əbɪ́lɪtij tə sɪ́mjəlèjt ɛ́nij kəmpjúwtər ǽlɡərɪ̀ðəm, now mǽtər háw kɒ́mplɛks. wájl ɪ̀mprǽktɪkəl tə bɪ́ld fɪ́zɪkəlij djúw tə ðə ɪ́nfɪnɪt téjp rəkwájərmənt, tjʊ́ərɪŋ məʃíjnz əstǽblɪʃt ðə θìjərɛ́tɪkəl fawndéjʃən fɔr mɒ́dərn kəmpjúwtərz ənd kɒ̀mpjuwtéjʃənəl kəmplɛ́ksɪtij θíjərij. ðə kɒ́nsɛpt əv 'tjʊ́ərɪŋ kəmplíjtnəs' dərájvz frəm ðɪs mɒ́dəl, rəfɜ́rɪŋ tə ɛ́nij sɪ́stəm kéjpəbəl əv pərfɔ́rmɪŋ ðə séjm kɒ̀mpjuwtéjʃənəl tǽsks æz ə tjʊ́ərɪŋ məʃíjn, wɪ́tʃ əfɛ́ktɪvlij míjnz ɪt kən kəmpjúwt ɛ́nijθɪ̀ŋ ðət ɪz æ̀lɡərɪ́θmɪklij kəmpjúwtəbəl."
    },
    {
        "Question": "What computational model represents a system with a limited number of defined states and transitions between those states, often used in parsing, pattern matching, and protocol implementation?",
        "RightAnswer": "Finite State Machine",
        "WrongAnswers": [
            "Binary Search Tree",
            "Virtual Memory Manager",
            "Graph Traversal Algorithm",
            "Dynamic Programming Matrix",
            "Hash Table Implementation"
        ],
        "Explanation": "A Finite State Machine is a computational model that represents a system which can be in exactly one of a finite number of states at any given time. It can change from one state to another in response to inputs; these changes are called transitions. FSMs are widely used in computer science for designing systems with predetermined sequences of behaviors or operations. They appear in many applications including text parsing, protocol design, compiler implementation, and hardware circuit design. The beauty of FSMs lies in their simplicity and clarity: they break complex systems into manageable, discrete states with well-defined rules for moving between them. Unlike more complex computational models, FSMs have limited memory capabilities, making them suitable for problems where the current action depends only on the current state and input, not the entire history of inputs.",
        "trans_Question": "wɒt kɒ̀mpjuwtéjʃənəl mɒ́dəl rɛ̀prəzɛ́nts ə sɪ́stəm wɪð ə lɪ́mɪtɪd nʌ́mbər əv dəfájnd stéjts ənd trænzɪ́ʃənz bijtwíjn ðowz stéjts, ɔ́fən júwzd ɪn pɑ́rsɪŋ, pǽtərn mǽtʃɪŋ, ənd prówtəkɒ̀l ɪ̀mpləmɛntéjʃən?",
        "trans_RightAnswer": "fájnàjt stéjt məʃíjn",
        "trans_WrongAnswers": [
            "bájnərij sɜ́rtʃ tríj",
            "vɜ́rtʃuwəl mɛ́mərij mǽnədʒər",
            "ɡrǽf trǽvərsəl ǽlɡərɪ̀ðəm",
            "dajnǽmɪk prówɡræ̀mɪŋ méjtrɪks",
            "hǽʃ téjbəl ɪ̀mpləmɛntéjʃən"
        ],
        "trans_Explanation": "ə fájnàjt stéjt məʃíjn ɪz ə kɒ̀mpjuwtéjʃənəl mɒ́dəl ðət rɛ̀prəzɛ́nts ə sɪ́stəm wɪ́tʃ kən bij ɪn əɡzǽktlij wʌ́n əv ə fájnàjt nʌ́mbər əv stéjts æt ɛ́nij ɡɪ́vən tájm. ɪt kən tʃéjndʒ frəm wʌ́n stéjt tə ənʌ́ðər ɪn rəspɒ́ns tə ɪ́npʊ̀ts; ðijz tʃéjndʒɪz ɑr kɔ́ld trænzɪ́ʃənz. FSMS ɑr wájdlij júwzd ɪn kəmpjúwtər sájəns fɔr dəzájnɪŋ sɪ́stəmz wɪð prìjdətɜ́rmɪnd síjkwənsɪz əv bəhéjvjərz ɔr ɒ̀pəréjʃənz. ðej əpɪ́ər ɪn mɛ́nij æ̀plɪkéjʃənz ɪnklúwdɪŋ tɛ́kst pɑ́rsɪŋ, prówtəkɒ̀l dəzájn, kəmpájlər ɪ̀mpləmɛntéjʃən, ənd hɑ́rdwɛ̀ər sɜ́rkət dəzájn. ðə bjúwtij əv FSMS lájz ɪn ðɛər sɪmplɪ́sɪtij ənd klɛ́ərɪtij: ðej bréjk kɒ́mplɛks sɪ́stəmz ɪntə mǽnədʒəbəl, dɪskríjt stéjts wɪð wɛ́l-dəfájnd rúwlz fɔr múwvɪŋ bijtwíjn ðɛm. ʌ̀nlájk mɔr kɒ́mplɛks kɒ̀mpjuwtéjʃənəl mɒ́dəlz, FSMS həv lɪ́mɪtɪd mɛ́mərij kèjpəbɪ́lɪtijz, méjkɪŋ ðɛm súwtəbəl fɔr prɒ́bləmz wɛ́ər ðə kɑ́rənt ǽkʃən dəpɛ́ndz ównlij ɒn ðə kɑ́rənt stéjt ənd ɪ́npʊ̀t, nɒt ðə əntájər hɪ́stərij əv ɪ́npʊ̀ts."
    },
    {
        "Question": "Which specialized field in computer science focuses on creating programs that transform source code written in one programming language into another language, typically into machine code or intermediate representations?",
        "RightAnswer": "Compiler Design",
        "WrongAnswers": [
            "Database Administration",
            "Network Topology",
            "Human-Computer Interaction",
            "Quantum Computing",
            "Cloud Architecture"
        ],
        "Explanation": "Compiler Design is the art and science of creating software systems that translate code from one language to another. At its core, a compiler takes source code that humans can write and understand, and transforms it into a form that computers can execute efficiently. The process involves several sophisticated phases including lexical analysis (breaking code into tokens), syntax analysis (parsing the structure), semantic analysis (checking meaning), optimization (improving performance), and code generation (producing the target code). Compiler Design requires deep understanding of language theory, algorithms, and computer architecture. Well-designed compilers not only translate code correctly but also produce efficient executables, provide helpful error messages, and implement language features that make programming more productive. This field fundamentally enables all software development by bridging the gap between human-friendly programming languages and machine-executable instructions.",
        "trans_Question": "wɪ́tʃ spɛ́ʃəlàjzd fíjld ɪn kəmpjúwtər sájəns fówkəsɪz ɒn krijéjtɪŋ prówɡræ̀mz ðət trǽnsfɔrm sɔ́rs kówd rɪ́tən ɪn wʌ́n prówɡræ̀mɪŋ lǽŋɡwədʒ ɪntə ənʌ́ðər lǽŋɡwədʒ, tɪ́pɪkəlij ɪntə məʃíjn kówd ɔr ɪ̀ntərmíjdijət rɛ̀prəzəntéjʃənz?",
        "trans_RightAnswer": "kəmpájlər dəzájn",
        "trans_WrongAnswers": [
            "déjtəbèjs ædmɪ̀nɪstréjʃən",
            "nɛ́twɜ̀rk təpɔ́lədʒij",
            "hjúwmən-kəmpjúwtər ɪ̀ntərǽkʃən",
            "kwɑ́ntəm kəmpjúwtɪŋ",
            "kláwd ɑ́rkɪtɛ̀ktʃər"
        ],
        "trans_Explanation": "kəmpájlər dəzájn ɪz ðə ɑ́rt ənd sájəns əv krijéjtɪŋ sɔ́ftwɛ̀ər sɪ́stəmz ðət trænsléjt kówd frəm wʌ́n lǽŋɡwədʒ tə ənʌ́ðər. æt ɪts kɔ́r, ə kəmpájlər téjks sɔ́rs kówd ðət hjúwmənz kən rájt ənd ʌ̀ndərstǽnd, ənd trænsfɔ́rmz ɪt ɪntə ə fɔ́rm ðət kəmpjúwtərz kən ɛ́ksəkjùwt əfɪ́ʃəntlij. ðə prɒ́sɛs ɪnvɒ́lvz sɛ́vərəl səfɪ́stɪkèjtɪd féjzɪz ɪnklúwdɪŋ lɛ́ksɪkəl ənǽlɪsɪs (bréjkɪŋ kówd ɪntə tówkənz), sɪ́ntæ̀ks ənǽlɪsɪs (pɑ́rsɪŋ ðə strʌ́ktʃər), səmǽntɪk ənǽlɪsɪs (tʃɛ́kɪŋ míjnɪŋ), ɒptɪmɪzéjʃən (ɪmprúwvɪŋ pərfɔ́rməns), ənd kówd dʒɛ̀nəréjʃən (prədúwsɪŋ ðə tɑ́rɡət kówd). kəmpájlər dəzájn rəkwájərz díjp ʌ̀ndərstǽndɪŋ əv lǽŋɡwədʒ θíjərij, ǽlɡərɪ̀ðəmz, ənd kəmpjúwtər ɑ́rkɪtɛ̀ktʃər. wɛ́l-dəzájnd kəmpájlərz nɒt ównlij trænsléjt kówd kərɛ́ktlij bʌt ɔ́lsow prədúws əfɪ́ʃənt ɛ́ksəkjùwtəbəlz, prəvájd hɛ́lpfəl ɛ́ərər mɛ́sɪdʒɪz, ənd ɪ́mpləmənt lǽŋɡwədʒ fíjtʃərz ðət méjk prówɡræ̀mɪŋ mɔr prədʌ́ktɪv. ðɪs fíjld fʌ̀ndəmɛ́ntəlij ɛnéjbəlz ɔl sɔ́ftwɛ̀ər dəvɛ́ləpmənt baj brɪ́dʒɪŋ ðə ɡǽp bijtwíjn hjúwmən-frɛ́ndlij prówɡræ̀mɪŋ lǽŋɡwədʒɪz ənd məʃíjn-ɛ́ksəkjùwtəbəl ɪnstrʌ́kʃənz."
    },
    {
        "Question": "What is the essential software that manages hardware resources, provides common services for computer programs, and serves as an interface between applications and computer hardware?",
        "RightAnswer": "Operating Systems",
        "WrongAnswers": [
            "Compilers",
            "Database Management Systems",
            "Web Browsers",
            "Programming IDEs",
            "Network Protocols"
        ],
        "Explanation": "Operating Systems are complex software platforms that serve as intermediaries between computer hardware and the applications that run on the computer. They perform critical functions including managing computer hardware resources such as CPU allocation, memory management, and input/output operations. Operating Systems provide a consistent environment for software applications to execute without needing direct knowledge of the underlying hardware details. Common examples include Windows, macOS, Linux, Android, and iOS. They also handle file management, security controls, and user interfaces. Without an operating system, application developers would need to write code to handle all hardware interactions, making software development significantly more complex and hardware-dependent. In essence, operating systems abstract away hardware complexity while providing services that applications can rely on across different devices.",
        "trans_Question": "wɒt ɪz ðə əsɛ́nʃəl sɔ́ftwɛ̀ər ðət mǽnɪdʒɪz hɑ́rdwɛ̀ər ríjsɔrsɪz, prəvájdz kɒ́mən sɜ́rvɪsɪz fɔr kəmpjúwtər prówɡræ̀mz, ənd sɜ́rvz æz ən ɪ́ntərfèjs bijtwíjn æ̀plɪkéjʃənz ənd kəmpjúwtər hɑ́rdwɛ̀ər?",
        "trans_RightAnswer": "ɒ́pərèjtɪŋ sɪ́stəmz",
        "trans_WrongAnswers": [
            "kəmpájlərz",
            "déjtəbèjs mǽnədʒmənt sɪ́stəmz",
            "wɛ́b bráwzərz",
            "prówɡræ̀mɪŋ ajdz",
            "nɛ́twɜ̀rk prówtəkɔ̀lz"
        ],
        "trans_Explanation": "ɒ́pərèjtɪŋ sɪ́stəmz ɑr kɒ́mplɛks sɔ́ftwɛ̀ər plǽtfɔ̀rmz ðət sɜ́rv æz ɪ̀ntərmíjdijɛ̀ərijz bijtwíjn kəmpjúwtər hɑ́rdwɛ̀ər ənd ðə æ̀plɪkéjʃənz ðət rʌ́n ɒn ðə kəmpjúwtər. ðej pərfɔ́rm krɪ́tɪkəl fʌ́ŋkʃənz ɪnklúwdɪŋ mǽnɪdʒɪŋ kəmpjúwtər hɑ́rdwɛ̀ər ríjsɔrsɪz sʌtʃ æz CPU æ̀ləkéjʃən, mɛ́mərij mǽnədʒmənt, ənd ɪ́npʊ̀t/áwtpʊ̀t ɒ̀pəréjʃənz. ɒ́pərèjtɪŋ sɪ́stəmz prəvájd ə kənsɪ́stənt ənvájərənmənt fɔr sɔ́ftwɛ̀ər æ̀plɪkéjʃənz tə ɛ́ksəkjùwt wɪðáwt níjdɪŋ dɪərɛ́kt nɒ́lɪdʒ əv ðə ʌ̀ndərlájɪŋ hɑ́rdwɛ̀ər díjtejlz. kɒ́mən əɡzǽmpəlz ɪnklúwd wɪ́ndowz, mækówɛs, lɪ́nəks, ǽndrɔ̀jd, ənd ájows. ðej ɔ́lsow hǽndəl fájl mǽnədʒmənt, səkjʊ́rɪtij kəntrówlz, ənd júwzər ɪ́ntərfèjsɪz. wɪðáwt ən ɒ́pərèjtɪŋ sɪ́stəm, æ̀plɪkéjʃən dəvɛ́ləpərz wʊd níjd tə rájt kówd tə hǽndəl ɔl hɑ́rdwɛ̀ər ɪ̀ntərǽkʃənz, méjkɪŋ sɔ́ftwɛ̀ər dəvɛ́ləpmənt sɪɡnɪ́fɪkəntlij mɔr kɒ́mplɛks ənd hɑ́rdwɛ̀ər-dəpɛ́ndənt. ɪn ɛ́səns, ɒ́pərèjtɪŋ sɪ́stəmz ǽbstræ̀kt əwéj hɑ́rdwɛ̀ər kəmplɛ́ksɪtij wájl prəvájdɪŋ sɜ́rvɪsɪz ðət æ̀plɪkéjʃənz kən rəláj ɒn əkrɔ́s dɪ́fərənt dəvájsɪz."
    },
    {
        "Question": "What is the formal system that provides a structured way for humans to communicate instructions to computers, consisting of syntax and semantics that allow programmers to express algorithms and data manipulations?",
        "RightAnswer": "Programming Language",
        "WrongAnswers": [
            "Operating System",
            "Database Management System",
            "Compiler",
            "Software Development Kit",
            "Integrated Development Environment"
        ],
        "Explanation": "A Programming Language is a formal system designed to communicate instructions to a machine, particularly a computer. It allows programmers to specify precisely what data a computer should work with and how this data should be stored or transmitted, and the actions that should be taken under various circumstances. Programming languages bridge the gap between human thinking and computer execution, providing vocabulary and grammatical rules (syntax) as well as meaning (semantics) that enable the expression of algorithms. They range from low-level languages that closely represent computer hardware operations to high-level languages that abstract away hardware details, making them more accessible to human programmers. Examples include Python, Java, C++, JavaScript, and Ruby, each with unique features suited to different types of problems or programming paradigms. The evolution of programming languages reflects ongoing efforts to make computer programming more intuitive, efficient, and powerful while addressing the growing complexity of software systems.",
        "trans_Question": "wɒt ɪz ðə fɔ́rməl sɪ́stəm ðət prəvájdz ə strʌ́ktʃərd wej fɔr hjúwmənz tə kəmjúwnɪkèjt ɪnstrʌ́kʃənz tə kəmpjúwtərz, kənsɪ́stɪŋ əv sɪ́ntæ̀ks ənd səmǽntɪks ðət əláw prówɡræ̀mərz tə əksprɛ́s ǽlɡərɪ̀ðəmz ənd déjtə mənɪ̀pjəléjʃənz?",
        "trans_RightAnswer": "prówɡræ̀mɪŋ lǽŋɡwədʒ",
        "trans_WrongAnswers": [
            "ɒ́pərèjtɪŋ sɪ́stəm",
            "déjtəbèjs mǽnədʒmənt sɪ́stəm",
            "kəmpájlər",
            "sɔ́ftwɛ̀ər dəvɛ́ləpmənt kɪ́t",
            "ɪ́ntəɡrejtɪd dəvɛ́ləpmənt ənvájərənmənt"
        ],
        "trans_Explanation": "ə prówɡræ̀mɪŋ lǽŋɡwədʒ ɪz ə fɔ́rməl sɪ́stəm dəzájnd tə kəmjúwnɪkèjt ɪnstrʌ́kʃənz tə ə məʃíjn, pərtɪ́kjələrlij ə kəmpjúwtər. ɪt əláwz prówɡræ̀mərz tə spɛ́sɪfàj prəsájslij wɒt déjtə ə kəmpjúwtər ʃʊd wɜ́rk wɪð ənd háw ðɪs déjtə ʃʊd bij stɔ́rd ɔr trænsmɪ́tɪd, ənd ðə ǽkʃənz ðət ʃʊd bij téjkən ʌ́ndər vɛ́ərijəs sɜ́rkəmstæ̀nsɪz. prówɡræ̀mɪŋ lǽŋɡwədʒɪz brɪ́dʒ ðə ɡǽp bijtwíjn hjúwmən θɪ́ŋkɪŋ ənd kəmpjúwtər ɛ̀ksəkjúwʃən, prəvájdɪŋ vowkǽbjəlɛ̀ərij ənd ɡrəmǽtɪkəl rúwlz (sɪ́ntæ̀ks) æz wɛ́l æz míjnɪŋ (səmǽntɪks) ðət ɛnéjbəl ðə əksprɛ́ʃən əv ǽlɡərɪ̀ðəmz. ðej réjndʒ frəm lów-lɛ́vəl lǽŋɡwədʒɪz ðət klówslij rɛ̀prəzɛ́nt kəmpjúwtər hɑ́rdwɛ̀ər ɒ̀pəréjʃənz tə háj-lɛ́vəl lǽŋɡwədʒɪz ðət ǽbstræ̀kt əwéj hɑ́rdwɛ̀ər díjtejlz, méjkɪŋ ðɛm mɔr æksɛ́sɪbəl tə hjúwmən prówɡræ̀mərz. əɡzǽmpəlz ɪnklúwd pájθɒn, dʒɒ́və, C++, dʒɒ́vəskrɪ̀pt, ənd rúwbij, ijtʃ wɪð juwnɪ́k fíjtʃərz súwtɪd tə dɪ́fərənt tájps əv prɒ́bləmz ɔr prówɡræ̀mɪŋ pǽrədàjmz. ðə ɛ̀vəlúwʃən əv prówɡræ̀mɪŋ lǽŋɡwədʒɪz rəflɛ́kts ɒ́nɡòwɪŋ ɛ́fərts tə méjk kəmpjúwtər prówɡræ̀mɪŋ mɔr ɪntúwɪtɪv, əfɪ́ʃənt, ənd páwərfəl wájl ədrɛ́sɪŋ ðə ɡrówɪŋ kəmplɛ́ksɪtij əv sɔ́ftwɛ̀ər sɪ́stəmz."
    },
    {
        "Question": "What programming paradigm is characterized by the use of classes, objects, inheritance, encapsulation, and polymorphism to model real-world entities and their interactions?",
        "RightAnswer": "Object-Oriented Programming",
        "WrongAnswers": [
            "Functional Programming",
            "Procedural Programming",
            "Declarative Programming",
            "Event-Driven Programming",
            "Logic Programming"
        ],
        "Explanation": "Object-Oriented Programming (OOP) is a programming paradigm that organizes software design around data, or objects, rather than functions and logic. In OOP, an object is a self-contained unit that contains data (attributes) and procedures (methods) that operate on that data. The key principles of OOP include encapsulation (bundling data and methods together), inheritance (creating new classes from existing ones), polymorphism (using a single interface to represent different underlying forms), and abstraction (simplifying complex reality by modeling classes based on essential properties). This approach helps developers create modular, reusable code that mimics real-world relationships, making programs easier to understand, maintain, and extend over time. Languages like Java, C++, Python, and C# are popular for implementing OOP principles.",
        "trans_Question": "wɒt prówɡræ̀mɪŋ pǽrədàjm ɪz kǽrəktərajzd baj ðə juwz əv klǽsɪz, ɒ́bdʒɛkts, ɪnhɛ́ərɪtəns, ɛnkǽpsəlèjʃən, ənd pɒ̀lijmɔ́rfɪzm tə mɒ́dəl ríjəl-wɜ́rld ɛ́ntɪtijz ənd ðɛər ɪ̀ntərǽkʃənz?",
        "trans_RightAnswer": "ɒ́bdʒəkt-ɔ́rijɛ̀ntɪd prówɡræ̀mɪŋ",
        "trans_WrongAnswers": [
            "fʌ́ŋkʃənəl prówɡræ̀mɪŋ",
            "prəsíjdʒərəl prówɡræ̀mɪŋ",
            "dəklǽrətɪv prówɡræ̀mɪŋ",
            "əvɛ́nt-drɪ́vən prówɡræ̀mɪŋ",
            "lɒ́dʒɪk prówɡræ̀mɪŋ"
        ],
        "trans_Explanation": "ɒ́bdʒəkt-ɔ́rijɛ̀ntɪd prówɡræ̀mɪŋ (OOP) ɪz ə prówɡræ̀mɪŋ pǽrədàjm ðət ɔ́rɡənàjzɪz sɔ́ftwɛ̀ər dəzájn əráwnd déjtə, ɔr ɒ́bdʒɛkts, rǽðər ðʌn fʌ́ŋkʃənz ənd lɒ́dʒɪk. ɪn OOP, ən ɒ́bdʒəkt ɪz ə sɛ́lf-kəntéjnd júwnɪt ðət kəntéjnz déjtə (ǽtrəbjùwts) ənd prəsíjdʒərz (mɛ́θədz) ðət ɒ́pərèjt ɒn ðət déjtə. ðə kíj prɪ́nsɪpəlz əv OOP ɪnklúwd ɛnkǽpsəlèjʃən (bʌ́ndəlɪŋ déjtə ənd mɛ́θədz təɡɛ́ðər), ɪnhɛ́ərɪtəns (krijéjtɪŋ núw klǽsɪz frəm əɡzɪ́stɪŋ wʌ́nz), pɒ̀lijmɔ́rfɪzm (júwzɪŋ ə sɪ́ŋɡəl ɪ́ntərfèjs tə rɛ̀prəzɛ́nt dɪ́fərənt ʌ̀ndərlájɪŋ fɔ́rmz), ənd æbstrǽkʃən (sɪ́mpləfajɪŋ kɒ́mplɛks rìjǽlɪtij baj mɒ́dəlɪ̀ŋ klǽsɪz béjst ɒn əsɛ́nʃəl prɒ́pərtijz). ðɪs əprówtʃ hɛ́lps dəvɛ́ləpərz krijéjt mɒ́dʒələr, rijúwzəbəl kówd ðət mɪ́mɪks ríjəl-wɜ́rld rəléjʃənʃɪ̀ps, méjkɪŋ prówɡræ̀mz íjzijər tə ʌ̀ndərstǽnd, mejntéjn, ənd əkstɛ́nd ówvər tájm. lǽŋɡwədʒɪz lájk dʒɒ́və, C++, pájθɒn, ənd C# ɑr pɒ́pjələr fɔr ɪ́mpləmɛ̀ntɪŋ OOP prɪ́nsɪpəlz."
    },
    {
        "Question": "Which programming paradigm treats computation as the evaluation of mathematical functions and avoids changing-state and mutable data?",
        "RightAnswer": "Functional Programming",
        "WrongAnswers": [
            "Object-Oriented Programming",
            "Imperative Programming",
            "Procedural Programming",
            "Event-Driven Programming",
            "Logic Programming"
        ],
        "Explanation": "Functional Programming is a programming paradigm that treats computation as the evaluation of mathematical functions and avoids changing state and mutable data. In functional programming, functions are first-class citizens, meaning they can be passed as arguments to other functions, returned as values from other functions, and assigned to variables. Functional programming emphasizes the application of functions rather than changes in state. Key concepts include pure functions (functions that always produce the same output for the same input and have no side effects), immutability (data cannot be changed after creation), and higher-order functions (functions that can take other functions as parameters or return them as results). Languages commonly associated with functional programming include Haskell, Lisp, Clojure, and Scala, though many modern languages incorporate functional programming features. This approach often leads to code that is more predictable, testable, and sometimes more concise than code written in other paradigms.",
        "trans_Question": "wɪ́tʃ prówɡræ̀mɪŋ pǽrədàjm tríjts kɒ̀mpjətéjʃən æz ðə əvæ̀ljuwéjʃən əv mæ̀θəmǽtɪkəl fʌ́ŋkʃənz ənd əvɔ́jdz tʃéjndʒɪŋ-stéjt ənd mjúwtəbəl déjtə?",
        "trans_RightAnswer": "fʌ́ŋkʃənəl prówɡræ̀mɪŋ",
        "trans_WrongAnswers": [
            "ɒ́bdʒəkt-ɔ́rijɛ̀ntɪd prówɡræ̀mɪŋ",
            "ɪ̀mpɛ́ərətɪv prówɡræ̀mɪŋ",
            "prəsíjdʒərəl prówɡræ̀mɪŋ",
            "əvɛ́nt-drɪ́vən prówɡræ̀mɪŋ",
            "lɒ́dʒɪk prówɡræ̀mɪŋ"
        ],
        "trans_Explanation": "fʌ́ŋkʃənəl prówɡræ̀mɪŋ ɪz ə prówɡræ̀mɪŋ pǽrədàjm ðət tríjts kɒ̀mpjətéjʃən æz ðə əvæ̀ljuwéjʃən əv mæ̀θəmǽtɪkəl fʌ́ŋkʃənz ənd əvɔ́jdz tʃéjndʒɪŋ stéjt ənd mjúwtəbəl déjtə. ɪn fʌ́ŋkʃənəl prówɡræ̀mɪŋ, fʌ́ŋkʃənz ɑr fɜ́rst-klǽs sɪ́tɪzənz, míjnɪŋ ðej kən bij pǽst æz ɑ́rɡjəmənts tə ʌ́ðər fʌ́ŋkʃənz, rətɜ́rnd æz vǽljuwz frəm ʌ́ðər fʌ́ŋkʃənz, ənd əsájnd tə vɛ́ərijəbəlz. fʌ́ŋkʃənəl prówɡræ̀mɪŋ ɛ́mfəsajzɪz ðə æ̀plɪkéjʃən əv fʌ́ŋkʃənz rǽðər ðʌn tʃéjndʒɪz ɪn stéjt. kíj kɒ́nsɛpts ɪnklúwd pjʊ́r fʌ́ŋkʃənz (fʌ́ŋkʃənz ðət ɔ́lwejz prədúws ðə séjm áwtpʊ̀t fɔr ðə séjm ɪ́npʊ̀t ənd həv now sájd əfɛ́kts), ɪ̀mjuwtæ̀bɪ́lɪtij (déjtə kǽnɒt bij tʃéjndʒd ǽftər krijéjʃən), ənd hájər-ɔ́rdər fʌ́ŋkʃənz (fʌ́ŋkʃənz ðət kən téjk ʌ́ðər fʌ́ŋkʃənz æz pərǽmətərz ɔr rətɜ́rn ðɛm æz rəzʌ́lts). lǽŋɡwədʒɪz kɒ́mənlij əsówsijèjtɪd wɪð fʌ́ŋkʃənəl prówɡræ̀mɪŋ ɪnklúwd hǽskəl, lɪsp, klówʒər, ənd skǽlə, ðów mɛ́nij mɒ́dərn lǽŋɡwədʒɪz ɪnkɔ́rpərejt fʌ́ŋkʃənəl prówɡræ̀mɪŋ fíjtʃərz. ðɪs əprówtʃ ɔ́fən líjdz tə kówd ðət ɪz mɔr prədɪ́ktəbəl, tɛ́stəbəl, ənd sʌ́mtàjmz mɔr kənsájs ðʌn kówd rɪ́tən ɪn ʌ́ðər pǽrədàjmz."
    },
    {
        "Question": "Which programming paradigm focuses on explicitly describing the steps a computer must take to achieve a desired outcome, emphasizing the 'how' of computation through sequences of statements that change program state?",
        "RightAnswer": "Imperative Programming",
        "WrongAnswers": [
            "Declarative Programming",
            "Functional Programming",
            "Logic Programming",
            "Constraint Programming",
            "Event-Driven Programming"
        ],
        "Explanation": "Imperative Programming is a programming paradigm that uses statements to change a program's state, focusing on describing how a program should accomplish a task through explicit sequences of commands. It mirrors how we typically give instructions in everyday life, such as following a recipe with step-by-step directions. In imperative programming, the programmer dictates the exact control flow, specifying the order of operations, variable assignments, and explicit state changes. Languages like C, Pascal, and Java predominantly follow this approach. This contrasts with declarative paradigms, which focus on what the program should accomplish without explicitly specifying how to achieve it. Imperative programming is often considered more intuitive for beginners since it aligns with our natural tendency to think in terms of procedures and sequential steps, though it can lead to more verbose code and potential side effects when managing complex state changes.",
        "trans_Question": "wɪ́tʃ prówɡræ̀mɪŋ pǽrədàjm fówkəsɪz ɒn əksplɪ́sɪtlij dəskrájbɪŋ ðə stɛ́ps ə kəmpjúwtər mʌst téjk tə ətʃíjv ə dəzájərd áwtkʌ̀m, ɛ́mfəsajzɪŋ ðə 'háw' əv kɒ̀mpjətéjʃən θrúw síjkwənsɪz əv stéjtmənts ðət tʃéjndʒ prówɡræ̀m stéjt?",
        "trans_RightAnswer": "ɪ̀mpɛ́ərətɪv prówɡræ̀mɪŋ",
        "trans_WrongAnswers": [
            "dəklǽrətɪv prówɡræ̀mɪŋ",
            "fʌ́ŋkʃənəl prówɡræ̀mɪŋ",
            "lɒ́dʒɪk prówɡræ̀mɪŋ",
            "kənstréjnt prówɡræ̀mɪŋ",
            "əvɛ́nt-drɪ́vən prówɡræ̀mɪŋ"
        ],
        "trans_Explanation": "ɪ̀mpɛ́ərətɪv prówɡræ̀mɪŋ ɪz ə prówɡræ̀mɪŋ pǽrədàjm ðət júwsɪz stéjtmənts tə tʃéjndʒ ə prówɡræ̀m'z stéjt, fówkəsɪŋ ɒn dəskrájbɪŋ háw ə prówɡræ̀m ʃʊd əkɒ́mplɪʃ ə tǽsk θrúw əksplɪ́sɪt síjkwənsɪz əv kəmǽndz. ɪt mɪ́ərərz háw wij tɪ́pɪkəlij ɡɪ́v ɪnstrʌ́kʃənz ɪn ɛ́vrijdéj lájf, sʌtʃ æz fɒ́lowɪŋ ə rɛ́sɪpij wɪð stɛ́p-baj-stɛ́p dɪərɛ́kʃənz. ɪn ɪ̀mpɛ́ərətɪv prówɡræ̀mɪŋ, ðə prówɡræ̀mər dɪ́ktèjts ðə əɡzǽkt kəntrówl flów, spɛ́sɪfàjɪŋ ðə ɔ́rdər əv ɒ̀pəréjʃənz, vɛ́ərijəbəl əsájnmənts, ənd əksplɪ́sɪt stéjt tʃéjndʒɪz. lǽŋɡwədʒɪz lájk C, pǽskəl, ənd dʒɒ́və prədɒ́mɪnəntlìj fɒ́low ðɪs əprówtʃ. ðɪs kɒ́ntræs wɪð dəklǽrətɪv pǽrədàjmz, wɪ́tʃ fówkəs ɒn wɒt ðə prówɡræ̀m ʃʊd əkɒ́mplɪʃ wɪðáwt əksplɪ́sɪtlij spɛ́sɪfàjɪŋ háw tə ətʃíjv ɪt. ɪ̀mpɛ́ərətɪv prówɡræ̀mɪŋ ɪz ɔ́fən kənsɪ́dərd mɔr ɪntúwɪtɪv fɔr bəɡɪ́nərz sɪns ɪt əlájnz wɪð awər nǽtʃərəl tɛ́ndənsij tə θɪ́ŋk ɪn tɜ́rmz əv prəsíjdʒərz ənd səkwɛ́nʃəl stɛ́ps, ðów ɪt kən líjd tə mɔr vərbóws kówd ənd pətɛ́nʃəl sájd əfɛ́kts wɛ́n mǽnɪdʒɪŋ kɒ́mplɛks stéjt tʃéjndʒɪz."
    },
    {
        "Question": "Which programming paradigm focuses on describing what the program should accomplish rather than explicitly stating how to accomplish it step-by-step?",
        "RightAnswer": "Declarative Programming",
        "WrongAnswers": [
            "Procedural Programming",
            "Object-Oriented Programming",
            "Imperative Programming",
            "Event-Driven Programming",
            "Structured Programming"
        ],
        "Explanation": "Declarative Programming is a programming paradigm that expresses the logic of computation without describing its control flow. Unlike imperative programming, which uses statements that change a program's state, declarative programming focuses on specifying what the program should accomplish, not how to accomplish it. It abstracts away the execution details, allowing developers to concentrate on the desired outcome rather than the sequence of steps to achieve it. Common examples include SQL for database queries, HTML for web structure, and functional programming languages like Haskell. The beauty of declarative programming lies in its conciseness and focus on the problem domain rather than implementation details, often resulting in code that is easier to reason about, maintain, and parallelize. When you use declarative programming, you are essentially describing your desired results and letting the underlying system determine the optimal execution strategy.",
        "trans_Question": "wɪ́tʃ prówɡræ̀mɪŋ pǽrədàjm fówkəsɪz ɒn dəskrájbɪŋ wɒt ðə prówɡræ̀m ʃʊd əkɒ́mplɪʃ rǽðər ðʌn əksplɪ́sɪtlij stéjtɪŋ háw tə əkɒ́mplɪʃ ɪt stɛ́p-baj-stɛ́p?",
        "trans_RightAnswer": "dəklǽrətɪv prówɡræ̀mɪŋ",
        "trans_WrongAnswers": [
            "prəsíjdʒərəl prówɡræ̀mɪŋ",
            "ɒ́bdʒəkt-ɔ́rijɛ̀ntɪd prówɡræ̀mɪŋ",
            "ɪ̀mpɛ́ərətɪv prówɡræ̀mɪŋ",
            "əvɛ́nt-drɪ́vən prówɡræ̀mɪŋ",
            "strʌ́ktʃərd prówɡræ̀mɪŋ"
        ],
        "trans_Explanation": "dəklǽrətɪv prówɡræ̀mɪŋ ɪz ə prówɡræ̀mɪŋ pǽrədàjm ðət əksprɛ́sɪz ðə lɒ́dʒɪk əv kɒ̀mpjətéjʃən wɪðáwt dəskrájbɪŋ ɪts kəntrówl flów. ʌ̀nlájk ɪ̀mpɛ́ərətɪv prówɡræ̀mɪŋ, wɪ́tʃ júwsɪz stéjtmənts ðət tʃéjndʒ ə prówɡræ̀m'z stéjt, dəklǽrətɪv prówɡræ̀mɪŋ fówkəsɪz ɒn spɛ́sɪfàjɪŋ wɒt ðə prówɡræ̀m ʃʊd əkɒ́mplɪʃ, nɒt háw tə əkɒ́mplɪʃ ɪt. ɪt ǽbstrækts əwéj ðə ɛ̀ksəkjúwʃən díjtejlz, əláwɪŋ dəvɛ́ləpərz tə kɒ́nsəntrèjt ɒn ðə dəzájərd áwtkʌ̀m rǽðər ðʌn ðə síjkwəns əv stɛ́ps tə ətʃíjv ɪt. kɒ́mən əɡzǽmpəlz ɪnklúwd SQL fɔr déjtəbèjs kwɛ́ərijz, HTML fɔr wɛ́b strʌ́ktʃər, ənd fʌ́ŋkʃənəl prówɡræ̀mɪŋ lǽŋɡwədʒɪz lájk hǽskəl. ðə bjúwtij əv dəklǽrətɪv prówɡræ̀mɪŋ lájz ɪn ɪts kənsájsnəs ənd fówkəs ɒn ðə prɒ́bləm dowméjn rǽðər ðʌn ɪ̀mpləmɛntéjʃən díjtejlz, ɔ́fən rəzʌ́ltɪŋ ɪn kówd ðət ɪz íjzijər tə ríjzən əbawt, mejntéjn, ənd pərǽləlàjz. wɛ́n juw juwz dəklǽrətɪv prówɡræ̀mɪŋ, juw ɑr əsɛ́nʃəlij dəskrájbɪŋ jɔr dəzájərd rəzʌ́lts ənd lɛ́tɪŋ ðə ʌ̀ndərlájɪŋ sɪ́stəm dətɜ́rmɪn ðə ɒ́ptɪməl ɛ̀ksəkjúwʃən strǽtədʒij."
    },
    {
        "Question": "Which programming paradigm organizes code as a sequence of steps and focuses on breaking down tasks into reusable procedures or subroutines that operate on data?",
        "RightAnswer": "Procedural Programming",
        "WrongAnswers": [
            "Object-Oriented Programming",
            "Functional Programming",
            "Declarative Programming",
            "Event-Driven Programming",
            "Logic Programming"
        ],
        "Explanation": "Procedural Programming is a programming paradigm based on the concept of procedure calls, where programs are structured as sequences of instructions grouped into procedures (also called subroutines, routines, or functions). It emphasizes breaking down a program's tasks into a collection of variables, data structures, and reusable procedures that act upon the data. The execution follows a top-down approach, with programs starting at the first line and proceeding through a defined sequence of procedure calls. Languages like C, Pascal, and FORTRAN exemplify this paradigm. Procedural programming excels in scenarios requiring straightforward, linear processing of tasks, though it may become unwieldy for complex systems compared to paradigms like object-oriented programming, which encapsulates data and behavior together. The focus in procedural programming is on how to perform tasks and execute algorithms rather than on modeling real-world objects or relationships.",
        "trans_Question": "wɪ́tʃ prówɡræ̀mɪŋ pǽrədàjm ɔ́rɡənàjzɪz kówd æz ə síjkwəns əv stɛ́ps ənd fówkəsɪz ɒn bréjkɪŋ dawn tǽsks ɪntə rijúwzəbəl prəsíjdʒərz ɔr sʌbruwtijnz ðət ɒ́pərèjt ɒn déjtə?",
        "trans_RightAnswer": "prəsíjdʒərəl prówɡræ̀mɪŋ",
        "trans_WrongAnswers": [
            "ɒ́bdʒəkt-ɔ́rijɛ̀ntɪd prówɡræ̀mɪŋ",
            "fʌ́ŋkʃənəl prówɡræ̀mɪŋ",
            "dəklǽrətɪv prówɡræ̀mɪŋ",
            "əvɛ́nt-drɪ́vən prówɡræ̀mɪŋ",
            "lɒ́dʒɪk prówɡræ̀mɪŋ"
        ],
        "trans_Explanation": "prəsíjdʒərəl prówɡræ̀mɪŋ ɪz ə prówɡræ̀mɪŋ pǽrədàjm béjst ɒn ðə kɒ́nsɛpt əv prəsíjdʒər kɔ́lz, wɛ́ər prówɡræ̀mz ɑr strʌ́ktʃərd æz síjkwənsɪz əv ɪnstrʌ́kʃənz ɡrúwpt ɪntə prəsíjdʒərz (ɔ́lsow kɔ́ld sʌbruwtijnz, ruwtíjnz, ɔr fʌ́ŋkʃənz). ɪt ɛ́mfəsajzɪz bréjkɪŋ dawn ə prówɡræ̀m'z tǽsks ɪntə ə kəlɛ́kʃən əv vɛ́ərijəbəlz, déjtə strʌ́ktʃərz, ənd rijúwzəbəl prəsíjdʒərz ðət ǽkt əpɒ́n ðə déjtə. ðə ɛ̀ksəkjúwʃən fɒ́lowz ə tɒ́p-dawn əprówtʃ, wɪð prówɡræ̀mz stɑ́rtɪŋ æt ðə fɜ́rst lájn ənd prəsíjdɪŋ θrúw ə dəfájnd síjkwəns əv prəsíjdʒər kɔ́lz. lǽŋɡwədʒɪz lájk C, pǽskəl, ənd FORTRAN əɡzɛ́mpləfàj ðɪs pǽrədàjm. prəsíjdʒərəl prówɡræ̀mɪŋ əksɛ́lz ɪn sənɛ́ərijowz rijkwájərɪŋ stréjtfɔ́rwərd, lɪ́nijər prɒ́sɛsɪŋ əv tǽsks, ðów ɪt mej bəkʌ́m ʌ̀nwíjldij fɔr kɒ́mplɛks sɪ́stəmz kəmpɛ́ərd tə pǽrədàjmz lájk ɒ́bdʒəkt-ɔ́rijɛ̀ntɪd prówɡræ̀mɪŋ, wɪ́tʃ ɛnkǽpsjʊlejts déjtə ənd bəhéjvjər təɡɛ́ðər. ðə fówkəs ɪn prəsíjdʒərəl prówɡræ̀mɪŋ ɪz ɒn háw tə pərfɔ́rm tǽsks ənd ɛ́ksəkjùwt ǽlɡərɪ̀ðəmz rǽðər ðʌn ɒn mɒ́dəlɪ̀ŋ ríjəl-wɜ́rld ɒ́bdʒɛkts ɔr rəléjʃənʃɪ̀ps."
    },
    {
        "Question": "What is the programming technique where a function calls itself to solve a problem by breaking it down into smaller instances of the same problem?",
        "RightAnswer": "Recursion",
        "WrongAnswers": [
            "Iteration",
            "Encapsulation",
            "Polymorphism",
            "Inheritance",
            "Abstraction"
        ],
        "Explanation": "Recursion is a powerful programming technique where a function solves a problem by calling itself with simpler versions of the original problem until it reaches a base case that can be solved directly. It elegantly handles problems that have a recursive structure, such as tree traversals, factorial calculations, or the Fibonacci sequence. The key components of recursion include a base case (which provides the stopping condition) and the recursive case (where the function calls itself). While recursion can create concise and intuitive solutions, it requires careful implementation to avoid infinite recursion and can sometimes be less efficient than iterative approaches due to the overhead of multiple function calls. Many algorithms in computer science, particularly those involving divide-and-conquer strategies, are naturally expressed using recursion.",
        "trans_Question": "wɒt ɪz ðə prówɡræ̀mɪŋ tɛkníjk wɛ́ər ə fʌ́ŋkʃən kɔ́lz ɪtsɛ́lf tə sɒ́lv ə prɒ́bləm baj bréjkɪŋ ɪt dawn ɪntə smɔ́lər ɪ́nstənsɪz əv ðə séjm prɒ́bləm?",
        "trans_RightAnswer": "rəkɜ́rʒən",
        "trans_WrongAnswers": [
            "ɪ̀təréjʃən",
            "ɛnkǽpsəlèjʃən",
            "pɒ̀lijmɔ́rfɪzm",
            "ɪnhɛ́ərɪtəns",
            "æbstrǽkʃən"
        ],
        "trans_Explanation": "rəkɜ́rʒən ɪz ə páwərfəl prówɡræ̀mɪŋ tɛkníjk wɛ́ər ə fʌ́ŋkʃən sɒ́lvz ə prɒ́bləm baj kɔ́lɪŋ ɪtsɛ́lf wɪð sɪ́mplər vɜ́rʒənz əv ðə ərɪ́dʒɪnəl prɒ́bləm əntɪ́l ɪt ríjtʃɪz ə béjs kéjs ðət kən bij sɒ́lvd dɪərɛ́klij. ɪt ɛ́ləɡəntlìj hǽndəlz prɒ́bləmz ðət həv ə rəkɜ́rsɪv strʌ́ktʃər, sʌtʃ æz tríj trəvɜ́rzəlz, fæ̀ktɔ́rijəl kæ̀lkjəléjʃənz, ɔr ðə fɪ̀bənɒ́tʃij síjkwəns. ðə kíj kəmpównənts əv rəkɜ́rʒən ɪnklúwd ə béjs kéjs (wɪ́tʃ prəvájdz ðə stɒ́pɪŋ kəndɪ́ʃən) ənd ðə rəkɜ́rsɪv kéjs (wɛ́ər ðə fʌ́ŋkʃən kɔ́lz ɪtsɛ́lf). wájl rəkɜ́rʒən kən krijéjt kənsájs ənd ɪntúwɪtɪv səlúwʃənz, ɪt rəkwájərz kɛ́ərfəl ɪ̀mpləmɛntéjʃən tə əvɔ́jd ɪ́nfɪnɪt rəkɜ́rʒən ənd kən sʌ́mtàjmz bij lɛ́s əfɪ́ʃənt ðʌn ɪ́tərətɪv əprówtʃɪz djúw tə ðə ówvərhɛ́d əv mʌ́ltɪpəl fʌ́ŋkʃən kɔ́lz. mɛ́nij ǽlɡərɪ̀ðəmz ɪn kəmpjúwtər sájəns, pərtɪ́kjələrlij ðowz ɪnvɒ́lvɪŋ dɪvájd-ənd-kɒ́ŋkər strǽtədʒijz, ɑr nǽtʃərəlij əksprɛ́st júwzɪŋ rəkɜ́rʒən."
    },
    {
        "Question": "What is the term for a well-defined computational procedure that takes a collection of items as input and produces an ordered arrangement of those items as output?",
        "RightAnswer": "Sorting Algorithm",
        "WrongAnswers": [
            "Query Processor",
            "Hash Function",
            "Memory Allocator",
            "Path Finder",
            "Tree Traversal"
        ],
        "Explanation": "A Sorting Algorithm is a specific type of algorithm in computer science designed to arrange elements in a particular order, typically numerical or lexicographical. These algorithms take an unordered collection of items and reorganize them according to a predefined ordering rule. Common examples include Bubble Sort, which repeatedly steps through the list and swaps adjacent elements if they are in the wrong order; Quick Sort, which uses a divide-and-conquer strategy; and Merge Sort, which divides the input array into smaller subarrays, sorts them, and then merges them. The efficiency of sorting algorithms is measured by their time complexity and space complexity, making them a fundamental topic in algorithm analysis. They are essential in various applications, from organizing data in databases to enabling efficient searches in ordered lists.",
        "trans_Question": "wɒt ɪz ðə tɜ́rm fɔr ə wɛ́l-dəfájnd kɒ̀mpjuwtéjʃənəl prəsíjdʒər ðət téjks ə kəlɛ́kʃən əv ájtəmz æz ɪ́npʊ̀t ənd prədúwsɪz ən ɔ́rdərd əréjndʒmənt əv ðowz ájtəmz æz áwtpʊ̀t?",
        "trans_RightAnswer": "sɔ́rtɪŋ ǽlɡərɪ̀ðəm",
        "trans_WrongAnswers": [
            "kwɛ́ərij prɒ́sɛsər",
            "hǽʃ fʌ́ŋkʃən",
            "mɛ́mərij ǽləkèjtər",
            "pǽθ fájndər",
            "tríj trǽvərsəl"
        ],
        "trans_Explanation": "ə sɔ́rtɪŋ ǽlɡərɪ̀ðəm ɪz ə spəsɪ́fɪk tájp əv ǽlɡərɪ̀ðəm ɪn kəmpjúwtər sájəns dəzájnd tə əréjndʒ ɛ́ləmənts ɪn ə pərtɪ́kjələr ɔ́rdər, tɪ́pɪkəlij njuwmɛ́ərɪkəl ɔr lɛ̀ksɪkəɡrǽfɪkəl. ðijz ǽlɡərɪ̀ðəmz téjk ən ʌnɔ́rdərd kəlɛ́kʃən əv ájtəmz ənd rijɔ́rɡənàjz ðɛm əkɔ́rdɪŋ tə ə prìjdəfájnd ɔ́rdərɪŋ rúwl. kɒ́mən əɡzǽmpəlz ɪnklúwd bʌ́bəl sɔ́rt, wɪ́tʃ rəpíjtɪdlij stɛ́ps θrúw ðə lɪ́st ənd swɒ́ps ədʒéjsənt ɛ́ləmənts ɪf ðej ɑr ɪn ðə rɔ́ŋ ɔ́rdər; kwɪ́k sɔ́rt, wɪ́tʃ júwsɪz ə dɪvájd-ənd-kɒ́ŋkər strǽtədʒij; ənd mɜ́rdʒ sɔ́rt, wɪ́tʃ dɪvájdz ðə ɪ́npʊ̀t əréj ɪntə smɔ́lər sʌbəréjz, sɔ́rts ðɛm, ənd ðɛn mɜ́rdʒɪz ðɛm. ðə əfɪ́ʃənsij əv sɔ́rtɪŋ ǽlɡərɪ̀ðəmz ɪz mɛ́ʒərd baj ðɛər tájm kəmplɛ́ksɪtij ənd spéjs kəmplɛ́ksɪtij, méjkɪŋ ðɛm ə fʌ̀ndəmɛ́ntəl tɒ́pɪk ɪn ǽlɡərɪ̀ðəm ənǽlɪsɪs. ðej ɑr əsɛ́nʃəl ɪn vɛ́ərijəs æ̀plɪkéjʃənz, frəm ɔ́rɡənàjzɪŋ déjtə ɪn déjtəbèjsɪz tə ɛnéjbəlɪŋ əfɪ́ʃənt sɜ́rtʃɪz ɪn ɔ́rdərd lɪ́sts."
    },
    {
        "Question": "What is the computational technique used to locate specific data within a dataset, exemplified by methods such as binary search and linear search?",
        "RightAnswer": "Searching Algorithm",
        "WrongAnswers": [
            "Data Structure",
            "Compiler Optimization",
            "Memory Allocation Model",
            "Encryption Protocol",
            "Runtime Environment"
        ],
        "Explanation": "A Searching Algorithm is a step-by-step procedure designed to locate a specific item or value within a collection of data. These algorithms are fundamental components in computer science that enable efficient retrieval of information. Common examples include linear search, which sequentially checks each element in a dataset until finding a match, and binary search, which repeatedly divides the search space in half to quickly locate items in sorted datasets. Searching algorithms are evaluated based on their efficiency, typically measured by time complexity, which indicates how the algorithm's performance scales with increasing data size. The choice of which searching algorithm to implement depends on factors such as whether the data is sorted, its size, and the specific requirements of the application. These algorithms form the backbone of many computing operations from database queries to artificial intelligence systems, making them essential knowledge for computer scientists and programmers.",
        "trans_Question": "wɒt ɪz ðə kɒ̀mpjuwtéjʃənəl tɛkníjk júwzd tə lówkèjt spəsɪ́fɪk déjtə wɪðɪ́n ə déjtəsɛ̀t, əɡzɛ́mpləfàjd baj mɛ́θədz sʌtʃ æz bájnərij sɜ́rtʃ ənd lɪ́nijər sɜ́rtʃ?",
        "trans_RightAnswer": "sɜ́rtʃɪŋ ǽlɡərɪ̀ðəm",
        "trans_WrongAnswers": [
            "déjtə strʌ́ktʃər",
            "kəmpájlər ɒptɪmɪzéjʃən",
            "mɛ́mərij æ̀ləkéjʃən mɒ́dəl",
            "ɛnkrɪ́pʃən prówtəkɒ̀l",
            "rʌ́ntàjm ənvájərənmənt"
        ],
        "trans_Explanation": "ə sɜ́rtʃɪŋ ǽlɡərɪ̀ðəm ɪz ə stɛ́p-baj-stɛ́p prəsíjdʒər dəzájnd tə lówkèjt ə spəsɪ́fɪk ájtəm ɔr vǽljuw wɪðɪ́n ə kəlɛ́kʃən əv déjtə. ðijz ǽlɡərɪ̀ðəmz ɑr fʌ̀ndəmɛ́ntəl kəmpównənts ɪn kəmpjúwtər sájəns ðət ɛnéjbəl əfɪ́ʃənt rətríjvəl əv ɪnfərméjʃən. kɒ́mən əɡzǽmpəlz ɪnklúwd lɪ́nijər sɜ́rtʃ, wɪ́tʃ səkwɛ́nʃəlij tʃɛ́ks ijtʃ ɛ́ləmənt ɪn ə déjtəsɛ̀t əntɪ́l fájndɪŋ ə mǽtʃ, ənd bájnərij sɜ́rtʃ, wɪ́tʃ rəpíjtɪdlij dɪvájdz ðə sɜ́rtʃ spéjs ɪn hǽf tə kwɪ́klij lówkèjt ájtəmz ɪn sɔ́rtɪd déjtəsɛ̀ts. sɜ́rtʃɪŋ ǽlɡərɪ̀ðəmz ɑr əvǽljuwèjtɪd béjst ɒn ðɛər əfɪ́ʃənsij, tɪ́pɪkəlij mɛ́ʒərd baj tájm kəmplɛ́ksɪtij, wɪ́tʃ ɪ́ndɪkèjts háw ðə ǽlɡərɪ̀ðəm'z pərfɔ́rməns skéjlz wɪð ɪnkríjsɪŋ déjtə sájz. ðə tʃɔ́js əv wɪ́tʃ sɜ́rtʃɪŋ ǽlɡərɪ̀ðəm tə ɪ́mpləmənt dəpɛ́ndz ɒn fǽktərz sʌtʃ æz wɛ́ðər ðə déjtə ɪz sɔ́rtɪd, ɪts sájz, ənd ðə spəsɪ́fɪk rəkwájərmənts əv ðə æ̀plɪkéjʃən. ðijz ǽlɡərɪ̀ðəmz fɔ́rm ðə bǽkbòwn əv mɛ́nij kəmpjúwtɪŋ ɒ̀pəréjʃənz frəm déjtəbèjs kwɛ́ərijz tə ɑ̀rtɪfɪ́ʃəl ɪntɛ́lɪdʒəns sɪ́stəmz, méjkɪŋ ðɛm əsɛ́nʃəl nɒ́lɪdʒ fɔr kəmpjúwtər sájəntɪsts ənd prówɡræ̀mərz."
    },
    {
        "Question": "Which area of discrete mathematics studies networks of interconnected objects and is fundamental to algorithms like shortest path finding, network analysis, and social network modeling?",
        "RightAnswer": "Graph Theory",
        "WrongAnswers": [
            "Database Normalization",
            "Lambda Calculus",
            "Automata Theory",
            "Numerical Analysis",
            "Vector Calculus"
        ],
        "Explanation": "Graph Theory is a branch of mathematics and computer science that studies graphs, which are mathematical structures used to model pairwise relations between objects. In computer science, graphs consist of vertices (also called nodes) connected by edges (also called links or arcs). This field provides powerful tools for modeling and solving problems involving relationships and connections, such as finding the shortest path between two points, analyzing social networks, scheduling tasks, or optimizing network flows. Graph Theory underlies many fundamental algorithms like Dijkstra's algorithm, breadth-first search, depth-first search, and minimum spanning tree algorithms. Its applications span virtually every area of computer science, from artificial intelligence and machine learning to database design, computer networks, and computational biology. Understanding Graph Theory is essential for developing efficient solutions to complex computational problems that involve relationships between entities.",
        "trans_Question": "wɪ́tʃ ɛ́ərijə əv dɪskríjt mæ̀θəmǽtɪks stʌ́dijz nɛ́twɜ̀rks əv ɪ̀ntərkənɛ́ktɪd ɒ́bdʒɛkts ənd ɪz fʌ̀ndəmɛ́ntəl tə ǽlɡərɪ̀ðəmz lájk ʃɔ́rtəst pǽθ fájndɪŋ, nɛ́twɜ̀rk ənǽlɪsɪs, ənd sówʃəl nɛ́twɜ̀rk mɒ́dəlɪ̀ŋ?",
        "trans_RightAnswer": "ɡrǽf θíjərij",
        "trans_WrongAnswers": [
            "déjtəbèjs nɔ̀rməlɪzéjʃən",
            "lǽmdə kǽlkjələs",
            "ɔtɒ́mətə θíjərij",
            "njuwmɛ́ərɪkəl ənǽlɪsɪs",
            "vɛ́ktər kǽlkjələs"
        ],
        "trans_Explanation": "ɡrǽf θíjərij ɪz ə brǽntʃ əv mæ̀θəmǽtɪks ənd kəmpjúwtər sájəns ðət stʌ́dijz ɡrǽfs, wɪ́tʃ ɑr mæ̀θəmǽtɪkəl strʌ́ktʃərz júwzd tə mɒ́dəl pɛ́ərwajz rəléjʃənz bijtwíjn ɒ́bdʒɛkts. ɪn kəmpjúwtər sájəns, ɡrǽfs kənsɪ́st əv vɜ́rtɪsìjz (ɔ́lsow kɔ́ld nówdz) kənɛ́ktɪd baj ɛ́dʒɪz (ɔ́lsow kɔ́ld lɪ́ŋks ɔr ɑ́rks). ðɪs fíjld prəvájdz páwərfəl túwlz fɔr mɒ́dəlɪ̀ŋ ənd sɒ́lvɪŋ prɒ́bləmz ɪnvɒ́lvɪŋ rəléjʃənʃɪ̀ps ənd kənɛ́kʃənz, sʌtʃ æz fájndɪŋ ðə ʃɔ́rtəst pǽθ bijtwíjn túw pɔ́jnts, ǽnəlàjzɪŋ sówʃəl nɛ́twɜ̀rks, skɛ́dʒuwlɪŋ tǽsks, ɔr ɒ́ptɪmàjzɪŋ nɛ́twɜ̀rk flówz. ɡrǽf θíjərij ʌ̀ndərlájz mɛ́nij fʌ̀ndəmɛ́ntəl ǽlɡərɪ̀ðəmz lájk dájkstrə'z ǽlɡərɪ̀ðəm, brɛ́dθ-fɜ́rst sɜ́rtʃ, dɛ́pθ-fɜ́rst sɜ́rtʃ, ənd mɪ́nɪməm spǽnɪŋ tríj ǽlɡərɪ̀ðəmz. ɪts æ̀plɪkéjʃənz spǽn vɜ́rtʃuwəlij ɛvərij ɛ́ərijə əv kəmpjúwtər sájəns, frəm ɑ̀rtɪfɪ́ʃəl ɪntɛ́lɪdʒəns ənd məʃíjn lɜ́rnɪŋ tə déjtəbèjs dəzájn, kəmpjúwtər nɛ́twɜ̀rks, ənd kɒ̀mpjuwtéjʃənəl bajɒ́lədʒij. ʌ̀ndərstǽndɪŋ ɡrǽf θíjərij ɪz əsɛ́nʃəl fɔr dəvɛ́ləpɪŋ əfɪ́ʃənt səlúwʃənz tə kɒ́mplɛks kɒ̀mpjuwtéjʃənəl prɒ́bləmz ðət ɪnvɒ́lv rəléjʃənʃɪ̀ps bijtwíjn ɛ́ntɪtijz."
    },
    {
        "Question": "In computer networking, what term describes the physical or logical arrangement of nodes and connections in a network, which can be represented in designs like star, ring, mesh, or bus?",
        "RightAnswer": "Network Topology",
        "WrongAnswers": [
            "Protocol Stack",
            "Bandwidth Distribution",
            "Network Segmentation",
            "Packet Switching",
            "Address Resolution"
        ],
        "Explanation": "Network Topology refers to the way in which nodes and connections are arranged in a computer network. It describes the physical or logical layout of network components and how they connect to one another. Common topologies include star (where all nodes connect to a central hub), ring (where each node connects to exactly two other nodes, forming a circular pathway), mesh (where nodes have multiple connections creating redundant paths), and bus (where all nodes connect to a single communication line). The choice of topology significantly impacts network performance, reliability, scalability, and cost. Network administrators must consider factors such as distance between nodes, traffic patterns, and failure resilience when selecting a topology. Understanding network topology is fundamental to network design, troubleshooting, and optimization in modern computing environments.",
        "trans_Question": "ɪn kəmpjúwtər nɛ́twɜ̀rkɪŋ, wɒt tɜ́rm dəskrájbz ðə fɪ́zɪkəl ɔr lɒ́dʒɪkəl əréjndʒmənt əv nówdz ənd kənɛ́kʃənz ɪn ə nɛ́twɜ̀rk, wɪ́tʃ kən bij rɛ̀prəzɛ́ntɪd ɪn dəzájnz lájk stɑ́r, rɪ́ŋ, mɛ́ʃ, ɔr bʌ́s?",
        "trans_RightAnswer": "nɛ́twɜ̀rk təpɔ́lədʒij",
        "trans_WrongAnswers": [
            "prówtəkɒ̀l stǽk",
            "bǽndwɪdθ dɪ̀strəbjúwʃən",
            "nɛ́twɜ̀rk sɛ̀ɡməntéjʃən",
            "pǽkət swɪ́tʃɪŋ",
            "æ̀drɛ́s rɛ̀zəlúwʃən"
        ],
        "trans_Explanation": "nɛ́twɜ̀rk təpɔ́lədʒij rəfɜ́rz tə ðə wej ɪn wɪ́tʃ nówdz ənd kənɛ́kʃənz ɑr əréjndʒd ɪn ə kəmpjúwtər nɛ́twɜ̀rk. ɪt dəskrájbz ðə fɪ́zɪkəl ɔr lɒ́dʒɪkəl léjàwt əv nɛ́twɜ̀rk kəmpównənts ənd háw ðej kənɛ́kt tə wʌ́n ənʌ́ðər. kɒ́mən təpɒ́lədʒijz ɪnklúwd stɑ́r (wɛ́ər ɔl nówdz kənɛ́kt tə ə sɛ́ntrəl hʌ́b), rɪ́ŋ (wɛ́ər ijtʃ nówd kənɛ́kts tə əɡzǽktlij túw ʌ́ðər nówdz, fɔ́rmɪŋ ə sɜ́rkjələr pǽθwèj), mɛ́ʃ (wɛ́ər nówdz həv mʌ́ltɪpəl kənɛ́kʃənz krijéjtɪŋ rədʌ́ndənt pǽðz), ənd bʌ́s (wɛ́ər ɔl nówdz kənɛ́kt tə ə sɪ́ŋɡəl kəmjùwnɪkéjʃən lájn). ðə tʃɔ́js əv təpɔ́lədʒij sɪɡnɪ́fɪkəntlij ɪ́mpækts nɛ́twɜ̀rk pərfɔ́rməns, rəlàjəbɪ́lɪtij, skéjləbɪ́lɪtij, ənd kɒ́st. nɛ́twɜ̀rk ædmɪ́nɪstrèjtərz mʌst kənsɪ́dər fǽktərz sʌtʃ æz dɪ́stəns bijtwíjn nówdz, trǽfɪk pǽtərnz, ənd féjljər rəzɪ́lijəns wɛ́n səlɛ́ktɪŋ ə təpɔ́lədʒij. ʌ̀ndərstǽndɪŋ nɛ́twɜ̀rk təpɔ́lədʒij ɪz fʌ̀ndəmɛ́ntəl tə nɛ́twɜ̀rk dəzájn, trʌ́bəlʃùwtɪŋ, ənd ɒptɪmɪzéjʃən ɪn mɒ́dərn kəmpjúwtɪŋ ənvájərənmənts."
    },
    {
        "Question": "Which computing approach involves breaking down large problems into smaller ones that can be processed simultaneously across multiple processors or computers to achieve faster solutions?",
        "RightAnswer": "Parallel Computing",
        "WrongAnswers": [
            "Sequential Computing",
            "Cloud Computing",
            "Quantum Computing",
            "Distributed Processing",
            "Grid Computing"
        ],
        "Explanation": "Parallel Computing is a computational approach where multiple calculations or processes are carried out simultaneously. Instead of executing instructions one after another as in traditional sequential computing, parallel computing breaks down complex problems into smaller parts that can be solved concurrently. These parts are then processed simultaneously across multiple computational resources such as processors, cores, or separate computers. By harnessing the collective power of multiple processing units working in coordination, parallel computing significantly reduces the time needed to solve computationally intensive problems. This approach is particularly valuable in fields requiring massive calculations like weather forecasting, genetic analysis, physics simulations, and artificial intelligence. The effectiveness of parallel computing depends on how well a problem can be divided into independent tasks and how efficiently these tasks can communicate with each other when necessary.",
        "trans_Question": "wɪ́tʃ kəmpjúwtɪŋ əprówtʃ ɪnvɒ́lvz bréjkɪŋ dawn lɑ́rdʒ prɒ́bləmz ɪntə smɔ́lər wʌ́nz ðət kən bij prɒ́sɛst sàjməltéjnijəslij əkrɔ́s mʌ́ltɪpəl prɒ́sɛsərz ɔr kəmpjúwtərz tə ətʃíjv fǽstər səlúwʃənz?",
        "trans_RightAnswer": "pǽrəlɛ̀l kəmpjúwtɪŋ",
        "trans_WrongAnswers": [
            "səkwɛ́nʃəl kəmpjúwtɪŋ",
            "kláwd kəmpjúwtɪŋ",
            "kwɑ́ntəm kəmpjúwtɪŋ",
            "dɪstrɪ́bjətɪd prɒ́sɛsɪŋ",
            "ɡrɪ́d kəmpjúwtɪŋ"
        ],
        "trans_Explanation": "pǽrəlɛ̀l kəmpjúwtɪŋ ɪz ə kɒ̀mpjuwtéjʃənəl əprówtʃ wɛ́ər mʌ́ltɪpəl kæ̀lkjəléjʃənz ɔr prɒ́sɛsɪz ɑr kǽrijd awt sàjməltéjnijəslij. ɪnstɛ́d əv ɛ́ksəkjùwtɪŋ ɪnstrʌ́kʃənz wʌ́n ǽftər ənʌ́ðər æz ɪn trədɪ́ʃənəl səkwɛ́nʃəl kəmpjúwtɪŋ, pǽrəlɛ̀l kəmpjúwtɪŋ bréjks dawn kɒ́mplɛks prɒ́bləmz ɪntə smɔ́lər pɑ́rts ðət kən bij sɒ́lvd kənkɜ́rəntlij. ðijz pɑ́rts ɑr ðɛn prɒ́sɛst sàjməltéjnijəslij əkrɔ́s mʌ́ltɪpəl kɒ̀mpjuwtéjʃənəl ríjsɔrsɪz sʌtʃ æz prɒ́sɛsərz, kɔ́rz, ɔr sɛ́pərət kəmpjúwtərz. baj hɑ́rnəsɪŋ ðə kəlɛ́ktɪv páwər əv mʌ́ltɪpəl prɒ́sɛsɪŋ júwnɪts wɜ́rkɪŋ ɪn kowɔ̀rdɪnéjʃən, pǽrəlɛ̀l kəmpjúwtɪŋ sɪɡnɪ́fɪkəntlij rədjúwsɪz ðə tájm níjdɪd tə sɒ́lv kɒ̀mpjətéjʃənəlij ɪntɛ́nsɪv prɒ́bləmz. ðɪs əprówtʃ ɪz pərtɪ́kjələrlij vǽljəbəl ɪn fíjldz rijkwájərɪŋ mǽsɪv kæ̀lkjəléjʃənz lájk wɛ́ðər fɔ́rkæ̀stɪŋ, dʒənɛ́tɪk ənǽlɪsɪs, fɪ́zɪks sɪ̀mjəléjʃənz, ənd ɑ̀rtɪfɪ́ʃəl ɪntɛ́lɪdʒəns. ðə əfɛ́ktɪvnəs əv pǽrəlɛ̀l kəmpjúwtɪŋ dəpɛ́ndz ɒn háw wɛ́l ə prɒ́bləm kən bij dɪvájdɪd ɪntə ɪndəpɛ́ndənt tǽsks ənd háw əfɪ́ʃəntlij ðijz tǽsks kən kəmjúwnɪkèjt wɪð ijtʃ ʌ́ðər wɛ́n nɛ́səsɛ̀ərij."
    },
    {
        "Question": "What term describes the computer science paradigm where components of a software system are located on computers connected through a network but work together as a unified system?",
        "RightAnswer": "Distributed Systems",
        "WrongAnswers": [
            "Sequential Programming",
            "Monolithic Architecture",
            "Quantum Computing",
            "Memory Segmentation",
            "Linear Processing"
        ],
        "Explanation": "Distributed Systems represent a fundamental approach in computer science where multiple computers or nodes operate as a single coherent system while being physically separated across a network. Unlike traditional monolithic systems where all components run on a single machine, distributed systems divide workloads and responsibilities across multiple interconnected machines. This architecture offers numerous advantages including increased fault tolerance (if one machine fails, others can continue operating), improved scalability (additional machines can be added to handle growing workloads), and enhanced performance through parallel processing. However, distributed systems also introduce complex challenges such as maintaining data consistency across nodes, handling network latency and failures, coordinating actions between components, and ensuring proper synchronization. Examples of distributed systems include cloud computing platforms, content delivery networks, peer-to-peer systems like BitTorrent, and large-scale databases that span multiple servers. The field continues to evolve with technologies like blockchain, microservices architecture, and edge computing all representing modern implementations of distributed system principles.",
        "trans_Question": "wɒt tɜ́rm dəskrájbz ðə kəmpjúwtər sájəns pǽrədàjm wɛ́ər kəmpównənts əv ə sɔ́ftwɛ̀ər sɪ́stəm ɑr lówkèjtɪd ɒn kəmpjúwtərz kənɛ́ktɪd θrúw ə nɛ́twɜ̀rk bʌt wɜ́rk təɡɛ́ðər æz ə júwnɪfàjd sɪ́stəm?",
        "trans_RightAnswer": "dɪstrɪ́bjətɪd sɪ́stəmz",
        "trans_WrongAnswers": [
            "səkwɛ́nʃəl prówɡræ̀mɪŋ",
            "mɒ̀nəlɪ́θɪk ɑ́rkɪtɛ̀ktʃər",
            "kwɑ́ntəm kəmpjúwtɪŋ",
            "mɛ́mərij sɛ̀ɡməntéjʃən",
            "lɪ́nijər prɒ́sɛsɪŋ"
        ],
        "trans_Explanation": "dɪstrɪ́bjətɪd sɪ́stəmz rɛ̀prəzɛ́nt ə fʌ̀ndəmɛ́ntəl əprówtʃ ɪn kəmpjúwtər sájəns wɛ́ər mʌ́ltɪpəl kəmpjúwtərz ɔr nówdz ɒ́pərèjt æz ə sɪ́ŋɡəl kowhɪ́ərənt sɪ́stəm wájl bíjɪŋ fɪ́zɪkəlij sɛ́pərèjtɪd əkrɔ́s ə nɛ́twɜ̀rk. ʌ̀nlájk trədɪ́ʃənəl mɒ̀nəlɪ́θɪk sɪ́stəmz wɛ́ər ɔl kəmpównənts rʌ́n ɒn ə sɪ́ŋɡəl məʃíjn, dɪstrɪ́bjətɪd sɪ́stəmz dɪvájd wɜ́rklòwdz ənd rəspɒ̀nsɪbɪ́lɪtijz əkrɔ́s mʌ́ltɪpəl ɪ̀ntərkənɛ́ktɪd məʃíjnz. ðɪs ɑ́rkɪtɛ̀ktʃər ɔ́fərz njúwmərəs ədvǽntɪdʒɪz ɪnklúwdɪŋ ɪnkríjst fɔ́lt tɒ́lərəns (ɪf wʌ́n məʃíjn féjlz, ʌ́ðərz kən kəntɪ́njuw ɒ́pərèjtɪŋ), ɪmprúwvd skéjləbɪ́lɪtij (ədɪ́ʃənəl məʃíjnz kən bij ǽdɪd tə hǽndəl ɡrówɪŋ wɜ́rklòwdz), ənd ənhǽnst pərfɔ́rməns θrúw pǽrəlɛ̀l prɒ́sɛsɪŋ. hàwɛ́vər, dɪstrɪ́bjətɪd sɪ́stəmz ɔ́lsow ɪntrədúws kɒ́mplɛks tʃǽləndʒɪz sʌtʃ æz mejntéjnɪŋ déjtə kənsɪ́stənsij əkrɔ́s nówdz, hǽndəlɪŋ nɛ́twɜ̀rk léjtənsij ənd féjljərz, kowɔ́rdɪnèjtɪŋ ǽkʃənz bijtwíjn kəmpównənts, ənd ɛnʃʊ́rɪŋ prɒ́pər sɪ̀ŋkrənɪzéjʃən. əɡzǽmpəlz əv dɪstrɪ́bjətɪd sɪ́stəmz ɪnklúwd kláwd kəmpjúwtɪŋ plǽtfɔ̀rmz, kɒ́ntənt dəlɪ́vərij nɛ́twɜ̀rks, pɪ́ər-tə-pɪ́ər sɪ́stəmz lájk bɪ́ttɔ̀rənt, ənd lɑ́rdʒ-skéjl déjtəbèjsɪz ðət spǽn mʌ́ltɪpəl sɜ́rvərz. ðə fíjld kəntɪ́njuwz tə əvɒ́lv wɪð tɛknɒ́lədʒijz lájk blɒ́ktʃéjn, májkrowsɜ́rvɪsɪz ɑ́rkɪtɛ̀ktʃər, ənd ɛ́dʒ kəmpjúwtɪŋ ɔl rɛ̀prəzɛ́ntɪŋ mɒ́dərn ɪ̀mpləmɛntéjʃənz əv dɪstrɪ́bjətɪd sɪ́stəm prɪ́nsɪpəlz."
    },
    {
        "Question": "What term describes the ability of a system to execute multiple operations at the same time, allowing a program to make progress on more than one task simultaneously?",
        "RightAnswer": "Concurrency",
        "WrongAnswers": [
            "Parallelism",
            "Multitasking",
            "Synchronization",
            "Threading",
            "Asynchronicity"
        ],
        "Explanation": "Concurrency in computer science refers to the ability of a system to handle multiple tasks in overlapping time periods, giving the appearance of simultaneous execution. Unlike true parallelism, which requires multiple processors or cores, concurrency can be achieved even on a single processor through techniques like context switching. Concurrent systems manage multiple tasks that are in progress at the same time, though not necessarily executing at the exact same moment. This concept is fundamental to modern operating systems, web servers, and applications that need to remain responsive while performing multiple operations. Concurrency introduces challenges like race conditions and deadlocks, requiring special programming techniques such as locks, semaphores, and message passing to ensure correct program behavior. Understanding concurrency is essential for developing efficient, responsive software in today's computing environments.",
        "trans_Question": "wɒt tɜ́rm dəskrájbz ðə əbɪ́lɪtij əv ə sɪ́stəm tə ɛ́ksəkjùwt mʌ́ltɪpəl ɒ̀pəréjʃənz æt ðə séjm tájm, əláwɪŋ ə prówɡræ̀m tə méjk prɒ́ɡrɛ̀s ɒn mɔr ðʌn wʌ́n tǽsk sàjməltéjnijəslij?",
        "trans_RightAnswer": "kənkɜ́rənsij",
        "trans_WrongAnswers": [
            "pǽrəlɛ̀lɪ̀zəm",
            "mʌ́ltijtæ̀skɪŋ",
            "sɪ̀ŋkrənɪzéjʃən",
            "θrɛ́dɪŋ",
            "ejsɪ̀ŋkrənɪ́sɪtij"
        ],
        "trans_Explanation": "kənkɜ́rənsij ɪn kəmpjúwtər sájəns rəfɜ́rz tə ðə əbɪ́lɪtij əv ə sɪ́stəm tə hǽndəl mʌ́ltɪpəl tǽsks ɪn ówvərlæ̀pɪŋ tájm pɪ́ərijədz, ɡɪ́vɪŋ ðə əpɪ́ərəns əv sàjməltéjnijəs ɛ̀ksəkjúwʃən. ʌ̀nlájk trúw pǽrəlɛ̀lɪ̀zəm, wɪ́tʃ rəkwájərz mʌ́ltɪpəl prɒ́sɛsərz ɔr kɔ́rz, kənkɜ́rənsij kən bij ətʃíjvd íjvən ɒn ə sɪ́ŋɡəl prɒ́sɛsər θrúw tɛkníjks lájk kɒ́ntɛkst swɪ́tʃɪŋ. kənkɜ́rənt sɪ́stəmz mǽnɪdʒ mʌ́ltɪpəl tǽsks ðət ɑr ɪn prɒ́ɡrɛ̀s æt ðə séjm tájm, ðów nɒt nɛ̀səsɛ́ərɪlij ɛ́ksəkjùwtɪŋ æt ðə əɡzǽkt séjm mówmənt. ðɪs kɒ́nsɛpt ɪz fʌ̀ndəmɛ́ntəl tə mɒ́dərn ɒ́pərèjtɪŋ sɪ́stəmz, wɛ́b sɜ́rvərz, ənd æ̀plɪkéjʃənz ðət níjd tə rəméjn rəspɒ́nsɪv wájl pərfɔ́rmɪŋ mʌ́ltɪpəl ɒ̀pəréjʃənz. kənkɜ́rənsij ɪntrədúwsɪz tʃǽləndʒɪz lájk réjs kəndɪ́ʃənz ənd dɛ́dlɒ̀ks, rijkwájərɪŋ spɛ́ʃəl prówɡræ̀mɪŋ tɛkníjks sʌtʃ æz lɒ́ks, sɛ́məfòwrz, ənd mɛ́sɪdʒ pǽsɪŋ tə ənʃʊ́r kərɛ́kt prówɡræ̀m bəhéjvjər. ʌ̀ndərstǽndɪŋ kənkɜ́rənsij ɪz əsɛ́nʃəl fɔr dəvɛ́ləpɪŋ əfɪ́ʃənt, rəspɒ́nsɪv sɔ́ftwɛ̀ər ɪn tədéj'z kəmpjúwtɪŋ ənvájərənmənts."
    },
    {
        "Question": "Which programming technique allows a program to execute multiple code paths simultaneously within a single process, enhancing efficiency by utilizing available CPU resources more effectively?",
        "RightAnswer": "Multithreading",
        "WrongAnswers": [
            "Circuit switching",
            "Memory paging",
            "Packet forwarding",
            "Register allocation",
            "Resource pooling"
        ],
        "Explanation": "Multithreading is a programming and execution model that enables a single process to have multiple code segments (threads) running concurrently. Think of it like having several assistants working on different parts of the same project simultaneously, rather than one person completing each task sequentially. Each thread maintains its own execution state, including program counter and stack, while sharing the same memory space with other threads in the process. This allows for improved application responsiveness, better resource utilization, and enhanced performance on multi-core processors. Multithreading is particularly valuable for applications that need to perform multiple operations at once, such as handling user interface responses while processing data in the background. However, it introduces challenges like thread synchronization and potential race conditions that developers must carefully manage. Modern operating systems and programming languages provide various tools and libraries to facilitate effective multithreaded programming.",
        "trans_Question": "wɪ́tʃ prówɡræ̀mɪŋ tɛkníjk əláwz ə prówɡræ̀m tə ɛ́ksəkjùwt mʌ́ltɪpəl kówd pǽðz sàjməltéjnijəslij wɪðɪ́n ə sɪ́ŋɡəl prɒ́sɛs, ɛnhǽnsɪŋ əfɪ́ʃənsij baj júwtɪlàjzɪŋ əvéjləbəl CPU ríjsɔrsɪz mɔr əfɛ́ktɪvlij?",
        "trans_RightAnswer": "mʌ̀ltijθrɛ́dɪŋ",
        "trans_WrongAnswers": [
            "sɜ́rkət swɪ́tʃɪŋ",
            "mɛ́mərij péjdʒɪŋ",
            "pǽkət fɔ́rwərdɪŋ",
            "rɛ́dʒɪstər æ̀ləkéjʃən",
            "ríjsɔrs púwlɪŋ"
        ],
        "trans_Explanation": "mʌ̀ltijθrɛ́dɪŋ ɪz ə prówɡræ̀mɪŋ ənd ɛ̀ksəkjúwʃən mɒ́dəl ðət ɛnéjbəlz ə sɪ́ŋɡəl prɒ́sɛs tə həv mʌ́ltɪpəl kówd sɛ́ɡmənts (θrɛ́dz) rʌ́nɪŋ kənkɜ́rəntlij. θɪ́ŋk əv ɪt lájk hǽvɪŋ sɛ́vərəl əsɪ́stənts wɜ́rkɪŋ ɒn dɪ́fərənt pɑ́rts əv ðə séjm prɒ́dʒɛkt sàjməltéjnijəslij, rǽðər ðʌn wʌ́n pɜ́rsən kəmplíjtɪŋ ijtʃ tǽsk səkwɛ́nʃəlij. ijtʃ θrɛ́d mejntéjnz ɪts ówn ɛ̀ksəkjúwʃən stéjt, ɪnklúwdɪŋ prówɡræ̀m káwntər ənd stǽk, wájl ʃɛ́ərɪŋ ðə séjm mɛ́mərij spéjs wɪð ʌ́ðər θrɛ́dz ɪn ðə prɒ́sɛs. ðɪs əláwz fɔr ɪmprúwvd æ̀plɪkéjʃən rəspɒ́nsɪvnəs, bɛ́tər ríjsɔrs jùwtɪlɪzéjʃən, ənd ənhǽnst pərfɔ́rməns ɒn mʌ́ltij-kɔ́r prɒ́sɛsərz. mʌ̀ltijθrɛ́dɪŋ ɪz pərtɪ́kjələrlij vǽljəbəl fɔr æ̀plɪkéjʃənz ðət níjd tə pərfɔ́rm mʌ́ltɪpəl ɒ̀pəréjʃənz æt wʌ́ns, sʌtʃ æz hǽndəlɪŋ júwzər ɪ́ntərfèjs rəspɒ́nsɪz wájl prɒ́sɛsɪŋ déjtə ɪn ðə bǽkɡràwnd. hàwɛ́vər, ɪt ɪntrədúwsɪz tʃǽləndʒɪz lájk θrɛ́d sɪ̀ŋkrənɪzéjʃən ənd pətɛ́nʃəl réjs kəndɪ́ʃənz ðət dəvɛ́ləpərz mʌst kɛ́ərfəlij mǽnɪdʒ. mɒ́dərn ɒ́pərèjtɪŋ sɪ́stəmz ənd prówɡræ̀mɪŋ lǽŋɡwədʒɪz prəvájd vɛ́ərijəs túwlz ənd lájbrɛərìjz tə fəsɪ́lətèjt əféktɪv mʌ́ltijθrɛ̀dɪd prówɡræ̀mɪŋ."
    },
    {
        "Question": "Which computer science term describes a situation where two or more processes are unable to proceed because each is waiting for resources held by another, resulting in a standstill?",
        "RightAnswer": "Deadlock",
        "WrongAnswers": [
            "Race condition",
            "Starvation",
            "Thread blocking",
            "Priority inversion",
            "Mutex violation"
        ],
        "Explanation": "A deadlock in computer science occurs when two or more processes become permanently stuck, unable to continue execution because each is waiting for resources that are held by another process in the same group. Think of it like a traffic gridlock where four cars at an intersection each want to go forward but none can move because the space is blocked by another car. In computing systems, deadlocks typically involve processes competing for limited resources such as memory, file locks, or database connections. For a deadlock to occur, four conditions must be present simultaneously: mutual exclusion (resources cannot be shared), hold and wait (processes hold resources while waiting for others), no preemption (resources cannot be forcibly taken away), and circular wait (a closed chain of processes waiting for resources). Deadlocks can cause system hangs and require intervention through techniques like deadlock prevention, avoidance, detection, or recovery mechanisms.",
        "trans_Question": "wɪ́tʃ kəmpjúwtər sájəns tɜ́rm dəskrájbz ə sɪ̀tʃuwéjʃən wɛ́ər túw ɔr mɔr prɒ́sɛsɪz ɑr ənéjbəl tə prəsíjd bəkɒ́z ijtʃ ɪz wéjtɪŋ fɔr ríjsɔrsɪz hɛ́ld baj ənʌ́ðər, rəzʌ́ltɪŋ ɪn ə stǽndstɪ̀l?",
        "trans_RightAnswer": "dɛ́dlɒ̀k",
        "trans_WrongAnswers": [
            "réjs kəndɪ́ʃən",
            "stɑrvéjʃən",
            "θrɛ́d blɒ́kɪŋ",
            "prajɔ́rɪtij ɪnvɜ́rʒən",
            "mʌ́tɛks vajəléjʃən"
        ],
        "trans_Explanation": "ə dɛ́dlɒ̀k ɪn kəmpjúwtər sájəns əkɜ́rz wɛ́n túw ɔr mɔr prɒ́sɛsɪz bəkʌ́m pɜ́rmənəntlij stʌ́k, ənéjbəl tə kəntɪ́njuw ɛ̀ksəkjúwʃən bəkɒ́z ijtʃ ɪz wéjtɪŋ fɔr ríjsɔrsɪz ðət ɑr hɛ́ld baj ənʌ́ðər prɒ́sɛs ɪn ðə séjm ɡrúwp. θɪ́ŋk əv ɪt lájk ə trǽfɪk ɡrɪ́dlɒ̀k wɛ́ər fɔ́r kɑ́rz æt ən ɪ̀ntərsɛ́kʃən ijtʃ wɒ́nt tə ɡow fɔ́rwərd bʌt nən kən múwv bəkɒ́z ðə spéjs ɪz blɒ́kt baj ənʌ́ðər kɑ́r. ɪn kəmpjúwtɪŋ sɪ́stəmz, dɛ́dlɒ̀ks tɪ́pɪkəlij ɪnvɒ́lv prɒ́sɛsɪz kəmpíjtɪŋ fɔr lɪ́mɪtɪd ríjsɔrsɪz sʌtʃ æz mɛ́mərij, fájl lɒ́ks, ɔr déjtəbèjs kənɛ́kʃənz. fɔr ə dɛ́dlɒ̀k tə əkɜ́r, fɔ́r kəndɪ́ʃənz mʌst bij prɛ́zənt sàjməltéjnijəslij: mjúwtʃuwəl əksklúwʒən (ríjsɔrsɪz kǽnɒt bij ʃɛ́ərd), hówld ənd wéjt (prɒ́sɛsɪz hówld ríjsɔrsɪz wájl wéjtɪŋ fɔr ʌ́ðərz), now prìjɛ́mpʃən (ríjsɔrsɪz kǽnɒt bij fɔ́rsəblij téjkən əwéj), ənd sɜ́rkjələr wéjt (ə klówzd tʃéjn əv prɒ́sɛsɪz wéjtɪŋ fɔr ríjsɔrsɪz). dɛ́dlɒ̀ks kən kɒ́z sɪ́stəm hǽŋz ənd rəkwájər ɪ̀ntərvɛ́nʃən θrúw tɛkníjks lájk dɛ́dlɒ̀k prəvɛ́nʃən, əvɔ́jdəns, dətɛ́kʃən, ɔr rəkʌ́vərij mɛ́kənɪzəmz."
    },
    {
        "Question": "What is the process of coordinating multiple threads or processes to ensure they access shared resources in a controlled, non-interfering manner to prevent race conditions?",
        "RightAnswer": "Synchronization",
        "WrongAnswers": [
            "Virtualization",
            "Parallelization",
            "Fragmentation",
            "Multiplexing",
            "Encapsulation"
        ],
        "Explanation": "Synchronization in computer science refers to the coordination of multiple concurrent operations to ensure they work together harmoniously, especially when accessing shared resources. Imagine multiple cooks in a kitchen trying to use the same knife or cutting board—without coordination, chaos ensues. Similarly, when multiple threads or processes in a computer system attempt to access the same memory location or file simultaneously, they can interfere with each other, causing unpredictable results known as race conditions. Synchronization mechanisms such as locks, semaphores, and monitors act as traffic controllers, establishing rules about when and how shared resources can be accessed. For example, a lock ensures only one thread can modify data at a time, while others must wait their turn. This coordination prevents data corruption and ensures predictable program behavior in concurrent environments like operating systems, databases, and multi-threaded applications. While synchronization is essential for correctness, it can introduce performance bottlenecks because it may force processes to wait, so efficient synchronization design is a critical skill in modern software development.",
        "trans_Question": "wɒt ɪz ðə prɒ́sɛs əv kowɔ́rdɪnèjtɪŋ mʌ́ltɪpəl θrɛ́dz ɔr prɒ́sɛsɪz tə ənʃʊ́r ðej ǽksɛ̀s ʃɛ́ərd ríjsɔrsɪz ɪn ə kəntrówld, nɒn-ɪ̀ntəfɪ́ərɪŋ mǽnər tə prəvɛ́nt réjs kəndɪ́ʃənz?",
        "trans_RightAnswer": "sɪ̀ŋkrənɪzéjʃən",
        "trans_WrongAnswers": [
            "vɜ̀rtʃuwəlɪzéjʃən",
            "pæ̀rələlɪzéjʃən",
            "fræ̀ɡməntéjʃən",
            "mʌ̀ltijplɛ́ksɪŋ",
            "ɛnkǽpsəlèjʃən"
        ],
        "trans_Explanation": "sɪ̀ŋkrənɪzéjʃən ɪn kəmpjúwtər sájəns rəfɜ́rz tə ðə kowɔ̀rdɪnéjʃən əv mʌ́ltɪpəl kənkɜ́rənt ɒ̀pəréjʃənz tə ənʃʊ́r ðej wɜ́rk təɡɛ́ðər hɑrmównijəslij, əspɛ́ʃəlij wɛ́n ǽksɛ̀sɪŋ ʃɛ́ərd ríjsɔrsɪz. ɪmǽdʒɪn mʌ́ltɪpəl kʊ́ks ɪn ə kɪ́tʃən trájɪŋ tə juwz ðə séjm nájf ɔr kʌ́tɪŋ bɔ́rd—wɪðáwt kowɔ̀rdɪnéjʃən, kéjɒs ənsúwz. sɪ́mɪlərlij, wɛ́n mʌ́ltɪpəl θrɛ́dz ɔr prɒ́sɛsɪz ɪn ə kəmpjúwtər sɪ́stəm ətɛ́mpt tə ǽksɛ̀s ðə séjm mɛ́mərij lowkéjʃən ɔr fájl sàjməltéjnijəslij, ðej kən ɪ̀ntəfɪ́ər wɪð ijtʃ ʌ́ðər, kɒ́zɪŋ ʌ̀nprədɪ́ktəbəl rəzʌ́lts nówn æz réjs kəndɪ́ʃənz. sɪ̀ŋkrənɪzéjʃən mɛ́kənɪzəmz sʌtʃ æz lɒ́ks, sɛ́məfòwrz, ənd mɒ́nɪtərz ǽkt æz trǽfɪk kəntrówlərz, əstǽblɪʃɪŋ rúwlz əbawt wɛ́n ənd háw ʃɛ́ərd ríjsɔrsɪz kən bij ǽksɛ̀st. fɔr əɡzǽmpəl, ə lɒ́k ənʃʊ́rz ównlij wʌ́n θrɛ́d kən mɒ́dɪfàj déjtə æt ə tájm, wájl ʌ́ðərz mʌst wéjt ðɛər tɜ́rn. ðɪs kowɔ̀rdɪnéjʃən prəvɛ́nts déjtə kərʌ́pʃən ənd ənʃʊ́rz prədɪ́ktəbəl prówɡræ̀m bəhéjvjər ɪn kənkɜ́rənt ənvájərənmənts lájk ɒ́pərèjtɪŋ sɪ́stəmz, déjtəbèjsɪz, ənd mʌ́ltij-θrɛ́dɪd æ̀plɪkéjʃənz. wájl sɪ̀ŋkrənɪzéjʃən ɪz əsɛ́nʃəl fɔr kərɛ́ktnəs, ɪt kən ɪntrədúws pərfɔ́rməns bɒ́təlnɛ̀ks bəkɒ́z ɪt mej fɔ́rs prɒ́sɛsɪz tə wéjt, sow əfɪ́ʃənt sɪ̀ŋkrənɪzéjʃən dəzájn ɪz ə krɪ́tɪkəl skɪ́l ɪn mɒ́dərn sɔ́ftwɛ̀ər dəvɛ́ləpmənt."
    },
    {
        "Question": "What is the term for the process of coordinating and controlling a computer's primary memory to efficiently allocate and deallocate resources between various programs and processes?",
        "RightAnswer": "Memory Management",
        "WrongAnswers": [
            "Resource Allocation",
            "Process Scheduling",
            "Address Translation",
            "Cache Optimization",
            "Garbage Collection"
        ],
        "Explanation": "Memory Management refers to the essential function within operating systems that controls and coordinates computer memory, determining how to allocate and deallocate memory space among competing programs and processes. It involves tracking which portions of memory are in use, which are available, and ensuring programs can access memory when needed without interfering with other processes. Effective memory management prevents memory leaks, reduces fragmentation, and maximizes available resources. It encompasses techniques like virtual memory, which creates the illusion of more memory than physically exists by using disk space as an extension, and various allocation algorithms that determine how memory is assigned. Memory management is fundamental to system stability, application performance, and efficient multitasking operations in modern computing environments.",
        "trans_Question": "wɒt ɪz ðə tɜ́rm fɔr ðə prɒ́sɛs əv kowɔ́rdɪnèjtɪŋ ənd kəntrówlɪŋ ə kəmpjúwtər'z prájmɛ̀ərij mɛ́mərij tə əfɪ́ʃəntlij ǽləkèjt ənd ədɛ́ləkejt ríjsɔrsɪz bijtwíjn vɛ́ərijəs prówɡræ̀mz ənd prɒ́sɛsɪz?",
        "trans_RightAnswer": "mɛ́mərij mǽnədʒmənt",
        "trans_WrongAnswers": [
            "ríjsɔrs æ̀ləkéjʃən",
            "prɒ́sɛs skɛ́dʒuwlɪŋ",
            "æ̀drɛ́s trænsléjʃən",
            "kǽʃ ɒptɪmɪzéjʃən",
            "ɡɑ́rbɪdʒ kəlɛ́kʃən"
        ],
        "trans_Explanation": "mɛ́mərij mǽnədʒmənt rəfɜ́rz tə ðə əsɛ́nʃəl fʌ́ŋkʃən wɪðɪ́n ɒ́pərèjtɪŋ sɪ́stəmz ðət kəntrówlz ənd kowɔ́rdɪnèjts kəmpjúwtər mɛ́mərij, dətɜ́rmɪnɪŋ háw tə ǽləkèjt ənd ədɛ́ləkejt mɛ́mərij spéjs əmʌ́ŋ kəmpíjtɪŋ prówɡræ̀mz ənd prɒ́sɛsɪz. ɪt ɪnvɒ́lvz trǽkɪŋ wɪ́tʃ pɔ́rʃənz əv mɛ́mərij ɑr ɪn juwz, wɪ́tʃ ɑr əvéjləbəl, ənd ɛnʃʊ́rɪŋ prówɡræ̀mz kən ǽksɛ̀s mɛ́mərij wɛ́n níjdɪd wɪðáwt ɪ̀ntəfɪ́ərɪŋ wɪð ʌ́ðər prɒ́sɛsɪz. əféktɪv mɛ́mərij mǽnədʒmənt prəvɛ́nts mɛ́mərij líjks, rədjúwsɪz fræ̀ɡməntéjʃən, ənd mǽksɪmàjzɪz əvéjləbəl ríjsɔrsɪz. ɪt ɛnkʌ́mpəsɪz tɛkníjks lájk vɜ́rtʃuwəl mɛ́mərij, wɪ́tʃ krijéjts ðə ɪ̀lúwʒən əv mɔr mɛ́mərij ðʌn fɪ́zɪkəlij əɡzɪ́sts baj júwzɪŋ dɪ́sk spéjs æz ən əkstɛ́nʃən, ənd vɛ́ərijəs æ̀ləkéjʃən ǽlɡərɪ̀ðəmz ðət dətɜ́rmɪn háw mɛ́mərij ɪz əsájnd. mɛ́mərij mǽnədʒmənt ɪz fʌ̀ndəmɛ́ntəl tə sɪ́stəm stəbɪ́lɪtij, æ̀plɪkéjʃən pərfɔ́rməns, ənd əfɪ́ʃənt mʌ́ltijtæ̀skɪŋ ɒ̀pəréjʃənz ɪn mɒ́dərn kəmpjúwtɪŋ ənvájərənmənts."
    },
    {
        "Question": "In C and C++ programming, what is the term for a variable that stores the memory address of another variable, allowing for indirect access to that variable's value?",
        "RightAnswer": "Pointers",
        "WrongAnswers": [
            "Accessors",
            "References",
            "Indexers",
            "Selectors",
            "Allocators"
        ],
        "Explanation": "Pointers are special variables in computer programming that store memory addresses rather than actual data values. They 'point to' the location in memory where data is stored, acting like a signpost rather than containing the data itself. Pointers are particularly important in languages like C and C++ where they enable powerful features such as dynamic memory allocation, efficient passing of large data structures, and implementation of complex data structures like linked lists and trees. When you use a pointer, you can indirectly access or modify the data at the address it points to through a process called dereferencing. While powerful, pointers require careful handling as improper use can lead to program crashes or security vulnerabilities through issues like memory leaks or buffer overflows. Understanding pointers is often considered a significant milestone in a programmer's journey because they provide insights into how computers manage memory at a fundamental level.",
        "trans_Question": "ɪn C ənd C++ prówɡræ̀mɪŋ, wɒt ɪz ðə tɜ́rm fɔr ə vɛ́ərijəbəl ðət stɔ́rz ðə mɛ́mərij æ̀drɛ́s əv ənʌ́ðər vɛ́ərijəbəl, əláwɪŋ fɔr ɪ̀ndɪərɛ́kt ǽksɛ̀s tə ðət vɛ́ərijəbəl'z vǽljuw?",
        "trans_RightAnswer": "pɔ́jntərz",
        "trans_WrongAnswers": [
            "əksɛ́sərz",
            "rɛ́fərənsɪz",
            "ɪ́ndɛ̀ksərz",
            "səlɛ́ktərz",
            "ǽləkèjtərz"
        ],
        "trans_Explanation": "pɔ́jntərz ɑr spɛ́ʃəl vɛ́ərijəbəlz ɪn kəmpjúwtər prówɡræ̀mɪŋ ðət stɔ́r mɛ́mərij ǽdrɛ́sɪz rǽðər ðʌn ǽktʃəl déjtə vǽljuwz. ðej 'pɔ́jnt tə' ðə lowkéjʃən ɪn mɛ́mərij wɛ́ər déjtə ɪz stɔ́rd, ǽktɪŋ lájk ə sájnpòwst rǽðər ðʌn kəntéjnɪŋ ðə déjtə ɪtsɛ́lf. pɔ́jntərz ɑr pərtɪ́kjələrlij ɪmpɔ́rtənt ɪn lǽŋɡwədʒɪz lájk C ənd C++ wɛ́ər ðej ɛnéjbəl páwərfəl fíjtʃərz sʌtʃ æz dajnǽmɪk mɛ́mərij æ̀ləkéjʃən, əfɪ́ʃənt pǽsɪŋ əv lɑ́rdʒ déjtə strʌ́ktʃərz, ənd ɪ̀mpləmɛntéjʃən əv kɒ́mplɛks déjtə strʌ́ktʃərz lájk lɪ́ŋkt lɪ́sts ənd tríjz. wɛ́n juw juwz ə pɔ́jntər, juw kən ɪ̀ndɪərɛ́ktlij ǽksɛ̀s ɔr mɒ́dɪfàj ðə déjtə æt ðə æ̀drɛ́s ɪt pɔ́jnts tə θrúw ə prɒ́sɛs kɔ́ld dìjərɛfərənsɪ́ŋ. wájl páwərfəl, pɔ́jntərz rəkwájər kɛ́ərfəl hǽndəlɪŋ æz ɪ̀mprɒ́pər juwz kən líjd tə prówɡræ̀m krǽʃɪz ɔr səkjʊ́rɪtij vʌ̀lnərəbɪ́lɪtijz θrúw ɪ́ʃuwz lájk mɛ́mərij líjks ɔr bʌ́fər ówvərflòwz. ʌ̀ndərstǽndɪŋ pɔ́jntərz ɪz ɔ́fən kənsɪ́dərd ə sɪɡnɪ́fɪkənt májlstòwn ɪn ə prówɡræ̀mər'z dʒɜ́rnij bəkɒ́z ðej prəvájd ɪ́nsàjts ɪntə háw kəmpjúwtərz mǽnɪdʒ mɛ́mərij æt ə fʌ̀ndəmɛ́ntəl lɛ́vəl."
    },
    {
        "Question": "What data structure consists of a sequence of elements where each element points to the next, allowing for efficient insertion and deletion operations but sacrificing direct access to individual elements?",
        "RightAnswer": "Linked List",
        "WrongAnswers": [
            "Hash Table",
            "Binary Tree",
            "Queue Array",
            "Heap Structure",
            "Indexed Vector"
        ],
        "Explanation": "A Linked List is a fundamental data structure in computer science that consists of nodes, where each node contains both data and a reference (or pointer) to the next node in the sequence. Unlike arrays that store elements in contiguous memory locations, linked lists can be scattered throughout memory, connected only by these references. This structure provides significant advantages for dynamic data manipulation, as inserting or removing elements requires only changing a few pointers rather than shifting many elements. However, this flexibility comes at a cost: to access the nth element, you must traverse from the beginning, following each pointer until you reach your target position. Linked lists come in several variations, including singly linked (with pointers only to the next node), doubly linked (with pointers to both next and previous nodes), and circular linked lists (where the last node points back to the first). They serve as building blocks for more complex data structures and are particularly useful when the size of data is unknown or frequently changing.",
        "trans_Question": "wɒt déjtə strʌ́ktʃər kənsɪ́sts əv ə síjkwəns əv ɛ́ləmənts wɛ́ər ijtʃ ɛ́ləmənt pɔ́jnts tə ðə nɛ́kst, əláwɪŋ fɔr əfɪ́ʃənt ɪnsɜ́rʃən ənd dəlíjʃən ɒ̀pəréjʃənz bʌt sǽkrɪfàjsɪŋ dɪərɛ́kt ǽksɛ̀s tə ɪndɪvɪ́dʒəwəl ɛ́ləmənts?",
        "trans_RightAnswer": "lɪ́ŋkt lɪ́st",
        "trans_WrongAnswers": [
            "hǽʃ téjbəl",
            "bájnərij tríj",
            "kjúw əréj",
            "híjp strʌ́ktʃər",
            "ɪ́ndɛkst vɛ́ktər"
        ],
        "trans_Explanation": "ə lɪ́ŋkt lɪ́st ɪz ə fʌ̀ndəmɛ́ntəl déjtə strʌ́ktʃər ɪn kəmpjúwtər sájəns ðət kənsɪ́sts əv nówdz, wɛ́ər ijtʃ nówd kəntéjnz bówθ déjtə ənd ə rɛ́fərəns (ɔr pɔ́jntər) tə ðə nɛ́kst nówd ɪn ðə síjkwəns. ʌ̀nlájk əréjz ðət stɔ́r ɛ́ləmənts ɪn kəntɪ́ɡjuwəs mɛ́mərij lowkéjʃənz, lɪ́ŋkt lɪ́sts kən bij skǽtərd θruwáwt mɛ́mərij, kənɛ́ktɪd ównlij baj ðijz rɛ́fərənsɪz. ðɪs strʌ́ktʃər prəvájdz sɪɡnɪ́fɪkənt ədvǽntɪdʒɪz fɔr dajnǽmɪk déjtə mənɪ̀pjəléjʃən, æz ɪnsɜ́rtɪŋ ɔr rijmúwvɪŋ ɛ́ləmənts rəkwájərz ównlij tʃéjndʒɪŋ ə fjúw pɔ́jntərz rǽðər ðʌn ʃɪ́ftɪŋ mɛ́nij ɛ́ləmənts. hàwɛ́vər, ðɪs flɛ̀ksɪbɪ́lɪtij kʌ́mz æt ə kɒ́st: tə ǽksɛ̀s ðə ɛ́nθ ɛ́ləmənt, juw mʌst trǽvərs frəm ðə bəɡɪ́nɪŋ, fɒ́lowɪŋ ijtʃ pɔ́jntər əntɪ́l juw ríjtʃ jɔr tɑ́rɡət pəzɪ́ʃən. lɪ́ŋkt lɪ́sts kʌ́m ɪn sɛ́vərəl vɛ̀ərijéjʃənz, ɪnklúwdɪŋ sɪ́ŋɡlij lɪ́ŋkt (wɪð pɔ́jntərz ównlij tə ðə nɛ́kst nówd), dʌ́blij lɪ́ŋkt (wɪð pɔ́jntərz tə bówθ nɛ́kst ənd príjvijəs nówdz), ənd sɜ́rkjələr lɪ́ŋkt lɪ́sts (wɛ́ər ðə lǽst nówd pɔ́jnts bǽk tə ðə fɜ́rst). ðej sɜ́rv æz bɪ́ldɪŋ blɒ́ks fɔr mɔr kɒ́mplɛks déjtə strʌ́ktʃərz ənd ɑr pərtɪ́kjələrlij júwsfəl wɛ́n ðə sájz əv déjtə ɪz ʌ̀nnówn ɔr fríjkwəntlij tʃéjndʒɪŋ."
    },
    {
        "Question": "Which data structure is best described as a collection of elements identified by an index or key, allowing direct access to any element through its position, and stored in a contiguous block of memory?",
        "RightAnswer": "Array",
        "WrongAnswers": [
            "Linked List",
            "Hash Table",
            "Tree",
            "Queue",
            "Stack"
        ],
        "Explanation": "An Array is one of the most fundamental data structures in computer science, consisting of a collection of elements stored at contiguous memory locations. Each element in an array is identified by an index or a key, which allows for direct and immediate access to any element based on its position. Arrays provide efficient random access to elements with a time complexity of O(1), making them ideal for situations where elements need to be accessed frequently by their position. Arrays have a fixed size in many programming languages, which means their capacity must be defined at creation time, though dynamic arrays can grow as needed. They are particularly useful for implementing other data structures and algorithms, such as matrices, heaps, and sorting algorithms. However, arrays have limitations, such as inefficient insertion and deletion operations, especially when elements need to be shifted. Despite these constraints, arrays remain essential in programming due to their simplicity and efficiency for storing and accessing sequential data.",
        "trans_Question": "wɪ́tʃ déjtə strʌ́ktʃər ɪz bɛ́st dəskrájbd æz ə kəlɛ́kʃən əv ɛ́ləmənts ajdɛ́ntɪfàjd baj ən ɪ́ndɛks ɔr kíj, əláwɪŋ dɪərɛ́kt ǽksɛ̀s tə ɛ́nij ɛ́ləmənt θrúw ɪts pəzɪ́ʃən, ənd stɔ́rd ɪn ə kəntɪ́ɡjuwəs blɒ́k əv mɛ́mərij?",
        "trans_RightAnswer": "əréj",
        "trans_WrongAnswers": [
            "lɪ́ŋkt lɪ́st",
            "hǽʃ téjbəl",
            "tríj",
            "kjúw",
            "stǽk"
        ],
        "trans_Explanation": "ən əréj ɪz wʌ́n əv ðə mówst fʌ̀ndəmɛ́ntəl déjtə strʌ́ktʃərz ɪn kəmpjúwtər sájəns, kənsɪ́stɪŋ əv ə kəlɛ́kʃən əv ɛ́ləmənts stɔ́rd æt kəntɪ́ɡjuwəs mɛ́mərij lowkéjʃənz. ijtʃ ɛ́ləmənt ɪn ən əréj ɪz ajdɛ́ntɪfàjd baj ən ɪ́ndɛks ɔr ə kíj, wɪ́tʃ əláwz fɔr dɪərɛ́kt ənd ɪmíjdijət ǽksɛ̀s tə ɛ́nij ɛ́ləmənt béjst ɒn ɪts pəzɪ́ʃən. əréjz prəvájd əfɪ́ʃənt rǽndəm ǽksɛ̀s tə ɛ́ləmənts wɪð ə tájm kəmplɛ́ksɪtij əv O(1), méjkɪŋ ðɛm ajdíjəl fɔr sɪ̀tʃuwéjʃənz wɛ́ər ɛ́ləmənts níjd tə bij ǽksɛ̀st fríjkwəntlij baj ðɛər pəzɪ́ʃən. əréjz həv ə fɪ́kst sájz ɪn mɛ́nij prówɡræ̀mɪŋ lǽŋɡwədʒɪz, wɪ́tʃ míjnz ðɛər kəpǽsɪtij mʌst bij dəfájnd æt krijéjʃən tájm, ðów dajnǽmɪk əréjz kən ɡrów æz níjdɪd. ðej ɑr pərtɪ́kjələrlij júwsfəl fɔr ɪ́mpləmɛ̀ntɪŋ ʌ́ðər déjtə strʌ́ktʃərz ənd ǽlɡərɪ̀ðəmz, sʌtʃ æz méjtrɪsɪz, híjps, ənd sɔ́rtɪŋ ǽlɡərɪ̀ðəmz. hàwɛ́vər, əréjz həv lɪ̀mɪtéjʃənz, sʌtʃ æz ɪ̀nəfɪ́ʃənt ɪnsɜ́rʃən ənd dəlíjʃən ɒ̀pəréjʃənz, əspɛ́ʃəlij wɛ́n ɛ́ləmənts níjd tə bij ʃɪ́ftɪd. dəspájt ðijz kənstréjnts, əréjz rəméjn əsɛ́nʃəl ɪn prówɡræ̀mɪŋ djúw tə ðɛər sɪmplɪ́sɪtij ənd əfɪ́ʃənsij fɔr stɔ́rɪŋ ənd ǽksɛ̀sɪŋ səkwɛ́nʃəl déjtə."
    },
    {
        "Question": "In computer science, which data structure follows the Last-In-First-Out (LIFO) principle where elements are added and removed from the same end?",
        "RightAnswer": "Stack",
        "WrongAnswers": [
            "Queue",
            "Linked List",
            "Hash Table",
            "Binary Tree",
            "Heap"
        ],
        "Explanation": "A Stack is a fundamental data structure in computer science that operates on the Last-In-First-Out (LIFO) principle. This means that the most recently added element is the first one to be removed, similar to a stack of plates where you can only take the top plate. Stacks have two primary operations: push, which adds an element to the top, and pop, which removes the top element. Stacks are used extensively in programming for function calls, expression evaluation, backtracking algorithms, and undo mechanisms in applications. The beauty of stacks lies in their simplicity and efficiency for these types of operations, making them one of the most important building blocks in algorithm design and software development.",
        "trans_Question": "ɪn kəmpjúwtər sájəns, wɪ́tʃ déjtə strʌ́ktʃər fɒ́lowz ðə lǽst-ɪn-fɜ́rst-awt (LIFO) prɪ́nsɪpəl wɛ́ər ɛ́ləmənts ɑr ǽdɪd ənd rijmúwvd frəm ðə séjm ɛ́nd?",
        "trans_RightAnswer": "stǽk",
        "trans_WrongAnswers": [
            "kjúw",
            "lɪ́ŋkt lɪ́st",
            "hǽʃ téjbəl",
            "bájnərij tríj",
            "híjp"
        ],
        "trans_Explanation": "ə stǽk ɪz ə fʌ̀ndəmɛ́ntəl déjtə strʌ́ktʃər ɪn kəmpjúwtər sájəns ðət ɒ́pərèjts ɒn ðə lǽst-ɪn-fɜ́rst-awt (LIFO) prɪ́nsɪpəl. ðɪs míjnz ðət ðə mówst ríjsəntlij ǽdɪd ɛ́ləmənt ɪz ðə fɜ́rst wʌ́n tə bij rijmúwvd, sɪ́mɪlər tə ə stǽk əv pléjts wɛ́ər juw kən ównlij téjk ðə tɒ́p pléjt. stǽks həv túw prájmɛ̀ərij ɒ̀pəréjʃənz: pʊ́ʃ, wɪ́tʃ ǽdz ən ɛ́ləmənt tə ðə tɒ́p, ənd pɒ́p, wɪ́tʃ rijmúwvz ðə tɒ́p ɛ́ləmənt. stǽks ɑr júwzd əkstɛ́nsɪvlij ɪn prówɡræ̀mɪŋ fɔr fʌ́ŋkʃən kɔ́lz, əksprɛ́ʃən əvæ̀ljuwéjʃən, bǽktræ̀kɪŋ ǽlɡərɪ̀ðəmz, ənd ʌ̀ndúw mɛ́kənɪzəmz ɪn æ̀plɪkéjʃənz. ðə bjúwtij əv stǽks lájz ɪn ðɛər sɪmplɪ́sɪtij ənd əfɪ́ʃənsij fɔr ðijz tájps əv ɒ̀pəréjʃənz, méjkɪŋ ðɛm wʌ́n əv ðə mówst ɪmpɔ́rtənt bɪ́ldɪŋ blɒ́ks ɪn ǽlɡərɪ̀ðəm dəzájn ənd sɔ́ftwɛ̀ər dəvɛ́ləpmənt."
    },
    {
        "Question": "Which data structure follows the 'First-In-First-Out' (FIFO) principle, where the first element added is the first one to be removed?",
        "RightAnswer": "Queue",
        "WrongAnswers": [
            "Stack",
            "Heap",
            "Binary Tree",
            "Hash Table",
            "Linked List"
        ],
        "Explanation": "A Queue is a fundamental data structure in computer science that operates on the First-In-First-Out (FIFO) principle. Think of it like a line of people waiting for a bus: the person who arrives first gets to board first. In computing, when you add an element to a queue (called an enqueue operation), it goes to the back of the line. When you remove an element (called a dequeue operation), it comes from the front of the line. Queues are incredibly useful for managing tasks that need to be processed in the exact order they were received, such as print jobs, process scheduling in operating systems, or handling requests to a web server. They provide a fair and predictable way to manage data that must be processed sequentially, making them essential in many algorithms and system designs.",
        "trans_Question": "wɪ́tʃ déjtə strʌ́ktʃər fɒ́lowz ðə 'fɜ́rst-ɪn-fɜ́rst-awt' (FIFO) prɪ́nsɪpəl, wɛ́ər ðə fɜ́rst ɛ́ləmənt ǽdɪd ɪz ðə fɜ́rst wʌ́n tə bij rijmúwvd?",
        "trans_RightAnswer": "kjúw",
        "trans_WrongAnswers": [
            "stǽk",
            "híjp",
            "bájnərij tríj",
            "hǽʃ téjbəl",
            "lɪ́ŋkt lɪ́st"
        ],
        "trans_Explanation": "ə kjúw ɪz ə fʌ̀ndəmɛ́ntəl déjtə strʌ́ktʃər ɪn kəmpjúwtər sájəns ðət ɒ́pərèjts ɒn ðə fɜ́rst-ɪn-fɜ́rst-awt (FIFO) prɪ́nsɪpəl. θɪ́ŋk əv ɪt lájk ə lájn əv píjpəl wéjtɪŋ fɔr ə bʌ́s: ðə pɜ́rsən huw ərájvz fɜ́rst ɡɛ́ts tə bɔ́rd fɜ́rst. ɪn kəmpjúwtɪŋ, wɛ́n juw ǽd ən ɛ́ləmənt tə ə kjúw (kɔ́ld ən ɪnkjúw ɒ̀pəréjʃən), ɪt ɡówz tə ðə bǽk əv ðə lájn. wɛ́n juw rijmúwv ən ɛ́ləmənt (kɔ́ld ə dɪkjúw ɒ̀pəréjʃən), ɪt kʌ́mz frəm ðə frʌ́nt əv ðə lájn. kjúwz ɑr ɪnkrɛ́dɪblij júwsfəl fɔr mǽnɪdʒɪŋ tǽsks ðət níjd tə bij prɒ́sɛst ɪn ðə əɡzǽkt ɔ́rdər ðej wɜ́r rəsíjvd, sʌtʃ æz prɪ́nt dʒɒ́bz, prɒ́sɛs skɛ́dʒuwlɪŋ ɪn ɒ́pərèjtɪŋ sɪ́stəmz, ɔr hǽndəlɪŋ rəkwɛ́s tə ə wɛ́b sɜ́rvər. ðej prəvájd ə fɛ́ər ənd prədɪ́ktəbəl wej tə mǽnɪdʒ déjtə ðət mʌst bij prɒ́sɛst səkwɛ́nʃəlij, méjkɪŋ ðɛm əsɛ́nʃəl ɪn mɛ́nij ǽlɡərɪ̀ðəmz ənd sɪ́stəm dəzájnz."
    },
    {
        "Question": "Which hierarchical data structure in computer science represents elements with parent-child relationships where each element can have multiple children but only one parent, commonly used for file systems, organization charts, and search algorithms?",
        "RightAnswer": "Tree",
        "WrongAnswers": [
            "Queue",
            "Hash Table",
            "Stack",
            "Linked List",
            "Array"
        ],
        "Explanation": "A Tree in computer science is a widely used hierarchical data structure that organizes elements in a parent-child relationship. Unlike linear data structures such as arrays or linked lists, a tree branches out, with each element (called a node) potentially having multiple children but exactly one parent (except for the topmost node, called the root, which has no parent). This structure naturally represents hierarchical relationships found in real-world scenarios like file systems, family genealogies, and organizational charts. Trees enable efficient searching, insertion, and deletion operations, forming the foundation for many algorithms and applications. Common tree variants include binary trees (where each node has at most two children), binary search trees (organized to facilitate searching), AVL trees (self-balancing), and B-trees (optimized for storage systems). The concept of trees provides an intuitive and efficient way to organize and navigate complex relationships between data elements.",
        "trans_Question": "wɪ́tʃ hàjərɑ́rkɪkəl déjtə strʌ́ktʃər ɪn kəmpjúwtər sájəns rɛ̀prəzɛ́nts ɛ́ləmənts wɪð pɛ́ərənt-tʃájld rəléjʃənʃɪ̀ps wɛ́ər ijtʃ ɛ́ləmənt kən həv mʌ́ltɪpəl tʃɪ́ldrən bʌt ównlij wʌ́n pɛ́ərənt, kɒ́mənlij júwzd fɔr fájl sɪ́stəmz, ɔ̀rɡənɪzéjʃən tʃɑ́rts, ənd sɜ́rtʃ ǽlɡərɪ̀ðəmz?",
        "trans_RightAnswer": "tríj",
        "trans_WrongAnswers": [
            "kjúw",
            "hǽʃ téjbəl",
            "stǽk",
            "lɪ́ŋkt lɪ́st",
            "əréj"
        ],
        "trans_Explanation": "ə tríj ɪn kəmpjúwtər sájəns ɪz ə wájdlij júwzd hàjərɑ́rkɪkəl déjtə strʌ́ktʃər ðət ɔ́rɡənàjzɪz ɛ́ləmənts ɪn ə pɛ́ərənt-tʃájld rəléjʃənʃɪ̀p. ʌ̀nlájk lɪ́nijər déjtə strʌ́ktʃərz sʌtʃ æz əréjz ɔr lɪ́ŋkt lɪ́sts, ə tríj brǽntʃɪz awt, wɪð ijtʃ ɛ́ləmənt (kɔ́ld ə nówd) pətɛ́nʃəlij hǽvɪŋ mʌ́ltɪpəl tʃɪ́ldrən bʌt əɡzǽktlij wʌ́n pɛ́ərənt (əksɛ́pt fɔr ðə tɒpmowst nówd, kɔ́ld ðə rúwt, wɪ́tʃ həz now pɛ́ərənt). ðɪs strʌ́ktʃər nǽtʃərəlij rɛ̀prəzɛ́nts hàjərɑ́rkɪkəl rəléjʃənʃɪ̀ps fáwnd ɪn ríjəl-wɜ́rld sənɛ́ərijowz lájk fájl sɪ́stəmz, fǽmɪlij dʒɛ̀nəlɒ́dʒijz, ənd ɔ̀rɡənɪzéjʃənəl tʃɑ́rts. tríjz ɛnéjbəl əfɪ́ʃənt sɜ́rtʃɪŋ, ɪnsɜ́rʃən, ənd dəlíjʃən ɒ̀pəréjʃənz, fɔ́rmɪŋ ðə fawndéjʃən fɔr mɛ́nij ǽlɡərɪ̀ðəmz ənd æ̀plɪkéjʃənz. kɒ́mən tríj vɛ́ərijənts ɪnklúwd bájnərij tríjz (wɛ́ər ijtʃ nówd həz æt mówst túw tʃɪ́ldrən), bájnərij sɜ́rtʃ tríjz (ɔ́rɡənàjzd tə fəsɪ́lətèjt sɜ́rtʃɪŋ), AVL tríjz (sɛ́lf-bǽlənsɪŋ), ənd b-tríjz (ɒ́ptɪmàjzd fɔr stɔ́rɪdʒ sɪ́stəmz). ðə kɒ́nsɛpt əv tríjz prəvájdz ən ɪntúwɪtɪv ənd əfɪ́ʃənt wej tə ɔ́rɡənàjz ənd nǽvɪɡejt kɒ́mplɛks rəléjʃənʃɪ̀ps bijtwíjn déjtə ɛ́ləmənts."
    },
    {
        "Question": "Which data structure consists of nodes, where each node has at most two children, often referred to as the left child and right child?",
        "RightAnswer": "Binary Tree",
        "WrongAnswers": [
            "Hash Table",
            "Linked List",
            "Priority Queue",
            "Graph Matrix",
            "Circular Buffer"
        ],
        "Explanation": "A Binary Tree is a hierarchical data structure in which each node has at most two children, typically referred to as the left child and the right child. This structure begins with a root node at the top and branches downward, creating a tree-like arrangement. Binary trees are widely used in computer science for efficient data organization, searching, and sorting. They form the foundation for more specialized structures like binary search trees, which maintain a specific ordering of elements for fast lookups, and heaps, which are used in priority queue implementations. The elegance of binary trees lies in their recursive nature: each child of a node is itself the root of a smaller binary tree, allowing for powerful recursive algorithms for traversal and manipulation. Different traversal methods such as in-order, pre-order, and post-order provide various ways to process the tree's data in specific sequences. Binary trees strike a balance between the simplicity of arrays and the flexibility of more complex data structures, making them essential in algorithm design and software development.",
        "trans_Question": "wɪ́tʃ déjtə strʌ́ktʃər kənsɪ́sts əv nówdz, wɛ́ər ijtʃ nówd həz æt mówst túw tʃɪ́ldrən, ɔ́fən rəfɜ́rd tə æz ðə lɛ́ft tʃájld ənd rájt tʃájld?",
        "trans_RightAnswer": "bájnərij tríj",
        "trans_WrongAnswers": [
            "hǽʃ téjbəl",
            "lɪ́ŋkt lɪ́st",
            "prajɔ́rɪtij kjúw",
            "ɡrǽf méjtrɪks",
            "sɜ́rkjələr bʌ́fər"
        ],
        "trans_Explanation": "ə bájnərij tríj ɪz ə hàjərɑ́rkɪkəl déjtə strʌ́ktʃər ɪn wɪ́tʃ ijtʃ nówd həz æt mówst túw tʃɪ́ldrən, tɪ́pɪkəlij rəfɜ́rd tə æz ðə lɛ́ft tʃájld ənd ðə rájt tʃájld. ðɪs strʌ́ktʃər bəɡɪ́nz wɪð ə rúwt nówd æt ðə tɒ́p ənd brǽntʃɪz dáwnwərd, krijéjtɪŋ ə tríj-lájk əréjndʒmənt. bájnərij tríjz ɑr wájdlij júwzd ɪn kəmpjúwtər sájəns fɔr əfɪ́ʃənt déjtə ɔ̀rɡənɪzéjʃən, sɜ́rtʃɪŋ, ənd sɔ́rtɪŋ. ðej fɔ́rm ðə fawndéjʃən fɔr mɔr spɛ́ʃəlàjzd strʌ́ktʃərz lájk bájnərij sɜ́rtʃ tríjz, wɪ́tʃ mejntéjn ə spəsɪ́fɪk ɔ́rdərɪŋ əv ɛ́ləmənts fɔr fǽst lʊ́kəps, ənd híjps, wɪ́tʃ ɑr júwzd ɪn prajɔ́rɪtij kjúw ɪ̀mpləmɛntéjʃənz. ðə ɛ́ləɡəns əv bájnərij tríjz lájz ɪn ðɛər rəkɜ́rsɪv néjtʃər: ijtʃ tʃájld əv ə nówd ɪz ɪtsɛ́lf ðə rúwt əv ə smɔ́lər bájnərij tríj, əláwɪŋ fɔr páwərfəl rəkɜ́rsɪv ǽlɡərɪ̀ðəmz fɔr trǽvərsəl ənd mənɪ̀pjəléjʃən. dɪ́fərənt trǽvərsəl mɛ́θədz sʌtʃ æz ɪn-ɔ́rdər, príj-ɔ́rdər, ənd pówst-ɔ́rdər prəvájd vɛ́ərijəs wéjz tə prɒ́sɛs ðə tríj'z déjtə ɪn spəsɪ́fɪk síjkwənsɪz. bájnərij tríjz strájk ə bǽləns bijtwíjn ðə sɪmplɪ́sɪtij əv əréjz ənd ðə flɛ̀ksɪbɪ́lɪtij əv mɔr kɒ́mplɛks déjtə strʌ́ktʃərz, méjkɪŋ ðɛm əsɛ́nʃəl ɪn ǽlɡərɪ̀ðəm dəzájn ənd sɔ́ftwɛ̀ər dəvɛ́ləpmənt."
    },
    {
        "Question": "What data structure is specifically designed to efficiently retrieve the maximum or minimum element and is often implemented as a complete binary tree with a specific ordering property?",
        "RightAnswer": "Heap",
        "WrongAnswers": [
            "Queue",
            "Linked List",
            "Hash Table",
            "B-Tree",
            "Trie"
        ],
        "Explanation": "A Heap is a specialized tree-based data structure that satisfies the heap property: in a max heap, for any given node, the value of that node is greater than or equal to the values of its children, while in a min heap, the value is less than or equal to those of its children. This arrangement ensures that the root element is always the maximum (in a max heap) or minimum (in a min heap) among all elements in the structure. Heaps are particularly useful for priority queue implementations, heap sort algorithms, and applications requiring efficient access to the largest or smallest elements in a collection. Unlike some other data structures, heaps do not support efficient searching for arbitrary elements, but they excel at insertion and extraction of the highest-priority element, typically with logarithmic time complexity. Heaps are commonly implemented using arrays, where the parent-child relationships are represented implicitly through index calculations rather than explicit pointers.",
        "trans_Question": "wɒt déjtə strʌ́ktʃər ɪz spəsɪ́fɪklij dəzájnd tə əfɪ́ʃəntlij rətríjv ðə mǽksɪməm ɔr mɪ́nɪməm ɛ́ləmənt ənd ɪz ɔ́fən ɪ́mpləmɛ̀ntɪd æz ə kəmplíjt bájnərij tríj wɪð ə spəsɪ́fɪk ɔ́rdərɪŋ prɒ́pərtij?",
        "trans_RightAnswer": "híjp",
        "trans_WrongAnswers": [
            "kjúw",
            "lɪ́ŋkt lɪ́st",
            "hǽʃ téjbəl",
            "b-tríj",
            "tráj"
        ],
        "trans_Explanation": "ə híjp ɪz ə spɛ́ʃəlàjzd tríj-béjst déjtə strʌ́ktʃər ðət sǽtɪsfàjz ðə híjp prɒ́pərtij: ɪn ə mæks híjp, fɔr ɛ́nij ɡɪ́vən nówd, ðə vǽljuw əv ðət nówd ɪz ɡréjtər ðʌn ɔr íjkwəl tə ðə vǽljuwz əv ɪts tʃɪ́ldrən, wájl ɪn ə mɪ́n híjp, ðə vǽljuw ɪz lɛ́s ðʌn ɔr íjkwəl tə ðowz əv ɪts tʃɪ́ldrən. ðɪs əréjndʒmənt ənʃʊ́rz ðət ðə rúwt ɛ́ləmənt ɪz ɔ́lwejz ðə mǽksɪməm (ɪn ə mæks híjp) ɔr mɪ́nɪməm (ɪn ə mɪ́n híjp) əmʌ́ŋ ɔl ɛ́ləmənts ɪn ðə strʌ́ktʃər. híjps ɑr pərtɪ́kjələrlij júwsfəl fɔr prajɔ́rɪtij kjúw ɪ̀mpləmɛntéjʃənz, híjp sɔ́rt ǽlɡərɪ̀ðəmz, ənd æ̀plɪkéjʃənz rijkwájərɪŋ əfɪ́ʃənt ǽksɛ̀s tə ðə lɑ́rdʒəst ɔr smɔ́ləst ɛ́ləmənts ɪn ə kəlɛ́kʃən. ʌ̀nlájk sʌm ʌ́ðər déjtə strʌ́ktʃərz, híjps dúw nɒt səpɔ́rt əfɪ́ʃənt sɜ́rtʃɪŋ fɔr ɑ́rbɪtrɛ̀ərij ɛ́ləmənts, bʌt ðej əksɛ́l æt ɪnsɜ́rʃən ənd əkstrǽkʃən əv ðə hájəst-prajɔ́rɪtij ɛ́ləmənt, tɪ́pɪkəlij wɪð lɒ̀ɡərɪ́ðmɪk tájm kəmplɛ́ksɪtij. híjps ɑr kɒ́mənlij ɪ́mpləmɛ̀ntɪd júwzɪŋ əréjz, wɛ́ər ðə pɛ́ərənt-tʃájld rəléjʃənʃɪ̀ps ɑr rɛ̀prəzɛ́ntɪd ɪmplɪ́sɪtlij θrúw ɪ́ndɛks kæ̀lkjəléjʃənz rǽðər ðʌn əksplɪ́sɪt pɔ́jntərz."
    },
    {
        "Question": "What data structure allows for highly efficient lookup operations by mapping keys to values using a special function that converts keys into array indices?",
        "RightAnswer": "Hash Table",
        "WrongAnswers": [
            "Binary Tree",
            "Linked List",
            "Stack",
            "Queue",
            "Heap"
        ],
        "Explanation": "A Hash Table is a data structure that implements an associative array, which maps keys to values for highly efficient lookups. It uses a hash function to compute an index into an array of buckets or slots, from which the desired value can be found. The major advantage of hash tables is their speed - the average time for each lookup is independent of the number of elements stored in the table, providing constant-time complexity for operations like insertion, deletion, and retrieval when implemented well. Hash tables are widely used in database indexing, caches, and symbol tables in compilers. They work by transforming the key using a hash function into a hash code, which serves as an index in the underlying array where the value is stored or can be found. Collisions (when different keys hash to the same index) are handled through techniques like chaining or open addressing. Hash tables represent a fundamental concept that balances memory usage with computational efficiency.",
        "trans_Question": "wɒt déjtə strʌ́ktʃər əláwz fɔr hájlij əfɪ́ʃənt lʊ́kəp ɒ̀pəréjʃənz baj mǽpɪŋ kíjz tə vǽljuwz júwzɪŋ ə spɛ́ʃəl fʌ́ŋkʃən ðət kɒ́nvərts kíjz ɪntə əréj ɪ́ndɪsɪz?",
        "trans_RightAnswer": "hǽʃ téjbəl",
        "trans_WrongAnswers": [
            "bájnərij tríj",
            "lɪ́ŋkt lɪ́st",
            "stǽk",
            "kjúw",
            "híjp"
        ],
        "trans_Explanation": "ə hǽʃ téjbəl ɪz ə déjtə strʌ́ktʃər ðət ɪ́mpləmənts ən əsówʃətɪ̀v əréj, wɪ́tʃ mǽps kíjz tə vǽljuwz fɔr hájlij əfɪ́ʃənt lʊ́kəps. ɪt júwsɪz ə hǽʃ fʌ́ŋkʃən tə kəmpjúwt ən ɪ́ndɛks ɪntə ən əréj əv bʌ́kəts ɔr slɒ́ts, frəm wɪ́tʃ ðə dəzájərd vǽljuw kən bij fáwnd. ðə méjdʒər ədvǽntɪdʒ əv hǽʃ téjbəlz ɪz ðɛər spíjd - ðə ǽvərɪdʒ tájm fɔr ijtʃ lʊ́kəp ɪz ɪndəpɛ́ndənt əv ðə nʌ́mbər əv ɛ́ləmənts stɔ́rd ɪn ðə téjbəl, prəvájdɪŋ kɒ́nstənt-tájm kəmplɛ́ksɪtij fɔr ɒ̀pəréjʃənz lájk ɪnsɜ́rʃən, dəlíjʃən, ənd rətríjvəl wɛ́n ɪ́mpləmɛ̀ntɪd wɛ́l. hǽʃ téjbəlz ɑr wájdlij júwzd ɪn déjtəbèjs ɪ́ndɛksɪŋ, kǽʃɪz, ənd sɪ́mbəl téjbəlz ɪn kəmpájlərz. ðej wɜ́rk baj trænsfɔ́rmɪŋ ðə kíj júwzɪŋ ə hǽʃ fʌ́ŋkʃən ɪntə ə hǽʃ kówd, wɪ́tʃ sɜ́rvz æz ən ɪ́ndɛks ɪn ðə ʌ̀ndərlájɪŋ əréj wɛ́ər ðə vǽljuw ɪz stɔ́rd ɔr kən bij fáwnd. kəlɪ́ʒənz (wɛ́n dɪ́fərənt kíjz hǽʃ tə ðə séjm ɪ́ndɛks) ɑr hǽndəld θrúw tɛkníjks lájk tʃéjnɪŋ ɔr ówpən ədrɛ́sɪŋ. hǽʃ téjbəlz rɛ̀prəzɛ́nt ə fʌ̀ndəmɛ́ntəl kɒ́nsɛpt ðət bǽlənsɪz mɛ́mərij júwsɪdʒ wɪð kɒ̀mpjuwtéjʃənəl əfɪ́ʃənsij."
    },
    {
        "Question": "In computer science, which data structure is specifically designed to store unique values without any particular order, mimicking the mathematical concept of an unordered collection of distinct objects?",
        "RightAnswer": "Set",
        "WrongAnswers": [
            "Array",
            "Queue",
            "Linked List",
            "Dictionary",
            "Stack"
        ],
        "Explanation": "A Set is a fundamental data structure in computer science that stores a collection of distinct elements with no duplicates allowed. Unlike arrays or lists where order matters and duplicates are permitted, Sets focus solely on the uniqueness of their members. When you add an element to a Set that already exists, the addition is simply ignored, preserving the collection's uniqueness property. Sets are particularly useful for membership testing, removing duplicates from a collection, and performing mathematical set operations like union, intersection, and difference. Many programming languages implement Sets as hash-based collections, allowing for very efficient lookups, typically with constant-time complexity. This makes Sets an excellent choice when you need to quickly determine if an item exists in a collection or when you want to ensure you're working with only unique values.",
        "trans_Question": "ɪn kəmpjúwtər sájəns, wɪ́tʃ déjtə strʌ́ktʃər ɪz spəsɪ́fɪklij dəzájnd tə stɔ́r juwnɪ́k vǽljuwz wɪðáwt ɛ́nij pərtɪ́kjələr ɔ́rdər, mɪ́mɪkɪŋ ðə mæ̀θəmǽtɪkəl kɒ́nsɛpt əv ən ʌnɔ́rdərd kəlɛ́kʃən əv dɪstɪ́ŋkt ɒ́bdʒɛkts?",
        "trans_RightAnswer": "sɛ́t",
        "trans_WrongAnswers": [
            "əréj",
            "kjúw",
            "lɪ́ŋkt lɪ́st",
            "dɪ́kʃənɛ̀ərij",
            "stǽk"
        ],
        "trans_Explanation": "ə sɛ́t ɪz ə fʌ̀ndəmɛ́ntəl déjtə strʌ́ktʃər ɪn kəmpjúwtər sájəns ðət stɔ́rz ə kəlɛ́kʃən əv dɪstɪ́ŋkt ɛ́ləmənts wɪð now djúwplɪkèjts əláwd. ʌ̀nlájk əréjz ɔr lɪ́sts wɛ́ər ɔ́rdər mǽtərz ənd djúwplɪkèjts ɑr pərmɪ́tɪd, sɛ́ts fówkəs sówlij ɒn ðə juwnɪ́knəs əv ðɛər mɛ́mbərz. wɛ́n juw ǽd ən ɛ́ləmənt tə ə sɛ́t ðət ɔ̀lrɛ́dij əɡzɪ́sts, ðə ədɪ́ʃən ɪz sɪ́mplij ɪ̀ɡnɔ́rd, prəzɜ́rvɪŋ ðə kəlɛ́kʃən'z juwnɪ́knəs prɒ́pərtij. sɛ́ts ɑr pərtɪ́kjələrlij júwsfəl fɔr mɛ́mbərʃɪ̀p tɛ́stɪŋ, rijmúwvɪŋ djúwplɪkèjts frəm ə kəlɛ́kʃən, ənd pərfɔ́rmɪŋ mæ̀θəmǽtɪkəl sɛ́t ɒ̀pəréjʃənz lájk júwnjən, ɪ̀ntərsɛ́kʃən, ənd dɪ́fərəns. mɛ́nij prówɡræ̀mɪŋ lǽŋɡwədʒɪz ɪ́mpləmənt sɛ́ts æz hǽʃ-béjst kəlɛ́kʃənz, əláwɪŋ fɔr vɛ́ərij əfɪ́ʃənt lʊ́kəps, tɪ́pɪkəlij wɪð kɒ́nstənt-tájm kəmplɛ́ksɪtij. ðɪs méjks sɛ́ts ən ɛ́ksələnt tʃɔ́js wɛ́n juw níjd tə kwɪ́klij dətɜ́rmɪn ɪf ən ájtəm əɡzɪ́sts ɪn ə kəlɛ́kʃən ɔr wɛ́n juw wɒ́nt tə ənʃʊ́r júwr wɜ́rkɪŋ wɪð ównlij juwnɪ́k vǽljuwz."
    },
    {
        "Question": "In computer science, which data structure is primarily designed to store key-value pairs where each unique key maps to a value, allowing for efficient lookup operations?",
        "RightAnswer": "Map",
        "WrongAnswers": [
            "Stack",
            "Queue",
            "Linked List",
            "Binary Tree",
            "Heap"
        ],
        "Explanation": "A Map is a fundamental data structure in computer science that organizes data as key-value pairs. Unlike arrays where elements are accessed by their position, Maps allow you to retrieve values using their associated unique keys. This creates a direct relationship or 'mapping' between keys and their corresponding values. Maps are particularly valuable when you need to quickly look up information based on a specific identifier rather than a numeric index. Programming languages implement this concept in various forms such as dictionaries in Python, HashMaps in Java, or objects in JavaScript. Maps are essential in numerous applications including database indexing, caching systems, and symbol tables in compilers. Their ability to provide fast lookups, insertions, and deletions makes them indispensable tools in efficient algorithm design and data management.",
        "trans_Question": "ɪn kəmpjúwtər sájəns, wɪ́tʃ déjtə strʌ́ktʃər ɪz prajmɛ́ərɪlij dəzájnd tə stɔ́r kíj-vǽljuw pɛ́ərz wɛ́ər ijtʃ juwnɪ́k kíj mǽps tə ə vǽljuw, əláwɪŋ fɔr əfɪ́ʃənt lʊ́kəp ɒ̀pəréjʃənz?",
        "trans_RightAnswer": "mǽp",
        "trans_WrongAnswers": [
            "stǽk",
            "kjúw",
            "lɪ́ŋkt lɪ́st",
            "bájnərij tríj",
            "híjp"
        ],
        "trans_Explanation": "ə mǽp ɪz ə fʌ̀ndəmɛ́ntəl déjtə strʌ́ktʃər ɪn kəmpjúwtər sájəns ðət ɔ́rɡənàjzɪz déjtə æz kíj-vǽljuw pɛ́ərz. ʌ̀nlájk əréjz wɛ́ər ɛ́ləmənts ɑr ǽksɛ̀st baj ðɛər pəzɪ́ʃən, mǽps əláw juw tə rətríjv vǽljuwz júwzɪŋ ðɛər əsówsijèjtɪd juwnɪ́k kíjz. ðɪs krijéjts ə dɪərɛ́kt rəléjʃənʃɪ̀p ɔr 'mǽpɪŋ' bijtwíjn kíjz ənd ðɛər kɔ̀rəspɒ́ndɪŋ vǽljuwz. mǽps ɑr pərtɪ́kjələrlij vǽljəbəl wɛ́n juw níjd tə kwɪ́klij lʊ́k ʌp ɪnfərméjʃən béjst ɒn ə spəsɪ́fɪk ajdɛ́ntɪfàjər rǽðər ðʌn ə njuwmɛ́ərɪk ɪ́ndɛks. prówɡræ̀mɪŋ lǽŋɡwədʒɪz ɪ́mpləmənt ðɪs kɒ́nsɛpt ɪn vɛ́ərijəs fɔ́rmz sʌtʃ æz dɪ́kʃənɛ̀ərijz ɪn pájθɒn, hǽʃmæps ɪn dʒɒ́və, ɔr ɒ́bdʒɛkts ɪn dʒɒ́vəskrɪ̀pt. mǽps ɑr əsɛ́nʃəl ɪn njúwmərəs æ̀plɪkéjʃənz ɪnklúwdɪŋ déjtəbèjs ɪ́ndɛksɪŋ, kǽʃɪŋ sɪ́stəmz, ənd sɪ́mbəl téjbəlz ɪn kəmpájlərz. ðɛər əbɪ́lɪtij tə prəvájd fǽst lʊ́kəps, ɪnsɜ́rʃənz, ənd dəlíjʃənz méjks ðɛm ɪ̀ndɪspɛ́nsəbəl túwlz ɪn əfɪ́ʃənt ǽlɡərɪ̀ðəm dəzájn ənd déjtə mǽnədʒmənt."
    },
    {
        "Question": "Which data structure is specifically designed to represent a collection of objects where some pairs of objects are connected by links, often used to model networks like social connections or road systems?",
        "RightAnswer": "Graph Data Structure",
        "WrongAnswers": [
            "Binary Search Tree",
            "Hash Table",
            "Priority Queue",
            "Linked List",
            "Stack"
        ],
        "Explanation": "A Graph Data Structure is a non-linear data structure consisting of nodes (or vertices) and edges that connect these nodes. Unlike hierarchical structures such as trees, graphs allow for complex relationships where any node can be connected to any other node, creating networks of relationships. Graphs are incredibly versatile and can model real-world systems like social networks (where people are vertices and friendships are edges), transportation networks (where locations are vertices and roads are edges), or computer networks (where devices are vertices and connections are edges). Graphs come in various forms including directed (edges have direction) or undirected, weighted (edges have values) or unweighted, and can be implemented using adjacency matrices or adjacency lists. Their flexibility makes graphs essential for solving complex problems like finding the shortest path between points, detecting cycles in networks, or analyzing connection patterns in data.",
        "trans_Question": "wɪ́tʃ déjtə strʌ́ktʃər ɪz spəsɪ́fɪklij dəzájnd tə rɛ̀prəzɛ́nt ə kəlɛ́kʃən əv ɒ́bdʒɛkts wɛ́ər sʌm pɛ́ərz əv ɒ́bdʒɛkts ɑr kənɛ́ktɪd baj lɪ́ŋks, ɔ́fən júwzd tə mɒ́dəl nɛ́twɜ̀rks lájk sówʃəl kənɛ́kʃənz ɔr rówd sɪ́stəmz?",
        "trans_RightAnswer": "ɡrǽf déjtə strʌ́ktʃər",
        "trans_WrongAnswers": [
            "bájnərij sɜ́rtʃ tríj",
            "hǽʃ téjbəl",
            "prajɔ́rɪtij kjúw",
            "lɪ́ŋkt lɪ́st",
            "stǽk"
        ],
        "trans_Explanation": "ə ɡrǽf déjtə strʌ́ktʃər ɪz ə nɒn-lɪ́nijər déjtə strʌ́ktʃər kənsɪ́stɪŋ əv nówdz (ɔr vɜ́rtɪsìjz) ənd ɛ́dʒɪz ðət kənɛ́kt ðijz nówdz. ʌ̀nlájk hàjərɑ́rkɪkəl strʌ́ktʃərz sʌtʃ æz tríjz, ɡrǽfs əláw fɔr kɒ́mplɛks rəléjʃənʃɪ̀ps wɛ́ər ɛ́nij nówd kən bij kənɛ́ktɪd tə ɛ́nij ʌ́ðər nówd, krijéjtɪŋ nɛ́twɜ̀rks əv rəléjʃənʃɪ̀ps. ɡrǽfs ɑr ɪnkrɛ́dɪblij vɜ́rsətajl ənd kən mɒ́dəl ríjəl-wɜ́rld sɪ́stəmz lájk sówʃəl nɛ́twɜ̀rks (wɛ́ər píjpəl ɑr vɜ́rtɪsìjz ənd frɛ́ndʃɪps ɑr ɛ́dʒɪz), træ̀nspərtéjʃən nɛ́twɜ̀rks (wɛ́ər lowkéjʃənz ɑr vɜ́rtɪsìjz ənd rówdz ɑr ɛ́dʒɪz), ɔr kəmpjúwtər nɛ́twɜ̀rks (wɛ́ər dəvájsɪz ɑr vɜ́rtɪsìjz ənd kənɛ́kʃənz ɑr ɛ́dʒɪz). ɡrǽfs kʌ́m ɪn vɛ́ərijəs fɔ́rmz ɪnklúwdɪŋ dɪərɛ́ktɪd (ɛ́dʒɪz həv dɪərɛ́kʃən) ɔr ʌ̀ndɪərɛ́ktɪd, wéjtɪd (ɛ́dʒɪz həv vǽljuwz) ɔr ʌ̀nwéjtɪd, ənd kən bij ɪ́mpləmɛ̀ntɪd júwzɪŋ ədʒéjsənsij méjtrɪsɪz ɔr ədʒéjsənsij lɪ́sts. ðɛər flɛ̀ksɪbɪ́lɪtij méjks ɡrǽfs əsɛ́nʃəl fɔr sɒ́lvɪŋ kɒ́mplɛks prɒ́bləmz lájk fájndɪŋ ðə ʃɔ́rtəst pǽθ bijtwíjn pɔ́jnts, dətɛ́ktɪŋ sájkəlz ɪn nɛ́twɜ̀rks, ɔr ǽnəlàjzɪŋ kənɛ́kʃən pǽtərnz ɪn déjtə."
    },
    {
        "Question": "In a computer network routing algorithm, what is the data structure that represents connections where traffic can only flow in one specific direction between nodes?",
        "RightAnswer": "Directed Graph",
        "WrongAnswers": [
            "Undirected Network",
            "Symmetric Matrix",
            "Bidirectional Tree",
            "Cyclic Array",
            "Neutral Mesh"
        ],
        "Explanation": "A Directed Graph is a fundamental data structure in computer science consisting of vertices (nodes) connected by edges, where each edge has a specific direction, indicating a one-way relationship from one vertex to another. Unlike undirected graphs where connections work both ways, directed graphs explicitly show which way information, data, or control can flow. They are essential in modeling many real-world scenarios such as web page links, social media follows, network traffic flow, dependency relationships in software, and state transitions in finite automata. The direction of edges creates important properties like reachability, where you can determine if there exists any path from one node to another by following the arrows. Directed graphs can contain special structures like cycles, where you can follow directions and return to a starting point, or they can be acyclic, which is particularly useful for representing hierarchies and scheduling problems. The directional nature of these graphs makes them perfect for situations where relationships aren't necessarily reciprocal.",
        "trans_Question": "ɪn ə kəmpjúwtər nɛ́twɜ̀rk ráwtɪŋ ǽlɡərɪ̀ðəm, wɒt ɪz ðə déjtə strʌ́ktʃər ðət rɛ̀prəzɛ́nts kənɛ́kʃənz wɛ́ər trǽfɪk kən ównlij flów ɪn wʌ́n spəsɪ́fɪk dɪərɛ́kʃən bijtwíjn nówdz?",
        "trans_RightAnswer": "dɪərɛ́ktɪd ɡrǽf",
        "trans_WrongAnswers": [
            "ʌ̀ndɪərɛ́ktɪd nɛ́twɜ̀rk",
            "sɪmɛ́trɪk méjtrɪks",
            "bàjdɪərékʃənəl tríj",
            "sájklɪk əréj",
            "núwtrəl mɛ́ʃ"
        ],
        "trans_Explanation": "ə dɪərɛ́ktɪd ɡrǽf ɪz ə fʌ̀ndəmɛ́ntəl déjtə strʌ́ktʃər ɪn kəmpjúwtər sájəns kənsɪ́stɪŋ əv vɜ́rtɪsìjz (nówdz) kənɛ́ktɪd baj ɛ́dʒɪz, wɛ́ər ijtʃ ɛ́dʒ həz ə spəsɪ́fɪk dɪərɛ́kʃən, ɪ́ndɪkèjtɪŋ ə wʌ́n-wej rəléjʃənʃɪ̀p frəm wʌ́n vɜ́rtɛ̀ks tə ənʌ́ðər. ʌ̀nlájk ʌ̀ndɪərɛ́ktɪd ɡrǽfs wɛ́ər kənɛ́kʃənz wɜ́rk bówθ wéjz, dɪərɛ́ktɪd ɡrǽfs əksplɪ́sɪtlij ʃów wɪ́tʃ wej ɪnfərméjʃən, déjtə, ɔr kəntrówl kən flów. ðej ɑr əsɛ́nʃəl ɪn mɒ́dəlɪ̀ŋ mɛ́nij ríjəl-wɜ́rld sənɛ́ərijowz sʌtʃ æz wɛ́b péjdʒ lɪ́ŋks, sówʃəl míjdijə fɒ́lowz, nɛ́twɜ̀rk trǽfɪk flów, dəpɛ́ndənsij rəléjʃənʃɪ̀ps ɪn sɔ́ftwɛ̀ər, ənd stéjt trænzɪ́ʃənz ɪn fájnàjt ɔtɒ́mətə. ðə dɪərɛ́kʃən əv ɛ́dʒɪz krijéjts ɪmpɔ́rtənt prɒ́pərtijz lájk rijtʃəbɪ́lətij, wɛ́ər juw kən dətɜ́rmɪn ɪf ðɛər əɡzɪ́sts ɛ́nij pǽθ frəm wʌ́n nówd tə ənʌ́ðər baj fɒ́lowɪŋ ðə ǽrowz. dɪərɛ́ktɪd ɡrǽfs kən kəntéjn spɛ́ʃəl strʌ́ktʃərz lájk sájkəlz, wɛ́ər juw kən fɒ́low dɪərɛ́kʃənz ənd rətɜ́rn tə ə stɑ́rtɪŋ pɔ́jnt, ɔr ðej kən bij əsájklɪk, wɪ́tʃ ɪz pərtɪ́kjələrlij júwsfəl fɔr rɛ̀prəzɛ́ntɪŋ hájərɑ̀rkijz ənd skɛ́dʒuwlɪŋ prɒ́bləmz. ðə dɪərɛ́kʃənəl néjtʃər əv ðijz ɡrǽfs méjks ðɛm pɜ́rfəkt fɔr sɪ̀tʃuwéjʃənz wɛ́ər rəléjʃənʃɪ̀ps ɑrənt nɛ̀səsɛ́ərɪlij rəsɪ́prəkəl."
    },
    {
        "Question": "Which data structure is commonly used to represent relationships between entities where connections have no direction, such as representing friendships on a social network where if person A is friends with person B, then person B is also friends with person A?",
        "RightAnswer": "Undirected Graph",
        "WrongAnswers": [
            "Directed Acyclic Graph",
            "Binary Search Tree",
            "Priority Queue",
            "Hash Table",
            "Linked List"
        ],
        "Explanation": "An undirected graph is a collection of nodes (also called vertices) connected by edges, where each edge represents a bidirectional relationship between two nodes. Unlike directed graphs, the edges in an undirected graph have no orientation or direction, meaning that if node A is connected to node B, then node B is also connected to node A. This symmetrical relationship makes undirected graphs particularly useful for modeling mutual connections such as friendships in social networks, road networks where streets can be traveled in both directions, electrical circuits, or collaboration networks. When we draw an undirected graph, we typically represent the edges as simple lines without arrows, emphasizing that the relationship flows both ways. Undirected graphs can be implemented using adjacency lists or adjacency matrices, and common operations include finding paths between nodes, identifying connected components, and checking if the graph is connected or contains cycles.",
        "trans_Question": "wɪ́tʃ déjtə strʌ́ktʃər ɪz kɒ́mənlij júwzd tə rɛ̀prəzɛ́nt rəléjʃənʃɪ̀ps bijtwíjn ɛ́ntɪtijz wɛ́ər kənɛ́kʃənz həv now dɪərɛ́kʃən, sʌtʃ æz rɛ̀prəzɛ́ntɪŋ frɛ́ndʃɪps ɒn ə sówʃəl nɛ́twɜ̀rk wɛ́ər ɪf pɜ́rsən ə ɪz frɛ́ndz wɪð pɜ́rsən B, ðɛn pɜ́rsən B ɪz ɔ́lsow frɛ́ndz wɪð pɜ́rsən A?",
        "trans_RightAnswer": "ʌ̀ndɪərɛ́ktɪd ɡrǽf",
        "trans_WrongAnswers": [
            "dɪərɛ́ktɪd əsájklɪk ɡrǽf",
            "bájnərij sɜ́rtʃ tríj",
            "prajɔ́rɪtij kjúw",
            "hǽʃ téjbəl",
            "lɪ́ŋkt lɪ́st"
        ],
        "trans_Explanation": "ən ʌ̀ndɪərɛ́ktɪd ɡrǽf ɪz ə kəlɛ́kʃən əv nówdz (ɔ́lsow kɔ́ld vɜ́rtɪsìjz) kənɛ́ktɪd baj ɛ́dʒɪz, wɛ́ər ijtʃ ɛ́dʒ rɛ̀prəzɛ́nts ə bàjdɪərékʃənəl rəléjʃənʃɪ̀p bijtwíjn túw nówdz. ʌ̀nlájk dɪərɛ́ktɪd ɡrǽfs, ðə ɛ́dʒɪz ɪn ən ʌ̀ndɪərɛ́ktɪd ɡrǽf həv now ɔ̀rijɛntéjʃən ɔr dɪərɛ́kʃən, míjnɪŋ ðət ɪf nówd ə ɪz kənɛ́ktɪd tə nówd B, ðɛn nówd B ɪz ɔ́lsow kənɛ́ktɪd tə nówd A. ðɪs sɪmɛ́trɪkəl rəléjʃənʃɪ̀p méjks ʌ̀ndɪərɛ́ktɪd ɡrǽfs pərtɪ́kjələrlij júwsfəl fɔr mɒ́dəlɪ̀ŋ mjúwtʃuwəl kənɛ́kʃənz sʌtʃ æz frɛ́ndʃɪps ɪn sówʃəl nɛ́twɜ̀rks, rówd nɛ́twɜ̀rks wɛ́ər stríjts kən bij trǽvəld ɪn bówθ dɪərɛ́kʃənz, əlɛ́ktrɪkəl sɜ́rkəts, ɔr kəlæ̀bəréjʃən nɛ́twɜ̀rks. wɛ́n wij drɔ́ ən ʌ̀ndɪərɛ́ktɪd ɡrǽf, wij tɪ́pɪkəlij rɛ̀prəzɛ́nt ðə ɛ́dʒɪz æz sɪ́mpəl lájnz wɪðáwt ǽrowz, ɛ́mfəsajzɪŋ ðət ðə rəléjʃənʃɪ̀p flówz bówθ wéjz. ʌ̀ndɪərɛ́ktɪd ɡrǽfs kən bij ɪ́mpləmɛ̀ntɪd júwzɪŋ ədʒéjsənsij lɪ́sts ɔr ədʒéjsənsij méjtrɪsɪz, ənd kɒ́mən ɒ̀pəréjʃənz ɪnklúwd fájndɪŋ pǽðz bijtwíjn nówdz, ajdɛ́ntɪfàjɪŋ kənɛ́ktɪd kəmpównənts, ənd tʃɛ́kɪŋ ɪf ðə ɡrǽf ɪz kənɛ́ktɪd ɔr kəntéjnz sájkəlz."
    },
    {
        "Question": "What is the formal term for the systematic process of visiting each node in a data structure that represents hierarchical relationships, such as a binary search tree or file system directory?",
        "RightAnswer": "Tree Traversal",
        "WrongAnswers": [
            "Node Iteration",
            "Branch Mapping",
            "Hierarchical Scanning",
            "Element Navigation",
            "Path Discovery"
        ],
        "Explanation": "Tree Traversal is a fundamental algorithm in computer science that involves systematically visiting every node in a tree data structure exactly once. Think of it as taking a complete tour through a family tree or an organizational chart. There are several common traversal methods, including in-order (where we visit left subtree, then the current node, then right subtree), pre-order (current node first, then subtrees), and post-order (subtrees first, then current node), as well as level-order traversal (visiting nodes level by level). These techniques are essential for operations like searching, printing hierarchical data, evaluating expressions, and file system navigation. The choice of traversal method depends on the specific application and can significantly affect efficiency and outcome. Tree traversal is one of the foundations of algorithms that work with hierarchical data structures.",
        "trans_Question": "wɒt ɪz ðə fɔ́rməl tɜ́rm fɔr ðə sɪ̀stəmǽtɪk prɒ́sɛs əv vɪ́zɪtɪŋ ijtʃ nówd ɪn ə déjtə strʌ́ktʃər ðət rɛ̀prəzɛ́nts hàjərɑ́rkɪkəl rəléjʃənʃɪ̀ps, sʌtʃ æz ə bájnərij sɜ́rtʃ tríj ɔr fájl sɪ́stəm dɪərɛ́ktərij?",
        "trans_RightAnswer": "tríj trǽvərsəl",
        "trans_WrongAnswers": [
            "nówd ɪ̀təréjʃən",
            "brǽntʃ mǽpɪŋ",
            "hàjərɑ́rkɪkəl skǽnɪŋ",
            "ɛ́ləmənt nǽvɪɡejʃən",
            "pǽθ dɪ̀skʌ́vrij"
        ],
        "trans_Explanation": "tríj trǽvərsəl ɪz ə fʌ̀ndəmɛ́ntəl ǽlɡərɪ̀ðəm ɪn kəmpjúwtər sájəns ðət ɪnvɒ́lvz sɪ̀stəmǽtɪklij vɪ́zɪtɪŋ ɛvərij nówd ɪn ə tríj déjtə strʌ́ktʃər əɡzǽktlij wʌ́ns. θɪ́ŋk əv ɪt æz téjkɪŋ ə kəmplíjt tʊ́r θrúw ə fǽmɪlij tríj ɔr ən ɔ̀rɡənɪzéjʃənəl tʃɑ́rt. ðɛər ɑr sɛ́vərəl kɒ́mən trǽvərsəl mɛ́θədz, ɪnklúwdɪŋ ɪn-ɔ́rdər (wɛ́ər wij vɪ́zɪt lɛ́ft sʌ́btrìj, ðɛn ðə kɑ́rənt nówd, ðɛn rájt sʌ́btrìj), príj-ɔ́rdər (kɑ́rənt nówd fɜ́rst, ðɛn sʌ́btrìjz), ənd pówst-ɔ́rdər (sʌ́btrìjz fɜ́rst, ðɛn kɑ́rənt nówd), æz wɛ́l æz lɛ́vəl-ɔ́rdər trǽvərsəl (vɪ́zɪtɪŋ nówdz lɛ́vəl baj lɛ́vəl). ðijz tɛkníjks ɑr əsɛ́nʃəl fɔr ɒ̀pəréjʃənz lájk sɜ́rtʃɪŋ, prɪ́ntɪŋ hàjərɑ́rkɪkəl déjtə, əvǽljuwèjtɪŋ əksprɛ́ʃənz, ənd fájl sɪ́stəm nǽvɪɡejʃən. ðə tʃɔ́js əv trǽvərsəl mɛ́θəd dəpɛ́ndz ɒn ðə spəsɪ́fɪk æ̀plɪkéjʃən ənd kən sɪɡnɪ́fɪkəntlij əfɛ́kt əfɪ́ʃənsij ənd áwtkʌ̀m. tríj trǽvərsəl ɪz wʌ́n əv ðə fawndéjʃənz əv ǽlɡərɪ̀ðəmz ðət wɜ́rk wɪð hàjərɑ́rkɪkəl déjtə strʌ́ktʃərz."
    },
    {
        "Question": "Which graph traversal algorithm exhaustively explores as far as possible along each branch before backtracking?",
        "RightAnswer": "Depth-First Search",
        "WrongAnswers": [
            "Breadth-First Search",
            "Dijkstra's Algorithm",
            "A-Star Search",
            "Bellman-Ford Algorithm",
            "Greedy Best-First Search"
        ],
        "Explanation": "Depth-First Search is a fundamental graph traversal algorithm that explores as deeply as possible along each path before backtracking. It works by starting at a root node, then continuously selecting an adjacent unvisited node until it reaches a dead end. When no unvisited adjacent nodes remain, it backtracks to the previous node and continues exploring other paths. This creates a behavior similar to exploring a maze by following one path until you cannot go further, then retracing your steps to try another route. DFS is particularly useful for topological sorting, finding connected components, solving puzzles like mazes, and detecting cycles in graphs. It can be implemented using a stack data structure or through recursion, making it an elegant and powerful technique in computer science for exploring hierarchical or network-like data structures.",
        "trans_Question": "wɪ́tʃ ɡrǽf trǽvərsəl ǽlɡərɪ̀ðəm əɡzɒ́stɪvlij əksplɔ́rz æz fɑ́r æz pɒ́sɪbəl əlɔ́ŋ ijtʃ brǽntʃ bəfɔ́r bǽktræ̀kɪŋ?",
        "trans_RightAnswer": "dɛ́pθ-fɜ́rst sɜ́rtʃ",
        "trans_WrongAnswers": [
            "brɛ́dθ-fɜ́rst sɜ́rtʃ",
            "dájkstrə'z ǽlɡərɪ̀ðəm",
            "ə-stɑ́r sɜ́rtʃ",
            "bɛ́lmən-fɔ́rd ǽlɡərɪ̀ðəm",
            "ɡríjdij bɛ́st-fɜ́rst sɜ́rtʃ"
        ],
        "trans_Explanation": "dɛ́pθ-fɜ́rst sɜ́rtʃ ɪz ə fʌ̀ndəmɛ́ntəl ɡrǽf trǽvərsəl ǽlɡərɪ̀ðəm ðət əksplɔ́rz æz díjplij æz pɒ́sɪbəl əlɔ́ŋ ijtʃ pǽθ bəfɔ́r bǽktræ̀kɪŋ. ɪt wɜ́rks baj stɑ́rtɪŋ æt ə rúwt nówd, ðɛn kəntɪ́njuwəslij səlɛ́ktɪŋ ən ədʒéjsənt ʌ̀nvɪ́zɪtɪd nówd əntɪ́l ɪt ríjtʃɪz ə dɛ́d ɛ́nd. wɛ́n now ʌ̀nvɪ́zɪtɪd ədʒéjsənt nówdz rəméjn, ɪt bǽktræ̀ks tə ðə príjvijəs nówd ənd kəntɪ́njuwz əksplɔ́rɪŋ ʌ́ðər pǽðz. ðɪs krijéjts ə bəhéjvjər sɪ́mɪlər tə əksplɔ́rɪŋ ə méjz baj fɒ́lowɪŋ wʌ́n pǽθ əntɪ́l juw kǽnɒt ɡow fɜ́rðər, ðɛn rijtréjsɪŋ jɔr stɛ́ps tə tráj ənʌ́ðər ráwt. DFS ɪz pərtɪ́kjələrlij júwsfəl fɔr tɒ̀pəlɒ́dʒɪkəl sɔ́rtɪŋ, fájndɪŋ kənɛ́ktɪd kəmpównənts, sɒ́lvɪŋ pʌ́zəlz lájk méjzɪz, ənd dətɛ́ktɪŋ sájkəlz ɪn ɡrǽfs. ɪt kən bij ɪ́mpləmɛ̀ntɪd júwzɪŋ ə stǽk déjtə strʌ́ktʃər ɔr θrúw rəkɜ́rʒən, méjkɪŋ ɪt ən ɛ́ləɡənt ənd páwərfəl tɛkníjk ɪn kəmpjúwtər sájəns fɔr əksplɔ́rɪŋ hàjərɑ́rkɪkəl ɔr nɛ́twɜ̀rk-lájk déjtə strʌ́ktʃərz."
    },
    {
        "Question": "Which graph traversal algorithm visits all the nodes at the current depth level before moving on to the nodes at the next depth level?",
        "RightAnswer": "Breadth-First Search",
        "WrongAnswers": [
            "Depth-First Search",
            "Dijkstra's Algorithm",
            "A* Search",
            "Binary Search",
            "Linear Probing"
        ],
        "Explanation": "Breadth-First Search is a graph traversal algorithm that systematically explores a graph by visiting all neighbors of a node before moving on to their neighbors. Starting from a specified node, it visits all nodes at the current depth level before proceeding to nodes at the next depth level. This approach creates a 'wavefront' that expands outward from the starting point, making it particularly useful for finding the shortest path in unweighted graphs. BFS uses a queue data structure to maintain the order of visitation, ensuring that nodes are processed in the order they are discovered. The algorithm is complete, meaning it will find a solution if one exists, and it is optimal when all edges have the same weight. BFS is widely applied in networking algorithms, social network analysis, web crawling, and finding the shortest path in maze-solving problems.",
        "trans_Question": "wɪ́tʃ ɡrǽf trǽvərsəl ǽlɡərɪ̀ðəm vɪ́zɪts ɔl ðə nówdz æt ðə kɑ́rənt dɛ́pθ lɛ́vəl bəfɔ́r múwvɪŋ ɒn tə ðə nówdz æt ðə nɛ́kst dɛ́pθ lɛ́vəl?",
        "trans_RightAnswer": "brɛ́dθ-fɜ́rst sɜ́rtʃ",
        "trans_WrongAnswers": [
            "dɛ́pθ-fɜ́rst sɜ́rtʃ",
            "dájkstrə'z ǽlɡərɪ̀ðəm",
            "A* sɜ́rtʃ",
            "bájnərij sɜ́rtʃ",
            "lɪ́nijər prówbɪŋ"
        ],
        "trans_Explanation": "brɛ́dθ-fɜ́rst sɜ́rtʃ ɪz ə ɡrǽf trǽvərsəl ǽlɡərɪ̀ðəm ðət sɪ̀stəmǽtɪklij əksplɔ́rz ə ɡrǽf baj vɪ́zɪtɪŋ ɔl néjbərz əv ə nówd bəfɔ́r múwvɪŋ ɒn tə ðɛər néjbərz. stɑ́rtɪŋ frəm ə spɛ́sɪfàjd nówd, ɪt vɪ́zɪts ɔl nówdz æt ðə kɑ́rənt dɛ́pθ lɛ́vəl bəfɔ́r prəsíjdɪŋ tə nówdz æt ðə nɛ́kst dɛ́pθ lɛ́vəl. ðɪs əprówtʃ krijéjts ə 'wéjvfrʌ̀nt' ðət əkspǽndz áwtwərd frəm ðə stɑ́rtɪŋ pɔ́jnt, méjkɪŋ ɪt pərtɪ́kjələrlij júwsfəl fɔr fájndɪŋ ðə ʃɔ́rtəst pǽθ ɪn ʌ̀nwéjtɪd ɡrǽfs. BFS júwsɪz ə kjúw déjtə strʌ́ktʃər tə mejntéjn ðə ɔ́rdər əv vɪ̀zɪtéjʃən, ɛnʃʊ́rɪŋ ðət nówdz ɑr prɒ́sɛst ɪn ðə ɔ́rdər ðej ɑr dɪskʌ́vərd. ðə ǽlɡərɪ̀ðəm ɪz kəmplíjt, míjnɪŋ ɪt wɪl fájnd ə səlúwʃən ɪf wʌ́n əɡzɪ́sts, ənd ɪt ɪz ɒ́ptɪməl wɛ́n ɔl ɛ́dʒɪz həv ðə séjm wéjt. BFS ɪz wájdlij əplájd ɪn nɛ́twɜ̀rkɪŋ ǽlɡərɪ̀ðəmz, sówʃəl nɛ́twɜ̀rk ənǽlɪsɪs, wɛ́b krɔ́lɪŋ, ənd fájndɪŋ ðə ʃɔ́rtəst pǽθ ɪn méjz-sɒ́lvɪŋ prɒ́bləmz."
    },
    {
        "Question": "When analyzing the time complexity of a divide-and-conquer algorithm like Merge Sort, what mathematical construct is used to express the relationship between the problem size and its smaller subproblems?",
        "RightAnswer": "Recurrence Relation",
        "WrongAnswers": [
            "State Transition Function",
            "Functional Dependency",
            "Algorithmic Invariant",
            "Complexity Propagation",
            "Recursive Dependency Graph"
        ],
        "Explanation": "A Recurrence Relation in computer science is a way to define a function by expressing its value at a certain point in terms of its values at smaller points. It serves as a mathematical description of recursive processes, where a problem is solved by breaking it down into smaller versions of itself. For example, when analyzing algorithms like binary search or merge sort, recurrence relations help us understand how the time complexity grows as input size increases. Instead of providing a direct formula for complexity, a recurrence relation shows how the work at one level relates to the work at previous levels, allowing computer scientists to reason about efficiency through techniques like the Master Theorem or recursion trees. They are particularly valuable tools for analyzing divide-and-conquer algorithms where problems are split into smaller subproblems, solved independently, and then combined to form a complete solution.",
        "trans_Question": "wɛ́n ǽnəlàjzɪŋ ðə tájm kəmplɛ́ksɪtij əv ə dɪvájd-ənd-kɒ́ŋkər ǽlɡərɪ̀ðəm lájk mɜ́rdʒ sɔ́rt, wɒt mæ̀θəmǽtɪkəl kɒ́nstrəkt ɪz júwzd tə əksprɛ́s ðə rəléjʃənʃɪ̀p bijtwíjn ðə prɒ́bləm sájz ənd ɪts smɔ́lər sʌ́bprɒ́bləmz?",
        "trans_RightAnswer": "rəkɜ́rəns rəléjʃən",
        "trans_WrongAnswers": [
            "stéjt trænzɪ́ʃən fʌ́ŋkʃən",
            "fʌ́ŋkʃənəl dəpɛ́ndənsij",
            "ǽlɡərɪ̀ðəmɪk ɪ̀nvɛ́ərijənt",
            "kəmplɛ́ksɪtij prɒ̀pəɡéjʃən",
            "rəkɜ́rsɪv dəpɛ́ndənsij ɡrǽf"
        ],
        "trans_Explanation": "ə rəkɜ́rəns rəléjʃən ɪn kəmpjúwtər sájəns ɪz ə wej tə dəfájn ə fʌ́ŋkʃən baj əksprɛ́sɪŋ ɪts vǽljuw æt ə sɜ́rtən pɔ́jnt ɪn tɜ́rmz əv ɪts vǽljuwz æt smɔ́lər pɔ́jnts. ɪt sɜ́rvz æz ə mæ̀θəmǽtɪkəl dəskrɪ́pʃən əv rəkɜ́rsɪv prɒ́sɛsɪz, wɛ́ər ə prɒ́bləm ɪz sɒ́lvd baj bréjkɪŋ ɪt dawn ɪntə smɔ́lər vɜ́rʒənz əv ɪtsɛ́lf. fɔr əɡzǽmpəl, wɛ́n ǽnəlàjzɪŋ ǽlɡərɪ̀ðəmz lájk bájnərij sɜ́rtʃ ɔr mɜ́rdʒ sɔ́rt, rəkɜ́rəns rəléjʃənz hɛ́lp US ʌ̀ndərstǽnd háw ðə tájm kəmplɛ́ksɪtij ɡrówz æz ɪ́npʊ̀t sájz ɪnkríjsɪz. ɪnstɛ́d əv prəvájdɪŋ ə dɪərɛ́kt fɔ́rmjələ fɔr kəmplɛ́ksɪtij, ə rəkɜ́rəns rəléjʃən ʃówz háw ðə wɜ́rk æt wʌ́n lɛ́vəl rəléjts tə ðə wɜ́rk æt príjvijəs lɛ́vəlz, əláwɪŋ kəmpjúwtər sájəntɪsts tə ríjzən əbawt əfɪ́ʃənsij θrúw tɛkníjks lájk ðə mǽstər θɪ́ərəm ɔr rəkɜ́rʒən tríjz. ðej ɑr pərtɪ́kjələrlij vǽljəbəl túwlz fɔr ǽnəlàjzɪŋ dɪvájd-ənd-kɒ́ŋkər ǽlɡərɪ̀ðəmz wɛ́ər prɒ́bləmz ɑr splɪ́t ɪntə smɔ́lər sʌ́bprɒ́bləmz, sɒ́lvd ɪndəpɛ́ndəntlij, ənd ðɛn kəmbájnd tə fɔ́rm ə kəmplíjt səlúwʃən."
    },
    {
        "Question": "What algorithm design paradigm involves breaking down a complex problem into smaller, more manageable subproblems, solving them independently, and then combining their solutions to solve the original problem?",
        "RightAnswer": "Divide and Conquer",
        "WrongAnswers": [
            "Greedy Algorithm",
            "Dynamic Programming",
            "Backtracking",
            "Branch and Bound",
            "Linear Programming"
        ],
        "Explanation": "Divide and Conquer is a powerful algorithmic paradigm in computer science that tackles complex problems by recursively breaking them down into simpler, more manageable subproblems of the same type. This approach follows three main steps: first, it divides the original problem into smaller subproblems; second, it conquers these subproblems by solving them independently, often through recursive calls; and finally, it combines these solutions to form the solution to the original problem. Classic examples include Merge Sort, which divides an array in half, sorts each half, and then merges the sorted halves; Quick Sort, which partitions data around a pivot element; and binary search, which repeatedly divides the search space in half. The efficiency of divide and conquer algorithms often leads to better time complexity than straightforward solutions, typically resulting in logarithmic or linearithmic time complexity for many problems that would otherwise require quadratic time.",
        "trans_Question": "wɒt ǽlɡərɪ̀ðəm dəzájn pǽrədàjm ɪnvɒ́lvz bréjkɪŋ dawn ə kɒ́mplɛks prɒ́bləm ɪntə smɔ́lər, mɔr mǽnədʒəbəl sʌ́bprɒ́bləmz, sɒ́lvɪŋ ðɛm ɪndəpɛ́ndəntlij, ənd ðɛn kəmbájnɪŋ ðɛər səlúwʃənz tə sɒ́lv ðə ərɪ́dʒɪnəl prɒ́bləm?",
        "trans_RightAnswer": "dɪvájd ənd kɒ́ŋkər",
        "trans_WrongAnswers": [
            "ɡríjdij ǽlɡərɪ̀ðəm",
            "dajnǽmɪk prówɡræ̀mɪŋ",
            "bǽktræ̀kɪŋ",
            "brǽntʃ ənd báwnd",
            "lɪ́nijər prówɡræ̀mɪŋ"
        ],
        "trans_Explanation": "dɪvájd ənd kɒ́ŋkər ɪz ə páwərfəl ǽlɡərɪ̀ðəmɪk pǽrədàjm ɪn kəmpjúwtər sájəns ðət tǽkəlz kɒ́mplɛks prɒ́bləmz baj rəkɜ́rsɪvlij bréjkɪŋ ðɛm dawn ɪntə sɪ́mplər, mɔr mǽnədʒəbəl sʌ́bprɒ́bləmz əv ðə séjm tájp. ðɪs əprówtʃ fɒ́lowz θríj méjn stɛ́ps: fɜ́rst, ɪt dɪvájdz ðə ərɪ́dʒɪnəl prɒ́bləm ɪntə smɔ́lər sʌ́bprɒ́bləmz; sɛ́kənd, ɪt kɒ́ŋkərz ðijz sʌ́bprɒ́bləmz baj sɒ́lvɪŋ ðɛm ɪndəpɛ́ndəntlij, ɔ́fən θrúw rəkɜ́rsɪv kɔ́lz; ənd fájnəlij, ɪt kəmbájnz ðijz səlúwʃənz tə fɔ́rm ðə səlúwʃən tə ðə ərɪ́dʒɪnəl prɒ́bləm. klǽsɪk əɡzǽmpəlz ɪnklúwd mɜ́rdʒ sɔ́rt, wɪ́tʃ dɪvájdz ən əréj ɪn hǽf, sɔ́rts ijtʃ hǽf, ənd ðɛn mɜ́rdʒɪz ðə sɔ́rtɪd hǽvz; kwɪ́k sɔ́rt, wɪ́tʃ pɑrtɪ́ʃənz déjtə əráwnd ə pɪ́vət ɛ́ləmənt; ənd bájnərij sɜ́rtʃ, wɪ́tʃ rəpíjtɪdlij dɪvájdz ðə sɜ́rtʃ spéjs ɪn hǽf. ðə əfɪ́ʃənsij əv dɪvájd ənd kɒ́ŋkər ǽlɡərɪ̀ðəmz ɔ́fən líjdz tə bɛ́tər tájm kəmplɛ́ksɪtij ðʌn stréjtfɔ́rwərd səlúwʃənz, tɪ́pɪkəlij rəzʌ́ltɪŋ ɪn lɒ̀ɡərɪ́ðmɪk ɔr lɪ̀nɪərɪ́θmɪk tájm kəmplɛ́ksɪtij fɔr mɛ́nij prɒ́bləmz ðət wʊd ʌ́ðərwàjz rəkwájər kwɒdrɒ́tɪk tájm."
    },
    {
        "Question": "Which algorithmic technique solves complex problems by breaking them down into simpler subproblems, solving each subproblem only once, and storing the solutions to avoid redundant computation?",
        "RightAnswer": "Dynamic Programming",
        "WrongAnswers": [
            "Greedy Algorithms",
            "Recursive Backtracking",
            "Branch and Bound",
            "Divide and Conquer",
            "Depth-First Search"
        ],
        "Explanation": "Dynamic Programming is a powerful algorithmic technique used to solve problems by breaking them down into overlapping subproblems. The key insight of Dynamic Programming is that we can save significant computation time by solving each subproblem only once and storing its solution in a table or matrix for future reference, rather than recalculating it repeatedly. This approach works particularly well when a problem exhibits two properties: optimal substructure, meaning the optimal solution to the problem contains optimal solutions to subproblems, and overlapping subproblems, where the same subproblems are encountered multiple times. Common applications include finding the shortest path in a graph, sequence alignment in genetics, resource allocation, and calculating Fibonacci numbers efficiently. Dynamic Programming transforms exponential time algorithms into polynomial time solutions, making previously intractable problems solvable. Unlike greedy algorithms that make locally optimal choices, Dynamic Programming considers all possible choices to find the globally optimal solution.",
        "trans_Question": "wɪ́tʃ ǽlɡərɪ̀ðəmɪk tɛkníjk sɒ́lvz kɒ́mplɛks prɒ́bləmz baj bréjkɪŋ ðɛm dawn ɪntə sɪ́mplər sʌ́bprɒ́bləmz, sɒ́lvɪŋ ijtʃ sʌ́bprɒ́bləm ównlij wʌ́ns, ənd stɔ́rɪŋ ðə səlúwʃənz tə əvɔ́jd rədʌ́ndənt kɒ̀mpjətéjʃən?",
        "trans_RightAnswer": "dajnǽmɪk prówɡræ̀mɪŋ",
        "trans_WrongAnswers": [
            "ɡríjdij ǽlɡərɪ̀ðəmz",
            "rəkɜ́rsɪv bǽktræ̀kɪŋ",
            "brǽntʃ ənd báwnd",
            "dɪvájd ənd kɒ́ŋkər",
            "dɛ́pθ-fɜ́rst sɜ́rtʃ"
        ],
        "trans_Explanation": "dajnǽmɪk prówɡræ̀mɪŋ ɪz ə páwərfəl ǽlɡərɪ̀ðəmɪk tɛkníjk júwzd tə sɒ́lv prɒ́bləmz baj bréjkɪŋ ðɛm dawn ɪntə ówvərlæ̀pɪŋ sʌ́bprɒ́bləmz. ðə kíj ɪ́nsàjt əv dajnǽmɪk prówɡræ̀mɪŋ ɪz ðət wij kən séjv sɪɡnɪ́fɪkənt kɒ̀mpjətéjʃən tájm baj sɒ́lvɪŋ ijtʃ sʌ́bprɒ́bləm ównlij wʌ́ns ənd stɔ́rɪŋ ɪts səlúwʃən ɪn ə téjbəl ɔr méjtrɪks fɔr fjúwtʃər rɛ́fərəns, rǽðər ðʌn rijkǽlkjəlèjtɪŋ ɪt rəpíjtɪdlij. ðɪs əprówtʃ wɜ́rks pərtɪ́kjələrlij wɛ́l wɛ́n ə prɒ́bləm əɡzɪ́bɪts túw prɒ́pərtijz: ɒ́ptɪməl sʌ́bstrʌ́ktʃər, míjnɪŋ ðə ɒ́ptɪməl səlúwʃən tə ðə prɒ́bləm kəntéjnz ɒ́ptɪməl səlúwʃənz tə sʌ́bprɒ́bləmz, ənd ówvərlæ̀pɪŋ sʌ́bprɒ́bləmz, wɛ́ər ðə séjm sʌ́bprɒ́bləmz ɑr ənkáwntərd mʌ́ltɪpəl tájmz. kɒ́mən æ̀plɪkéjʃənz ɪnklúwd fájndɪŋ ðə ʃɔ́rtəst pǽθ ɪn ə ɡrǽf, síjkwəns əlájnmənt ɪn dʒənɛ́tɪks, ríjsɔrs æ̀ləkéjʃən, ənd kǽlkjəlèjtɪŋ fɪ̀bənɒ́tʃij nʌ́mbərz əfɪ́ʃəntlij. dajnǽmɪk prówɡræ̀mɪŋ trænsfɔ́rmz ɛ̀kspownɛ́nʃəl tájm ǽlɡərɪ̀ðəmz ɪntə pɒ̀lijnówmijəl tájm səlúwʃənz, méjkɪŋ príjvijəslij ɪ̀ntrǽktəbəl prɒ́bləmz sɒ́lvəbəl. ʌ̀nlájk ɡríjdij ǽlɡərɪ̀ðəmz ðət méjk lówkəlij ɒ́ptɪməl tʃɔ́jsɪz, dajnǽmɪk prówɡræ̀mɪŋ kənsɪ́dərz ɔl pɒ́sɪbəl tʃɔ́jsɪz tə fájnd ðə ɡlówbəlij ɒ́ptɪməl səlúwʃən."
    },
    {
        "Question": "In algorithm design, which problem-solving approach always selects the immediate optimal choice at each step, hoping to find the global optimum solution?",
        "RightAnswer": "Greedy Algorithm",
        "WrongAnswers": [
            "Divide and Conquer",
            "Dynamic Programming",
            "Backtracking Algorithm",
            "Brute Force Method",
            "Branch and Bound"
        ],
        "Explanation": "A Greedy Algorithm is a problem-solving approach that makes the locally optimal choice at each step with the hope of finding a global optimum. At each step, it selects what appears to be the best immediate choice without reconsidering previous choices. This is similar to climbing a hill and always moving in the direction that goes highest, without looking ahead to see if another path might lead to a taller peak. Greedy algorithms are relatively simple to design and implement, making them practical for many problems. They work exceptionally well for optimization problems like Huffman coding, Dijkstra's shortest path, and minimum spanning tree algorithms. However, they don't guarantee optimal solutions for all problems, as sometimes the locally optimal choices don't lead to the globally optimal solution. Despite this limitation, greedy algorithms are valuable for their efficiency and simplicity when applicable to the right class of problems.",
        "trans_Question": "ɪn ǽlɡərɪ̀ðəm dəzájn, wɪ́tʃ prɒ́bləm-sɒ́lvɪŋ əprówtʃ ɔ́lwejz səlɛ́kts ðə ɪmíjdijət ɒ́ptɪməl tʃɔ́js æt ijtʃ stɛ́p, hówpɪŋ tə fájnd ðə ɡlówbəl ɒ́ptɪməm səlúwʃən?",
        "trans_RightAnswer": "ɡríjdij ǽlɡərɪ̀ðəm",
        "trans_WrongAnswers": [
            "dɪvájd ənd kɒ́ŋkər",
            "dajnǽmɪk prówɡræ̀mɪŋ",
            "bǽktræ̀kɪŋ ǽlɡərɪ̀ðəm",
            "brúwt fɔ́rs mɛ́θəd",
            "brǽntʃ ənd báwnd"
        ],
        "trans_Explanation": "ə ɡríjdij ǽlɡərɪ̀ðəm ɪz ə prɒ́bləm-sɒ́lvɪŋ əprówtʃ ðət méjks ðə lówkəlij ɒ́ptɪməl tʃɔ́js æt ijtʃ stɛ́p wɪð ðə hówp əv fájndɪŋ ə ɡlówbəl ɒ́ptɪməm. æt ijtʃ stɛ́p, ɪt səlɛ́kts wɒt əpɪ́ərz tə bij ðə bɛ́st ɪmíjdijət tʃɔ́js wɪðáwt rìjkənsɪ́dərɪŋ príjvijəs tʃɔ́jsɪz. ðɪs ɪz sɪ́mɪlər tə klájmɪŋ ə hɪ́l ənd ɔ́lwejz múwvɪŋ ɪn ðə dɪərɛ́kʃən ðət ɡówz hájəst, wɪðáwt lʊ́kɪŋ əhɛ́d tə síj ɪf ənʌ́ðər pǽθ majt líjd tə ə tɔ́lər píjk. ɡríjdij ǽlɡərɪ̀ðəmz ɑr rɛ́lətɪvlij sɪ́mpəl tə dəzájn ənd ɪ́mpləmənt, méjkɪŋ ðɛm prǽktɪkəl fɔr mɛ́nij prɒ́bləmz. ðej wɜ́rk əksɛ́pʃənəlij wɛ́l fɔr ɒptɪmɪzéjʃən prɒ́bləmz lájk hʌ́fmən kówdɪŋ, dájkstrə'z ʃɔ́rtəst pǽθ, ənd mɪ́nɪməm spǽnɪŋ tríj ǽlɡərɪ̀ðəmz. hàwɛ́vər, ðej dównt ɡɛ̀ərəntíj ɒ́ptɪməl səlúwʃənz fɔr ɔl prɒ́bləmz, æz sʌ́mtàjmz ðə lówkəlij ɒ́ptɪməl tʃɔ́jsɪz dównt líjd tə ðə ɡlówbəlij ɒ́ptɪməl səlúwʃən. dəspájt ðɪs lɪ̀mɪtéjʃən, ɡríjdij ǽlɡərɪ̀ðəmz ɑr vǽljəbəl fɔr ðɛər əfɪ́ʃənsij ənd sɪmplɪ́sɪtij wɛ́n ǽplɪkəbəl tə ðə rájt klǽs əv prɒ́bləmz."
    },
    {
        "Question": "Which algorithmic technique systematically tries multiple possibilities for a solution, discarding failed paths and returning to previous steps when necessary?",
        "RightAnswer": "Backtracking",
        "WrongAnswers": [
            "Greedy Algorithm",
            "Dynamic Programming",
            "Breadth-First Search",
            "Hashing",
            "Binary Insertion"
        ],
        "Explanation": "Backtracking is a methodical problem-solving technique in computer science where potential solutions are built incrementally. When the algorithm reaches a point where it determines the current path cannot lead to a valid solution, it abandons that path (backtracks), returning to a previous decision point to explore alternative branches. Think of it like navigating a maze: if you reach a dead end, you retrace your steps to the last intersection and try a different route. Backtracking is particularly useful for constraint satisfaction problems, combinatorial optimization, and puzzles like Sudoku or the Eight Queens problem. It's more efficient than brute force approaches because it can eliminate entire sections of the search space once it recognizes a path as unproductive. The technique relies on recursion to maintain the state at each decision point, allowing the algorithm to efficiently return to previous states when necessary.",
        "trans_Question": "wɪ́tʃ ǽlɡərɪ̀ðəmɪk tɛkníjk sɪ̀stəmǽtɪklij trájz mʌ́ltɪpəl pɒ̀sɪbɪ́lɪtijz fɔr ə səlúwʃən, dɪskɑ́rdɪŋ féjld pǽðz ənd rətɜ́rnɪŋ tə príjvijəs stɛ́ps wɛ́n nɛ́səsɛ̀ərij?",
        "trans_RightAnswer": "bǽktræ̀kɪŋ",
        "trans_WrongAnswers": [
            "ɡríjdij ǽlɡərɪ̀ðəm",
            "dajnǽmɪk prówɡræ̀mɪŋ",
            "brɛ́dθ-fɜ́rst sɜ́rtʃ",
            "hǽʃɪŋ",
            "bájnərij ɪnsɜ́rʃən"
        ],
        "trans_Explanation": "bǽktræ̀kɪŋ ɪz ə məθɒ́dɪkəl prɒ́bləm-sɒ́lvɪŋ tɛkníjk ɪn kəmpjúwtər sájəns wɛ́ər pətɛ́nʃəl səlúwʃənz ɑr bɪ́lt ɪnkrəmɛ́ntəlìj. wɛ́n ðə ǽlɡərɪ̀ðəm ríjtʃɪz ə pɔ́jnt wɛ́ər ɪt dətɜ́rmɪnz ðə kɑ́rənt pǽθ kǽnɒt líjd tə ə vǽlɪd səlúwʃən, ɪt əbǽndənz ðət pǽθ (bǽktræ̀ks), rətɜ́rnɪŋ tə ə príjvijəs dəsɪ́ʒən pɔ́jnt tə əksplɔ́r ɔltɜ́rnətɪv brǽntʃɪz. θɪ́ŋk əv ɪt lájk nǽvɪɡejtɪŋ ə méjz: ɪf juw ríjtʃ ə dɛ́d ɛ́nd, juw rijtréjs jɔr stɛ́ps tə ðə lǽst ɪ̀ntərsɛ́kʃən ənd tráj ə dɪ́fərənt ráwt. bǽktræ̀kɪŋ ɪz pərtɪ́kjələrlij júwsfəl fɔr kənstréjnt sæ̀tɪsfǽkʃən prɒ́bləmz, kɒ̀mbɪnéjtɔrijəl ɒptɪmɪzéjʃən, ənd pʌ́zəlz lájk súwdòwkuw ɔr ðə éjt kwíjnz prɒ́bləm. ɪt's mɔr əfɪ́ʃənt ðʌn brúwt fɔ́rs əprówtʃɪz bəkɒ́z ɪt kən əlɪ́mɪnèjt əntájər sɛ́kʃənz əv ðə sɜ́rtʃ spéjs wʌ́ns ɪt rɛ́kəɡnàjzɪz ə pǽθ æz ʌ̀nprədʌ́ktɪv. ðə tɛkníjk rəlájz ɒn rəkɜ́rʒən tə mejntéjn ðə stéjt æt ijtʃ dəsɪ́ʒən pɔ́jnt, əláwɪŋ ðə ǽlɡərɪ̀ðəm tə əfɪ́ʃəntlij rətɜ́rn tə príjvijəs stéjts wɛ́n nɛ́səsɛ̀ərij."
    },
    {
        "Question": "In computational complexity theory, which term describes a class of problems that are at least as hard as the hardest problems in NP, and to which all other NP problems can be reduced in polynomial time?",
        "RightAnswer": "NP-Completeness",
        "WrongAnswers": [
            "P-Hardness",
            "Polynomial Tractability",
            "Exponential Complexity",
            "Computational Intractability",
            "Algorithm Inefficiency"
        ],
        "Explanation": "NP-Completeness is a fundamental concept in computational complexity theory that characterizes particularly difficult computational problems. A problem is NP-Complete if it belongs to the class NP (problems whose solutions can be verified quickly, in polynomial time) and every other problem in NP can be transformed into it via a polynomial-time reduction. This means NP-Complete problems represent the hardest problems in NP. If anyone finds an efficient (polynomial-time) algorithm to solve any NP-Complete problem, then all NP problems would be efficiently solvable, resolving the famous P versus NP question. Classic examples include the Traveling Salesman Problem, Graph Coloring, and Boolean Satisfiability. The significance of NP-Completeness is that it helps computer scientists identify problems that are likely computationally intractable, allowing them to justify using approximation algorithms or heuristics rather than seeking exact efficient solutions that might not exist.",
        "trans_Question": "ɪn kɒ̀mpjuwtéjʃənəl kəmplɛ́ksɪtij θíjərij, wɪ́tʃ tɜ́rm dəskrájbz ə klǽs əv prɒ́bləmz ðət ɑr æt líjst æz hɑ́rd æz ðə hɑ́rdəst prɒ́bləmz ɪn NP, ənd tə wɪ́tʃ ɔl ʌ́ðər NP prɒ́bləmz kən bij rədjúwst ɪn pɒ̀lijnówmijəl tájm?",
        "trans_RightAnswer": "np-kəmplíjtnəs",
        "trans_WrongAnswers": [
            "p-hɑ́rdnəs",
            "pɒ̀lijnówmijəl trǽktəbɪ́lɪtij",
            "ɛ̀kspownɛ́nʃəl kəmplɛ́ksɪtij",
            "kɒ̀mpjuwtéjʃənəl ɪ̀ntrǽktəbɪ́lɪtij",
            "ǽlɡərɪ̀ðəm ɪ̀nəfɪ́ʃənsij"
        ],
        "trans_Explanation": "np-kəmplíjtnəs ɪz ə fʌ̀ndəmɛ́ntəl kɒ́nsɛpt ɪn kɒ̀mpjuwtéjʃənəl kəmplɛ́ksɪtij θíjərij ðət kǽrəktərajzɪz pərtɪ́kjələrlij dɪ́fɪkəlt kɒ̀mpjuwtéjʃənəl prɒ́bləmz. ə prɒ́bləm ɪz np-kəmplíjt ɪf ɪt bəlɔ́ŋz tə ðə klǽs NP (prɒ́bləmz húwz səlúwʃənz kən bij vɛ́ərɪfajd kwɪ́klij, ɪn pɒ̀lijnówmijəl tájm) ənd ɛvərij ʌ́ðər prɒ́bləm ɪn NP kən bij trænsfɔ́rmd ɪntə ɪt vájə ə pɒ̀lijnówmijəl-tájm rədʌ́kʃən. ðɪs míjnz np-kəmplíjt prɒ́bləmz rɛ̀prəzɛ́nt ðə hɑ́rdəst prɒ́bləmz ɪn NP. ɪf ɛ́nijwən fájndz ən əfɪ́ʃənt (pɒ̀lijnówmijəl-tájm) ǽlɡərɪ̀ðəm tə sɒ́lv ɛ́nij np-kəmplíjt prɒ́bləm, ðɛn ɔl NP prɒ́bləmz wʊd bij əfɪ́ʃəntlij sɒ́lvəbəl, rijzɒ́lvɪŋ ðə féjməs P vɜ́rsəs NP kwɛ́stʃən. klǽsɪk əɡzǽmpəlz ɪnklúwd ðə trǽvəlɪŋ séjlzmən prɒ́bləm, ɡrǽf kʌ́lərɪŋ, ənd buwlíjən sæ̀tɪsfǽɪəbɪ́lɪtij. ðə sɪɡnɪ́fɪkəns əv np-kəmplíjtnəs ɪz ðət ɪt hɛ́lps kəmpjúwtər sájəntɪsts ajdɛ́ntɪfàj prɒ́bləmz ðət ɑr lájklij kɒ̀mpjətéjʃənəlij ɪ̀ntrǽktəbəl, əláwɪŋ ðɛm tə dʒʌ́stɪfàj júwzɪŋ əprɒ̀ksəméjʃən ǽlɡərɪ̀ðəmz ɔr hjʊrɪ́stɪks rǽðər ðʌn síjkɪŋ əɡzǽkt əfɪ́ʃənt səlúwʃənz ðət majt nɒt əɡzɪ́st."
    },
    {
        "Question": "Which fundamental theoretical problem in computer science asks whether every problem whose solution can be quickly verified can also be quickly solved by a computer?",
        "RightAnswer": "P versus NP",
        "WrongAnswers": [
            "Turing Completeness",
            "Halting Problem",
            "Shannon's Theorem",
            "Von Neumann Bottleneck",
            "Church-Turing Thesis"
        ],
        "Explanation": "P versus NP is one of the most important unsolved problems in theoretical computer science. It asks a fundamental question about computation: if a solution to a problem can be verified quickly (in polynomial time, which is the NP part), can the solution also be found quickly (also in polynomial time, which is the P part)? In other words, is finding a solution inherently harder than checking one? Most computer scientists believe P does not equal NP, meaning there are problems whose solutions can be verified quickly but cannot be solved quickly. This distinction has profound implications for cryptography, optimization, artificial intelligence, and many other fields. If P were proven equal to NP, many currently intractable computational problems would become solvable efficiently, potentially revolutionizing numerous industries. The Clay Mathematics Institute has designated P versus NP as one of its seven Millennium Prize Problems, offering one million dollars for its solution.",
        "trans_Question": "wɪ́tʃ fʌ̀ndəmɛ́ntəl θìjərɛ́tɪkəl prɒ́bləm ɪn kəmpjúwtər sájəns ǽsks wɛ́ðər ɛvərij prɒ́bləm húwz səlúwʃən kən bij kwɪ́klij vɛ́ərɪfajd kən ɔ́lsow bij kwɪ́klij sɒ́lvd baj ə kəmpjúwtər?",
        "trans_RightAnswer": "P vɜ́rsəs NP",
        "trans_WrongAnswers": [
            "tjʊ́ərɪŋ kəmplíjtnəs",
            "hɔ́ltɪŋ prɒ́bləm",
            "ʃǽnən'z θɪ́ərəm",
            "vɒn nɔ́jmən bɒ́təlnɛ̀k",
            "tʃɜ́rtʃ-tjʊ́ərɪŋ θíjsɪs"
        ],
        "trans_Explanation": "P vɜ́rsəs NP ɪz wʌ́n əv ðə mówst ɪmpɔ́rtənt ʌ̀nsɒ́lvd prɒ́bləmz ɪn θìjərɛ́tɪkəl kəmpjúwtər sájəns. ɪt ǽsks ə fʌ̀ndəmɛ́ntəl kwɛ́stʃən əbawt kɒ̀mpjətéjʃən: ɪf ə səlúwʃən tə ə prɒ́bləm kən bij vɛ́ərɪfajd kwɪ́klij (ɪn pɒ̀lijnówmijəl tájm, wɪ́tʃ ɪz ðə NP pɑ́rt), kən ðə səlúwʃən ɔ́lsow bij fáwnd kwɪ́klij (ɔ́lsow ɪn pɒ̀lijnówmijəl tájm, wɪ́tʃ ɪz ðə P pɑ́rt)? ɪn ʌ́ðər wɜ́rdz, ɪz fájndɪŋ ə səlúwʃən ɪnhɛ́ərəntlij hɑ́rdər ðʌn tʃɛ́kɪŋ wʌ́n? mówst kəmpjúwtər sájəntɪsts bəlíjv P dʌz nɒt íjkwəl NP, míjnɪŋ ðɛər ɑr prɒ́bləmz húwz səlúwʃənz kən bij vɛ́ərɪfajd kwɪ́klij bʌt kǽnɒt bij sɒ́lvd kwɪ́klij. ðɪs dɪstɪ́ŋkʃən həz prowfáwnd ɪ̀mplɪkéjʃənz fɔr krɪptɒ́ɡrəfij, ɒptɪmɪzéjʃən, ɑ̀rtɪfɪ́ʃəl ɪntɛ́lɪdʒəns, ənd mɛ́nij ʌ́ðər fíjldz. ɪf P wɜ́r prúwvən íjkwəl tə NP, mɛ́nij kɜ́rəntlij ɪ̀ntrǽktəbəl kɒ̀mpjuwtéjʃənəl prɒ́bləmz wʊd bəkʌ́m sɒ́lvəbəl əfɪ́ʃəntlij, pətɛ́nʃəlij rɛ̀vəlúwʃənàjzɪŋ njúwmərəs ɪ́ndəstrijz. ðə kléj mæ̀θəmǽtɪks ɪ́nstɪtùwt həz dɛ́zɪɡnèjtɪd P vɜ́rsəs NP æz wʌ́n əv ɪts sɛ́vən mɪlɛ́nijəm prájz prɒ́bləmz, ɔ́fərɪŋ wʌ́n mɪ́ljən dɒ́lərz fɔr ɪts səlúwʃən."
    },
    {
        "Question": "Which algorithm design technique is specifically developed to find reasonably good solutions for computationally difficult optimization problems, even though it cannot guarantee the optimal solution?",
        "RightAnswer": "Approximation Algorithm",
        "WrongAnswers": [
            "Probabilistic Algorithm",
            "Greedy Algorithm",
            "Randomized Algorithm",
            "Heuristic Search",
            "Dynamic Programming"
        ],
        "Explanation": "An Approximation Algorithm is a technique used in computer science to tackle optimization problems that are too complex to solve optimally within reasonable time constraints. Unlike exact algorithms that guarantee optimal solutions but may take exponential time, approximation algorithms produce solutions that are provably close to optimal, with mathematical guarantees on how far the solution might deviate from the best possible answer. These algorithms are particularly valuable for NP-hard problems where finding the perfect solution would be computationally infeasible for large inputs. For example, when solving the traveling salesman problem across thousands of cities, an approximation algorithm might quickly find a route that is guaranteed to be no more than 50 percent longer than the optimal route. Computer scientists analyze approximation algorithms based on their approximation ratio, which measures the worst-case relationship between the algorithm's solution and the optimal solution. This approach strikes a practical balance between solution quality and computational efficiency for otherwise intractable problems.",
        "trans_Question": "wɪ́tʃ ǽlɡərɪ̀ðəm dəzájn tɛkníjk ɪz spəsɪ́fɪklij dəvɛ́ləpt tə fájnd ríjzənəblij ɡʊ́d səlúwʃənz fɔr kɒ̀mpjətéjʃənəlij dɪ́fɪkəlt ɒptɪmɪzéjʃən prɒ́bləmz, íjvən ðów ɪt kǽnɒt ɡɛ̀ərəntíj ðə ɒ́ptɪməl səlúwʃən?",
        "trans_RightAnswer": "əprɒ̀ksəméjʃən ǽlɡərɪ̀ðəm",
        "trans_WrongAnswers": [
            "prɒ̀bəbɪlɪ́stɪk ǽlɡərɪ̀ðəm",
            "ɡríjdij ǽlɡərɪ̀ðəm",
            "rǽndəmàjzd ǽlɡərɪ̀ðəm",
            "hjʊrɪ́stɪk sɜ́rtʃ",
            "dajnǽmɪk prówɡræ̀mɪŋ"
        ],
        "trans_Explanation": "ən əprɒ̀ksəméjʃən ǽlɡərɪ̀ðəm ɪz ə tɛkníjk júwzd ɪn kəmpjúwtər sájəns tə tǽkəl ɒptɪmɪzéjʃən prɒ́bləmz ðət ɑr túw kɒ́mplɛks tə sɒ́lv ɒ́ptɪməlij wɪðɪ́n ríjzənəbəl tájm kənstréjnts. ʌ̀nlájk əɡzǽkt ǽlɡərɪ̀ðəmz ðət ɡɛ̀ərəntíj ɒ́ptɪməl səlúwʃənz bʌt mej téjk ɛ̀kspownɛ́nʃəl tájm, əprɒ̀ksəméjʃən ǽlɡərɪ̀ðəmz prədúws səlúwʃənz ðət ɑr prúwvəblij klóws tə ɒ́ptɪməl, wɪð mæ̀θəmǽtɪkəl ɡɛ̀ərəntíjz ɒn háw fɑ́r ðə səlúwʃən majt díjvijèjt frəm ðə bɛ́st pɒ́sɪbəl ǽnsər. ðijz ǽlɡərɪ̀ðəmz ɑr pərtɪ́kjələrlij vǽljəbəl fɔr np-hɑ́rd prɒ́bləmz wɛ́ər fájndɪŋ ðə pɜ́rfəkt səlúwʃən wʊd bij kɒ̀mpjətéjʃənəlij ɪ̀nfíjzəbəl fɔr lɑ́rdʒ ɪ́npʊ̀ts. fɔr əɡzǽmpəl, wɛ́n sɒ́lvɪŋ ðə trǽvəlɪŋ séjlzmən prɒ́bləm əkrɔ́s θáwzəndz əv sɪ́tijz, ən əprɒ̀ksəméjʃən ǽlɡərɪ̀ðəm majt kwɪ́klij fájnd ə ráwt ðət ɪz ɡɛ̀ərəntíjd tə bij now mɔr ðʌn 50 pərsɛ́nt lɔ́ŋɡər ðʌn ðə ɒ́ptɪməl ráwt. kəmpjúwtər sájəntɪsts ǽnəlàjz əprɒ̀ksəméjʃən ǽlɡərɪ̀ðəmz béjst ɒn ðɛər əprɒ̀ksəméjʃən réjʃijòw, wɪ́tʃ mɛ́ʒərz ðə wɜ́rst-kéjs rəléjʃənʃɪ̀p bijtwíjn ðə ǽlɡərɪ̀ðəm'z səlúwʃən ənd ðə ɒ́ptɪməl səlúwʃən. ðɪs əprówtʃ strájks ə prǽktɪkəl bǽləns bijtwíjn səlúwʃən kwɑ́lɪtij ənd kɒ̀mpjuwtéjʃənəl əfɪ́ʃənsij fɔr ʌ́ðərwàjz ɪ̀ntrǽktəbəl prɒ́bləmz."
    },
    {
        "Question": "In computer science, what term describes a problem-solving approach that uses practical methods or shortcuts to find good-enough solutions when classic methods are too slow or impractical?",
        "RightAnswer": "Heuristic",
        "WrongAnswers": [
            "Algorithm",
            "Recursion",
            "Compiler",
            "Protocol",
            "Abstraction"
        ],
        "Explanation": "A heuristic is a practical approach to problem solving that sacrifices optimality, completeness, or precision for speed. In computer science, heuristics are especially valuable when dealing with complex problems where finding the absolute best solution would be computationally expensive or even impossible within reasonable time constraints. Instead of exhaustively examining every possible solution, a heuristic applies a clever rule of thumb, an educated guess, or an intuitive judgment to find a solution that is good enough for the practical purpose. For example, in pathfinding problems, the A-star search algorithm uses a heuristic to estimate the distance to the goal, allowing it to explore more promising paths first. Heuristics are found in many applications including artificial intelligence, optimization problems, machine learning, and game theory. While they don't guarantee the optimal solution, well-designed heuristics can dramatically improve efficiency while maintaining acceptable results.",
        "trans_Question": "ɪn kəmpjúwtər sájəns, wɒt tɜ́rm dəskrájbz ə prɒ́bləm-sɒ́lvɪŋ əprówtʃ ðət júwsɪz prǽktɪkəl mɛ́θədz ɔr ʃɔ́rtkʌ̀ts tə fájnd ɡʊ́d-ənʌ́f səlúwʃənz wɛ́n klǽsɪk mɛ́θədz ɑr túw slów ɔr ɪ̀mprǽktɪkəl?",
        "trans_RightAnswer": "hjʊrɪ́stɪk",
        "trans_WrongAnswers": [
            "ǽlɡərɪ̀ðəm",
            "rəkɜ́rʒən",
            "kəmpájlər",
            "prówtəkɒ̀l",
            "æbstrǽkʃən"
        ],
        "trans_Explanation": "ə hjʊrɪ́stɪk ɪz ə prǽktɪkəl əprówtʃ tə prɒ́bləm sɒ́lvɪŋ ðət sǽkrɪfàjsɪz ɒ̀ptɪmǽlɪtij, kəmplíjtnəs, ɔr prəsɪ́ʒən fɔr spíjd. ɪn kəmpjúwtər sájəns, hjʊrɪ́stɪks ɑr əspɛ́ʃəlij vǽljəbəl wɛ́n díjlɪŋ wɪð kɒ́mplɛks prɒ́bləmz wɛ́ər fájndɪŋ ðə ǽbsəlùwt bɛ́st səlúwʃən wʊd bij kɒ̀mpjətéjʃənəlij əkspɛ́nsɪv ɔr íjvən ɪ̀mpɒ́sɪbəl wɪðɪ́n ríjzənəbəl tájm kənstréjnts. ɪnstɛ́d əv əɡzɒ́stɪvlij əɡzǽmɪnɪŋ ɛvərij pɒ́sɪbəl səlúwʃən, ə hjʊrɪ́stɪk əplájz ə klɛ́vər rúwl əv θʌ́m, ən ɛ́dʒəkèjtɪd ɡɛ́s, ɔr ən ɪntúwɪtɪv dʒʌ́dʒmənt tə fájnd ə səlúwʃən ðət ɪz ɡʊ́d ənʌ́f fɔr ðə prǽktɪkəl pɜ́rpəs. fɔr əɡzǽmpəl, ɪn pǽθfàjndɪŋ prɒ́bləmz, ðə ə-stɑ́r sɜ́rtʃ ǽlɡərɪ̀ðəm júwsɪz ə hjʊrɪ́stɪk tə ɛ́stɪmèjt ðə dɪ́stəns tə ðə ɡówl, əláwɪŋ ɪt tə əksplɔ́r mɔr prɒ́mɪsɪŋ pǽðz fɜ́rst. hjʊrɪ́stɪks ɑr fáwnd ɪn mɛ́nij æ̀plɪkéjʃənz ɪnklúwdɪŋ ɑ̀rtɪfɪ́ʃəl ɪntɛ́lɪdʒəns, ɒptɪmɪzéjʃən prɒ́bləmz, məʃíjn lɜ́rnɪŋ, ənd ɡéjm θíjərij. wájl ðej dównt ɡɛ̀ərəntíj ðə ɒ́ptɪməl səlúwʃən, wɛ́l-dəzájnd hjʊrɪ́stɪks kən drəmǽtɪkəlij ɪmprúwv əfɪ́ʃənsij wájl mejntéjnɪŋ æksɛ́ptəbəl rəzʌ́lts."
    },
    {
        "Question": "Which field of computer science deals with securing data through the transformation of information into formats that unauthorized parties cannot understand?",
        "RightAnswer": "Cryptography",
        "WrongAnswers": [
            "Data Mining",
            "Machine Learning",
            "Virtual Reality",
            "Parallel Computing",
            "Database Normalization"
        ],
        "Explanation": "Cryptography is the practice and study of techniques for secure communication and data protection in the presence of adversaries. It involves creating systems that encode messages and information in ways that only intended recipients can decode and understand. Modern cryptography intersects disciplines like mathematics, computer science, and electrical engineering, and serves as the foundation for essential security features like secure web browsing, password protection, and digital signatures. Cryptographers develop algorithms that scramble data using keys, making it appear random to anyone without the correct decryption method. The field has evolved from ancient ciphers to sophisticated mathematical constructs that protect our digital infrastructure, enabling confidentiality, data integrity, authentication, and non-repudiation in our interconnected world.",
        "trans_Question": "wɪ́tʃ fíjld əv kəmpjúwtər sájəns díjlz wɪð səkjʊ́rɪŋ déjtə θrúw ðə træ̀nsfərméjʃən əv ɪnfərméjʃən ɪntə fɔ́rmæ̀ts ðət ənɔ́θəràjzd pɑ́rtijz kǽnɒt ʌ̀ndərstǽnd?",
        "trans_RightAnswer": "krɪptɒ́ɡrəfij",
        "trans_WrongAnswers": [
            "déjtə májnɪŋ",
            "məʃíjn lɜ́rnɪŋ",
            "vɜ́rtʃuwəl rìjǽlɪtij",
            "pǽrəlɛ̀l kəmpjúwtɪŋ",
            "déjtəbèjs nɔ̀rməlɪzéjʃən"
        ],
        "trans_Explanation": "krɪptɒ́ɡrəfij ɪz ðə prǽktɪs ənd stʌ́dij əv tɛkníjks fɔr səkjʊ́r kəmjùwnɪkéjʃən ənd déjtə prətɛ́kʃən ɪn ðə prɛ́zəns əv ǽdvərsɛ̀ərijz. ɪt ɪnvɒ́lvz krijéjtɪŋ sɪ́stəmz ðət ɛnkówd mɛ́sɪdʒɪz ənd ɪnfərméjʃən ɪn wéjz ðət ównlij ɪntɛ́ndɪd rəsɪ́pijənts kən dəkówd ənd ʌ̀ndərstǽnd. mɒ́dərn krɪptɒ́ɡrəfij ɪ̀ntərsɛ́kts dɪ́sɪplɪnz lájk mæ̀θəmǽtɪks, kəmpjúwtər sájəns, ənd əlɛ́ktrɪkəl ɛ̀ndʒɪnɪ́ərɪŋ, ənd sɜ́rvz æz ðə fawndéjʃən fɔr əsɛ́nʃəl səkjʊ́rɪtij fíjtʃərz lájk səkjʊ́r wɛ́b bráwzɪŋ, pǽswɜ̀rd prətɛ́kʃən, ənd dɪ́dʒɪtəl sɪ́ɡnətʃərz. krɪptɒ́ɡrəfərz dəvɛ́ləp ǽlɡərɪ̀ðəmz ðət skrǽmbəl déjtə júwzɪŋ kíjz, méjkɪŋ ɪt əpɪ́ər rǽndəm tə ɛ́nijwən wɪðáwt ðə kərɛ́kt dəkrɪ́pʃən mɛ́θəd. ðə fíjld həz əvɒ́lvd frəm éjntʃənt sájfərz tə səfɪ́stɪkèjtɪd mæ̀θəmǽtɪkəl kɒ́nstrəkts ðət prətɛ́kt awər dɪ́dʒɪtəl ɪnfrəstrʌ́ktʃər, ɛnéjbəlɪŋ kɒ̀nfɪdɛ́nʃijǽlɪtij, déjtə ɪntɛ́ɡrɪtij, ɔθɛ̀ntɪkéjʃən, ənd nɒn-rəpjùwdijéjʃən ɪn awər ɪ̀ntərkənɛ́ktɪd wɜ́rld."
    },
    {
        "Question": "Which cryptographic approach uses a pair of mathematically related keys, where one is shared publicly and the other is kept private, allowing for secure communication without requiring prior key exchange?",
        "RightAnswer": "Public Key Cryptography",
        "WrongAnswers": [
            "Symmetric Encryption",
            "Hash Function Authentication",
            "One-Time Pad Security",
            "Stream Cipher Methodology",
            "Block Chain Verification"
        ],
        "Explanation": "Public Key Cryptography is a revolutionary approach to secure communication that uses two mathematically related keys: a public key that can be shared with anyone, and a private key that remains secret. Unlike traditional symmetric encryption where both parties must share the same secret key beforehand, public key cryptography eliminates this requirement. When someone wants to send you a secure message, they encrypt it using your public key, creating a message that can only be decrypted with your private key. This elegant system enables secure communication between parties who have never met, underpins modern internet security protocols like HTTPS, enables digital signatures that verify identity, and forms the foundation for secure online transactions. Developed in the 1970s, it solved the key distribution problem that had limited cryptography for centuries and now protects virtually all secure digital communications.",
        "trans_Question": "wɪ́tʃ krɪptɒ́ɡrəfɪk əprówtʃ júwsɪz ə pɛ́ər əv mæ̀θəmǽtɪkəlij rəléjtɪd kíjz, wɛ́ər wʌ́n ɪz ʃɛ́ərd pʌ́blɪklij ənd ðə ʌ́ðər ɪz kɛ́pt prájvət, əláwɪŋ fɔr səkjʊ́r kəmjùwnɪkéjʃən wɪðáwt rijkwájərɪŋ prájər kíj əkstʃéjndʒ?",
        "trans_RightAnswer": "pʌ́blɪk kíj krɪptɒ́ɡrəfij",
        "trans_WrongAnswers": [
            "sɪmɛ́trɪk ɛnkrɪ́pʃən",
            "hǽʃ fʌ́ŋkʃən ɔθɛ̀ntɪkéjʃən",
            "wʌ́n-tájm pǽd səkjʊ́rɪtij",
            "stríjm sájfər mɛ̀θədɒ́lədʒij",
            "blɒ́k tʃéjn vɛ̀ərɪfɪkéjʃən"
        ],
        "trans_Explanation": "pʌ́blɪk kíj krɪptɒ́ɡrəfij ɪz ə rɛ̀vəlúwʃənɛ̀ərij əprówtʃ tə səkjʊ́r kəmjùwnɪkéjʃən ðət júwsɪz túw mæ̀θəmǽtɪkəlij rəléjtɪd kíjz: ə pʌ́blɪk kíj ðət kən bij ʃɛ́ərd wɪð ɛ́nijwən, ənd ə prájvət kíj ðət rəméjnz síjkrət. ʌ̀nlájk trədɪ́ʃənəl sɪmɛ́trɪk ɛnkrɪ́pʃən wɛ́ər bówθ pɑ́rtijz mʌst ʃɛ́ər ðə séjm síjkrət kíj bəfɔ́rhæ̀nd, pʌ́blɪk kíj krɪptɒ́ɡrəfij əlɪ́mɪnèjts ðɪs rəkwájərmənt. wɛ́n sʌ́mwʌ̀n wɒ́nts tə sɛ́nd juw ə səkjʊ́r mɛ́sɪdʒ, ðej ɛnkrɪ́pt ɪt júwzɪŋ jɔr pʌ́blɪk kíj, krijéjtɪŋ ə mɛ́sɪdʒ ðət kən ównlij bij dəkrɪ́ptɪd wɪð jɔr prájvət kíj. ðɪs ɛ́ləɡənt sɪ́stəm ɛnéjbəlz səkjʊ́r kəmjùwnɪkéjʃən bijtwíjn pɑ́rtijz huw həv nɛ́vər mɛ́t, ʌ̀ndərpɪ́nz mɒ́dərn ɪ́ntərnɛ̀t səkjʊ́rɪtij prówtəkɔ̀lz lájk HTTPS, ɛnéjbəlz dɪ́dʒɪtəl sɪ́ɡnətʃərz ðət vɛ́ərɪfaj ajdɛ́ntɪtij, ənd fɔ́rmz ðə fawndéjʃən fɔr səkjʊ́r ɔ́nlàjn trænzǽkʃənz. dəvɛ́ləpt ɪn ðə 1970s, ɪt sɒ́lvd ðə kíj dɪ̀strəbjúwʃən prɒ́bləm ðət hǽd lɪ́mɪtɪd krɪptɒ́ɡrəfij fɔr sɛ́ntʃərijz ənd náw prətɛ́kts vɜ́rtʃuwəlij ɔl səkjʊ́r dɪ́dʒɪtəl kəmjùwnɪkéjʃənz."
    },
    {
        "Question": "Which cryptographic method uses the same secret key for both encrypting and decrypting data, making it faster but requiring secure key exchange between parties?",
        "RightAnswer": "Symmetric Encryption",
        "WrongAnswers": [
            "Asymmetric Hashing",
            "Public Key Infrastructure",
            "One-Way Encryption",
            "Token-Based Authentication",
            "Digital Signature Algorithm"
        ],
        "Explanation": "Symmetric Encryption is a cryptographic method where the same key is used for both encrypting and decrypting data. Think of it like a physical lockbox where both the sender and recipient need copies of the identical key. This approach is computationally efficient and fast, making it ideal for encrypting large amounts of data. However, it presents a key distribution challenge: how do you securely share the secret key with intended recipients without exposing it to potential attackers? Common symmetric encryption algorithms include AES (Advanced Encryption Standard), DES (Data Encryption Standard), and Blowfish. While symmetric encryption excels in performance, its primary limitation is that it requires a secure channel to exchange the key initially, which is why it's often used in combination with asymmetric encryption in modern security protocols.",
        "trans_Question": "wɪ́tʃ krɪptɒ́ɡrəfɪk mɛ́θəd júwsɪz ðə séjm síjkrət kíj fɔr bówθ ɛnkrɪ́ptɪŋ ənd dɪkrɪ́ptɪŋ déjtə, méjkɪŋ ɪt fǽstər bʌt rijkwájərɪŋ səkjʊ́r kíj əkstʃéjndʒ bijtwíjn pɑ́rtijz?",
        "trans_RightAnswer": "sɪmɛ́trɪk ɛnkrɪ́pʃən",
        "trans_WrongAnswers": [
            "èjsɪmɛ́trɪk hǽʃɪŋ",
            "pʌ́blɪk kíj ɪnfrəstrʌ́ktʃər",
            "wʌ́n-wej ɛnkrɪ́pʃən",
            "tówkən-béjst ɔθɛ̀ntɪkéjʃən",
            "dɪ́dʒɪtəl sɪ́ɡnətʃər ǽlɡərɪ̀ðəm"
        ],
        "trans_Explanation": "sɪmɛ́trɪk ɛnkrɪ́pʃən ɪz ə krɪptɒ́ɡrəfɪk mɛ́θəd wɛ́ər ðə séjm kíj ɪz júwzd fɔr bówθ ɛnkrɪ́ptɪŋ ənd dɪkrɪ́ptɪŋ déjtə. θɪ́ŋk əv ɪt lájk ə fɪ́zɪkəl lɒ́kbɒ̀ks wɛ́ər bówθ ðə sɛ́ndər ənd rəsɪ́pijənt níjd kɒ́pijz əv ðə ajdɛ́ntɪkəl kíj. ðɪs əprówtʃ ɪz kɒ̀mpjətéjʃənəlij əfɪ́ʃənt ənd fǽst, méjkɪŋ ɪt ajdíjəl fɔr ɛnkrɪ́ptɪŋ lɑ́rdʒ əmáwnts əv déjtə. hàwɛ́vər, ɪt prɛ́zənts ə kíj dɪ̀strəbjúwʃən tʃǽləndʒ: háw dúw juw səkjʊ́rlij ʃɛ́ər ðə síjkrət kíj wɪð ɪntɛ́ndɪd rəsɪ́pijənts wɪðáwt əkspówzɪŋ ɪt tə pətɛ́nʃəl ətǽkərz? kɒ́mən sɪmɛ́trɪk ɛnkrɪ́pʃən ǽlɡərɪ̀ðəmz ɪnklúwd AES (ədvǽnst ɛnkrɪ́pʃən stǽndərd), DES (déjtə ɛnkrɪ́pʃən stǽndərd), ənd blówfɪʃ. wájl sɪmɛ́trɪk ɛnkrɪ́pʃən əksɛ́lz ɪn pərfɔ́rməns, ɪts prájmɛ̀ərij lɪ̀mɪtéjʃən ɪz ðət ɪt rəkwájərz ə səkjʊ́r tʃǽnəl tə əkstʃéjndʒ ðə kíj ɪnɪ́ʃəlij, wɪ́tʃ ɪz wáj ɪt's ɔ́fən júwzd ɪn kɒ̀mbɪnéjʃən wɪð èjsɪmɛ́trɪk ɛnkrɪ́pʃən ɪn mɒ́dərn səkjʊ́rɪtij prówtəkɔ̀lz."
    },
    {
        "Question": "Which cryptographic method uses two mathematically related keys — one public and one private — allowing users to securely communicate without sharing secret keys in advance?",
        "RightAnswer": "Asymmetric Encryption",
        "WrongAnswers": [
            "Bitwise Encryption",
            "Symmetric Cryptography",
            "Hash Verification",
            "Protocol Tunneling",
            "Sequential Ciphering"
        ],
        "Explanation": "Asymmetric Encryption refers to a cryptographic system that uses pairs of keys: public keys that can be widely shared, and private keys known only to the owner. What makes this system revolutionary is that information encrypted with a public key can only be decrypted with the corresponding private key. This solves the key distribution problem that plagued earlier encryption methods, as users no longer need to securely exchange secret keys before communicating. Asymmetric encryption enables secure communications over insecure channels like the internet and forms the foundation of technologies like HTTPS, digital signatures, and secure email. While typically slower than symmetric encryption, its security advantages make it essential for establishing secure connections, after which faster symmetric methods often take over for bulk data transfer. RSA, ECC, and Diffie-Hellman are popular implementations of asymmetric encryption algorithms.",
        "trans_Question": "wɪ́tʃ krɪptɒ́ɡrəfɪk mɛ́θəd júwsɪz túw mæ̀θəmǽtɪkəlij rəléjtɪd kíjz — wʌ́n pʌ́blɪk ənd wʌ́n prájvət — əláwɪŋ júwzərz tə səkjʊ́rlij kəmjúwnɪkèjt wɪðáwt ʃɛ́ərɪŋ síjkrət kíjz ɪn ədvǽns?",
        "trans_RightAnswer": "èjsɪmɛ́trɪk ɛnkrɪ́pʃən",
        "trans_WrongAnswers": [
            "bɪtwajz ɛnkrɪ́pʃən",
            "sɪmɛ́trɪk krɪptɒ́ɡrəfij",
            "hǽʃ vɛ̀ərɪfɪkéjʃən",
            "prówtəkɒ̀l tʌ́nəlɪŋ",
            "səkwɛ́nʃəl sájfərɪŋ"
        ],
        "trans_Explanation": "èjsɪmɛ́trɪk ɛnkrɪ́pʃən rəfɜ́rz tə ə krɪptɒ́ɡrəfɪk sɪ́stəm ðət júwsɪz pɛ́ərz əv kíjz: pʌ́blɪk kíjz ðət kən bij wájdlij ʃɛ́ərd, ənd prájvət kíjz nówn ównlij tə ðə ównər. wɒt méjks ðɪs sɪ́stəm rɛ̀vəlúwʃənɛ̀ərij ɪz ðət ɪnfərméjʃən ɛnkrɪ́ptɪd wɪð ə pʌ́blɪk kíj kən ównlij bij dəkrɪ́ptɪd wɪð ðə kɔ̀rəspɒ́ndɪŋ prájvət kíj. ðɪs sɒ́lvz ðə kíj dɪ̀strəbjúwʃən prɒ́bləm ðət pléjɡd ɜ́rlijər ɛnkrɪ́pʃən mɛ́θədz, æz júwzərz now lɔ́ŋɡər níjd tə səkjʊ́rlij əkstʃéjndʒ síjkrət kíjz bəfɔ́r kəmjúwnɪkèjtɪŋ. èjsɪmɛ́trɪk ɛnkrɪ́pʃən ɛnéjbəlz səkjʊ́r kəmjùwnɪkéjʃənz ówvər ɪ́nsəkjʊr tʃǽnəlz lájk ðə ɪ́ntərnɛ̀t ənd fɔ́rmz ðə fawndéjʃən əv tɛknɒ́lədʒijz lájk HTTPS, dɪ́dʒɪtəl sɪ́ɡnətʃərz, ənd səkjʊ́r íjmejl. wájl tɪ́pɪkəlij slówər ðʌn sɪmɛ́trɪk ɛnkrɪ́pʃən, ɪts səkjʊ́rɪtij ədvǽntɪdʒɪz méjk ɪt əsɛ́nʃəl fɔr əstǽblɪʃɪŋ səkjʊ́r kənɛ́kʃənz, ǽftər wɪ́tʃ fǽstər sɪmɛ́trɪk mɛ́θədz ɔ́fən téjk ówvər fɔr bʌ́lk déjtə trǽnsfər. RSA, ECC, ənd dɪ́fij-hɛ́lmən ɑr pɒ́pjələr ɪ̀mpləmɛntéjʃənz əv èjsɪmɛ́trɪk ɛnkrɪ́pʃən ǽlɡərɪ̀ðəmz."
    },
    {
        "Question": "What is the data transformation technique used to convert variable-length inputs into fixed-length outputs, often used in data retrieval systems, password storage, and digital signatures?",
        "RightAnswer": "Hashing",
        "WrongAnswers": [
            "Encryption",
            "Normalization",
            "Compression",
            "Serialization",
            "Tokenization"
        ],
        "Explanation": "Hashing is a fundamental technique in computer science that transforms input data of arbitrary size into a fixed-size value called a hash or digest. Unlike encryption, hashing is a one-way function, meaning that it's practically impossible to reverse the process and obtain the original data from the hash value. This unique property makes hashing ideal for password storage, where systems store hash values rather than actual passwords. Hashing is also crucial for data structures like hash tables, which provide incredibly fast data retrieval operations. When you search for an element in a hash table, the hashing function quickly computes where the element is likely stored, avoiding the need to search through the entire dataset. Additionally, hashing plays a vital role in data integrity verification, digital signatures, and blockchain technology, where it helps detect even the smallest changes in data. Different hashing algorithms like MD5, SHA-256, and bcrypt are used depending on the specific requirements for speed, security, and collision resistance in a given application.",
        "trans_Question": "wɒt ɪz ðə déjtə træ̀nsfərméjʃən tɛkníjk júwzd tə kɒ́nvɜrt vɛ́ərijəbəl-lɛ́ŋθ ɪ́npʊ̀ts ɪntə fɪ́kst-lɛ́ŋθ áwtpʊ̀ts, ɔ́fən júwzd ɪn déjtə rətríjvəl sɪ́stəmz, pǽswɜ̀rd stɔ́rɪdʒ, ənd dɪ́dʒɪtəl sɪ́ɡnətʃərz?",
        "trans_RightAnswer": "hǽʃɪŋ",
        "trans_WrongAnswers": [
            "ɛnkrɪ́pʃən",
            "nɔ̀rməlɪzéjʃən",
            "kəmprɛ́ʃən",
            "sɪ̀ərìjəlɪzéjʃən",
            "tòwkənəzéjʃən"
        ],
        "trans_Explanation": "hǽʃɪŋ ɪz ə fʌ̀ndəmɛ́ntəl tɛkníjk ɪn kəmpjúwtər sájəns ðət trænsfɔ́rmz ɪ́npʊ̀t déjtə əv ɑ́rbɪtrɛ̀ərij sájz ɪntə ə fɪ́kst-sájz vǽljuw kɔ́ld ə hǽʃ ɔr dájdʒɛst. ʌ̀nlájk ɛnkrɪ́pʃən, hǽʃɪŋ ɪz ə wʌ́n-wej fʌ́ŋkʃən, míjnɪŋ ðət ɪt's prǽktɪkəlij ɪ̀mpɒ́sɪbəl tə rijvɜ́rs ðə prɒ́sɛs ənd əbtéjn ðə ərɪ́dʒɪnəl déjtə frəm ðə hǽʃ vǽljuw. ðɪs juwnɪ́k prɒ́pərtij méjks hǽʃɪŋ ajdíjəl fɔr pǽswɜ̀rd stɔ́rɪdʒ, wɛ́ər sɪ́stəmz stɔ́r hǽʃ vǽljuwz rǽðər ðʌn ǽktʃəl pǽswɜ̀rdz. hǽʃɪŋ ɪz ɔ́lsow krúwʃəl fɔr déjtə strʌ́ktʃərz lájk hǽʃ téjbəlz, wɪ́tʃ prəvájd ɪnkrɛ́dɪblij fǽst déjtə rətríjvəl ɒ̀pəréjʃənz. wɛ́n juw sɜ́rtʃ fɔr ən ɛ́ləmənt ɪn ə hǽʃ téjbəl, ðə hǽʃɪŋ fʌ́ŋkʃən kwɪ́klij kəmpjúwts wɛ́ər ðə ɛ́ləmənt ɪz lájklij stɔ́rd, əvɔ́jdɪŋ ðə níjd tə sɜ́rtʃ θrúw ðə əntájər déjtəsɛ̀t. ədɪ́ʃənʌ̀lij, hǽʃɪŋ pléjz ə vájtəl rówl ɪn déjtə ɪntɛ́ɡrɪtij vɛ̀ərɪfɪkéjʃən, dɪ́dʒɪtəl sɪ́ɡnətʃərz, ənd blɒ́ktʃéjn tɛknɒ́lədʒij, wɛ́ər ɪt hɛ́lps dətɛ́kt íjvən ðə smɔ́ləst tʃéjndʒɪz ɪn déjtə. dɪ́fərənt hǽʃɪŋ ǽlɡərɪ̀ðəmz lájk MD5, SHA-256, ənd bijkrɪ́pt ɑr júwzd dəpɛ́ndɪŋ ɒn ðə spəsɪ́fɪk rəkwájərmənts fɔr spíjd, səkjʊ́rɪtij, ənd kəlɪ́ʒən rəzɪ́stəns ɪn ə ɡɪ́vən æ̀plɪkéjʃən."
    },
    {
        "Question": "In cybersecurity, what cryptographic technique allows users to verify the authenticity of a digital message or document by providing proof of origin, identity, and status of an electronic document?",
        "RightAnswer": "Digital Signature",
        "WrongAnswers": [
            "Data Encryption",
            "Checksum Verification",
            "Hash Tokenization",
            "Identity Certificate",
            "Authentication Protocol"
        ],
        "Explanation": "A Digital Signature is a mathematical scheme for verifying the authenticity of digital messages or documents. It provides a way to ensure that the message was created by a known sender and was not altered during transmission. Unlike handwritten signatures, digital signatures are nearly impossible to forge when properly implemented. They work using public key cryptography, where the signer uses their private key to create the signature, and anyone can use the corresponding public key to verify it. Digital signatures are widely used in secure email, software distribution, financial transactions, and contract management systems to establish non-repudiation, meaning the signer cannot deny their association with the signed document. This technology has become fundamental to digital trust and security across the internet.",
        "trans_Question": "ɪn sàjbərsəkjʊ́rɪtij, wɒt krɪptɒ́ɡrəfɪk tɛkníjk əláwz júwzərz tə vɛ́ərɪfaj ðə ɔ̀θəntɪ́sɪtij əv ə dɪ́dʒɪtəl mɛ́sɪdʒ ɔr dɒ́kjəmɛnt baj prəvájdɪŋ prúwf əv ɔ́rɪdʒɪn, ajdɛ́ntɪtij, ənd stǽtəs əv ən ələktrɒ́nɪk dɒ́kjəmɛnt?",
        "trans_RightAnswer": "dɪ́dʒɪtəl sɪ́ɡnətʃər",
        "trans_WrongAnswers": [
            "déjtə ɛnkrɪ́pʃən",
            "tʃɛ́ksəm vɛ̀ərɪfɪkéjʃən",
            "hǽʃ tòwkənəzéjʃən",
            "ajdɛ́ntɪtij sərtɪ́fɪkət",
            "ɔθɛ̀ntɪkéjʃən prówtəkɒ̀l"
        ],
        "trans_Explanation": "ə dɪ́dʒɪtəl sɪ́ɡnətʃər ɪz ə mæ̀θəmǽtɪkəl skíjm fɔr vɛ́ərɪfajɪŋ ðə ɔ̀θəntɪ́sɪtij əv dɪ́dʒɪtəl mɛ́sɪdʒɪz ɔr dɒ́kjəmənts. ɪt prəvájdz ə wej tə ənʃʊ́r ðət ðə mɛ́sɪdʒ wɒz krijéjtɪd baj ə nówn sɛ́ndər ənd wɒz nɒt ɔ́ltərd dʊ́rɪŋ trænsmɪ́ʃən. ʌ̀nlájk hǽndrɪ̀tən sɪ́ɡnətʃərz, dɪ́dʒɪtəl sɪ́ɡnətʃərz ɑr nɪ́ərlij ɪ̀mpɒ́sɪbəl tə fɔ́rdʒ wɛ́n prɒ́pərlij ɪ́mpləmɛ̀ntɪd. ðej wɜ́rk júwzɪŋ pʌ́blɪk kíj krɪptɒ́ɡrəfij, wɛ́ər ðə sájnər júwsɪz ðɛər prájvət kíj tə krijéjt ðə sɪ́ɡnətʃər, ənd ɛ́nijwən kən juwz ðə kɔ̀rəspɒ́ndɪŋ pʌ́blɪk kíj tə vɛ́ərɪfaj ɪt. dɪ́dʒɪtəl sɪ́ɡnətʃərz ɑr wájdlij júwzd ɪn səkjʊ́r íjmejl, sɔ́ftwɛ̀ər dɪ̀strəbjúwʃən, fàjnǽnʃəl trænzǽkʃənz, ənd kɒ́ntrækt mǽnədʒmənt sɪ́stəmz tə əstǽblɪʃ nɒn-rəpjùwdijéjʃən, míjnɪŋ ðə sájnər kǽnɒt dənáj ðɛər əsòwsijéjʃən wɪð ðə sájnd dɒ́kjəmɛnt. ðɪs tɛknɒ́lədʒij həz bəkʌ́m fʌ̀ndəmɛ́ntəl tə dɪ́dʒɪtəl trʌ́st ənd səkjʊ́rɪtij əkrɔ́s ðə ɪ́ntərnɛ̀t."
    },
    {
        "Question": "What decentralized technology relies on a distributed ledger that records transactions across multiple computers to ensure security, transparency, and immutability of data?",
        "RightAnswer": "Blockchain",
        "WrongAnswers": [
            "Cloud Computing",
            "Quantum Encryption",
            "Neural Network",
            "Virtual Machine",
            "Edge Computing"
        ],
        "Explanation": "Blockchain is a revolutionary data structure that maintains a continuously growing list of records, called blocks, which are linked using cryptography. Each block contains transaction data, a timestamp, and a reference to the previous block, creating an unalterable chain. What makes blockchain particularly innovative is its decentralized nature—rather than relying on a central authority, the data is distributed across a peer-to-peer network where each participant (or node) maintains a copy of the entire ledger. This design creates a system that is transparent (all transactions are visible to network participants), secure (through advanced cryptographic techniques), and resistant to modification (changing one block would require altering all subsequent blocks and gaining consensus from the network). Originally developed as the underlying technology for Bitcoin, blockchain has expanded far beyond cryptocurrencies and is now being applied to various domains including supply chain management, voting systems, identity verification, and smart contracts—self-executing contracts with agreement terms directly written into code.",
        "trans_Question": "wɒt dəsɛ́ntrəlàjzd tɛknɒ́lədʒij rəlájz ɒn ə dɪstrɪ́bjətɪd lɛ́dʒər ðət rɛ́kərdz trænzǽkʃənz əkrɔ́s mʌ́ltɪpəl kəmpjúwtərz tə ənʃʊ́r səkjʊ́rɪtij, trænspɛ́ərənsij, ənd ɪ̀mjuwtæ̀bɪ́lɪtij əv déjtə?",
        "trans_RightAnswer": "blɒ́ktʃéjn",
        "trans_WrongAnswers": [
            "kláwd kəmpjúwtɪŋ",
            "kwɑ́ntəm ɛnkrɪ́pʃən",
            "nʊ́rəl nɛ́twɜ̀rk",
            "vɜ́rtʃuwəl məʃíjn",
            "ɛ́dʒ kəmpjúwtɪŋ"
        ],
        "trans_Explanation": "blɒ́ktʃéjn ɪz ə rɛ̀vəlúwʃənɛ̀ərij déjtə strʌ́ktʃər ðət mejntéjnz ə kəntɪ́njuwəslij ɡrówɪŋ lɪ́st əv rɛ́kərdz, kɔ́ld blɒ́ks, wɪ́tʃ ɑr lɪ́ŋkt júwzɪŋ krɪptɒ́ɡrəfij. ijtʃ blɒ́k kəntéjnz trænzǽkʃən déjtə, ə tájmstæ̀mp, ənd ə rɛ́fərəns tə ðə príjvijəs blɒ́k, krijéjtɪŋ ən ənɔ́ltərəbəl tʃéjn. wɒt méjks blɒ́ktʃéjn pərtɪ́kjələrlij ɪ́nəvejtɪv ɪz ɪts dəsɛ́ntrəlàjzd néjtʃər—rǽðər ðʌn rəlájɪŋ ɒn ə sɛ́ntrəl əθɔ́rɪtij, ðə déjtə ɪz dɪstrɪ́bjətɪd əkrɔ́s ə pɪ́ər-tə-pɪ́ər nɛ́twɜ̀rk wɛ́ər ijtʃ pɑrtɪ́səpənt (ɔr nówd) mejntéjnz ə kɒ́pij əv ðə əntájər lɛ́dʒər. ðɪs dəzájn krijéjts ə sɪ́stəm ðət ɪz trænspǽrənt (ɔl trænzǽkʃənz ɑr vɪ́zɪbəl tə nɛ́twɜ̀rk pɑrtɪ́səpənts), səkjʊ́r (θrúw ədvǽnst krɪptɒ́ɡrəfɪk tɛkníjks), ənd rəzɪ́stənt tə mɒ̀dɪfɪkéjʃən (tʃéjndʒɪŋ wʌ́n blɒ́k wʊd rəkwájər ɔ́ltərɪŋ ɔl sʌ́bsəkwənt blɒ́ks ənd ɡéjnɪŋ kənsɛ́nsəs frəm ðə nɛ́twɜ̀rk). ərɪ́dʒɪnəlij dəvɛ́ləpt æz ðə ʌ̀ndərlájɪŋ tɛknɒ́lədʒij fɔr bɪ́tkɔ́jn, blɒ́ktʃéjn həz əkspǽndɪd fɑ́r bìjɔ́nd krɪ̀ptowkɜ́rənsijz ənd ɪz náw bíjɪŋ əplájd tə vɛ́ərijəs dowméjnz ɪnklúwdɪŋ səpláj tʃéjn mǽnədʒmənt, vówtɪŋ sɪ́stəmz, ajdɛ́ntɪtij vɛ̀ərɪfɪkéjʃən, ənd smɑ́rt kɒ́ntræ̀kts—sɛ́lf-ɛ́ksəkjùwtɪŋ kɒ́ntræ̀kts wɪð əɡríjmənt tɜ́rmz dɪərɛ́klij rɪ́tən ɪntə kówd."
    },
    {
        "Question": "Which computing discipline is primarily concerned with protecting data from unauthorized access, disclosure, disruption, modification, or destruction?",
        "RightAnswer": "Information Security",
        "WrongAnswers": [
            "Quantum Computing",
            "Machine Learning",
            "Data Visualization",
            "Natural Language Processing",
            "Human-Computer Interaction"
        ],
        "Explanation": "Information Security is the discipline within Computer Science focused on safeguarding digital data and computer systems throughout their lifecycle. It encompasses practices, technologies, and policies designed to prevent unauthorized access, maintain data integrity, ensure confidentiality, and guarantee availability of information systems. Information Security professionals work to protect against threats like malware, hackers, data breaches, and insider threats by implementing strategies such as encryption, access controls, network security measures, and security awareness training. The field has become increasingly important as organizations store more valuable and sensitive data digitally and as cyber threats grow in sophistication. Beyond technical solutions, Information Security also involves risk management, compliance with regulations, incident response planning, and creating a security-conscious organizational culture.",
        "trans_Question": "wɪ́tʃ kəmpjúwtɪŋ dɪ́sɪplɪn ɪz prajmɛ́ərɪlij kənsɜ́rnd wɪð prətɛ́ktɪŋ déjtə frəm ənɔ́θəràjzd ǽksɛ̀s, dɪsklówʒər, dɪsrʌ́pʃən, mɒ̀dɪfɪkéjʃən, ɔr dəstrʌ́kʃən?",
        "trans_RightAnswer": "ɪnfərméjʃən səkjʊ́rɪtij",
        "trans_WrongAnswers": [
            "kwɑ́ntəm kəmpjúwtɪŋ",
            "məʃíjn lɜ́rnɪŋ",
            "déjtə vɪ̀ʒwəlɪzéjʃən",
            "nǽtʃərəl lǽŋɡwədʒ prɒ́sɛsɪŋ",
            "hjúwmən-kəmpjúwtər ɪ̀ntərǽkʃən"
        ],
        "trans_Explanation": "ɪnfərméjʃən səkjʊ́rɪtij ɪz ðə dɪ́sɪplɪn wɪðɪ́n kəmpjúwtər sájəns fówkəst ɒn séjfɡɑ̀rdɪŋ dɪ́dʒɪtəl déjtə ənd kəmpjúwtər sɪ́stəmz θruwáwt ðɛər lájfsàjkəl. ɪt ɛnkʌ́mpəsɪz prǽktɪsɪz, tɛknɒ́lədʒijz, ənd pɒ́lɪsijz dəzájnd tə prəvɛ́nt ənɔ́θəràjzd ǽksɛ̀s, mejntéjn déjtə ɪntɛ́ɡrɪtij, ənʃʊ́r kɒ̀nfɪdɛ́nʃijǽlɪtij, ənd ɡɛ̀ərəntíj əvèjləbɪ́lɪtij əv ɪnfərméjʃən sɪ́stəmz. ɪnfərméjʃən səkjʊ́rɪtij prəfɛ́ʃənəlz wɜ́rk tə prətɛ́kt əɡéjnst θrɛ́ts lájk mǽlwɛ̀ər, hǽkərz, déjtə bríjtʃɪz, ənd ɪnsájdər θrɛ́ts baj ɪ́mpləmɛ̀ntɪŋ strǽtədʒijz sʌtʃ æz ɛnkrɪ́pʃən, ǽksɛ̀s kəntrówlz, nɛ́twɜ̀rk səkjʊ́rɪtij mɛ́ʒərz, ənd səkjʊ́rɪtij əwɛ́ərnəs tréjnɪŋ. ðə fíjld həz bəkʌ́m ɪnkríjsɪŋɡlij ɪmpɔ́rtənt æz ɔ̀rɡənɪzéjʃənz stɔ́r mɔr vǽljəbəl ənd sɛ́nsɪtɪv déjtə dɪ́dʒɪtəlij ənd æz sájbər θrɛ́ts ɡrów ɪn səfɪ̀stɪkéjʃən. bìjɔ́nd tɛ́knɪkəl səlúwʃənz, ɪnfərméjʃən səkjʊ́rɪtij ɔ́lsow ɪnvɒ́lvz rɪ́sk mǽnədʒmənt, kəmplájəns wɪð rɛ̀ɡjəléjʃənz, ɪ́nsɪdənt rəspɒ́ns plǽnɪŋ, ənd krijéjtɪŋ ə səkjʊ́rɪtij-kɒ́nʃəs ɔ̀rɡənɪzéjʃənəl kʌ́ltʃər."
    },
    {
        "Question": "Which field focuses on protecting computer systems, networks, and data from unauthorized access, attacks, and damage, while also ensuring digital information remains confidential, integral, and available?",
        "RightAnswer": "Cybersecurity",
        "WrongAnswers": [
            "Data Mining",
            "Quantum Computing",
            "Cloud Architecture",
            "Natural Language Processing",
            "Virtual Reality"
        ],
        "Explanation": "Cybersecurity is the practice of defending computers, servers, mobile devices, electronic systems, networks, and data from malicious attacks and unauthorized access. It encompasses a wide range of technologies, processes, and practices designed to protect digital assets. Cybersecurity professionals work to prevent data breaches, identity theft, and damage to hardware, software, and information systems. The field has become increasingly important as our world becomes more digitally connected, with threats constantly evolving from simple viruses to sophisticated attacks like ransomware, phishing, and social engineering. Cybersecurity includes multiple layers of protection across computers, programs, and networks, and requires expertise in threat intelligence, security operations, application security, and disaster recovery planning. Beyond technical solutions, it also involves educating users about secure digital behavior, as human error remains one of the greatest vulnerabilities in any security system.",
        "trans_Question": "wɪ́tʃ fíjld fówkəsɪz ɒn prətɛ́ktɪŋ kəmpjúwtər sɪ́stəmz, nɛ́twɜ̀rks, ənd déjtə frəm ənɔ́θəràjzd ǽksɛ̀s, ətǽks, ənd dǽmɪdʒ, wájl ɔ́lsow ɛnʃʊ́rɪŋ dɪ́dʒɪtəl ɪnfərméjʃən rəméjnz kɒ̀nfɪdɛ́nʃəl, ɪ́ntəɡrəl, ənd əvéjləbəl?",
        "trans_RightAnswer": "sàjbərsəkjʊ́rɪtij",
        "trans_WrongAnswers": [
            "déjtə májnɪŋ",
            "kwɑ́ntəm kəmpjúwtɪŋ",
            "kláwd ɑ́rkɪtɛ̀ktʃər",
            "nǽtʃərəl lǽŋɡwədʒ prɒ́sɛsɪŋ",
            "vɜ́rtʃuwəl rìjǽlɪtij"
        ],
        "trans_Explanation": "sàjbərsəkjʊ́rɪtij ɪz ðə prǽktɪs əv dəfɛ́ndɪŋ kəmpjúwtərz, sɜ́rvərz, mówbajl dəvájsɪz, ələktrɒ́nɪk sɪ́stəmz, nɛ́twɜ̀rks, ənd déjtə frəm məlɪ́ʃəs ətǽks ənd ənɔ́θəràjzd ǽksɛ̀s. ɪt ɛnkʌ́mpəsɪz ə wájd réjndʒ əv tɛknɒ́lədʒijz, prɒ́sɛsɪz, ənd prǽktɪsɪz dəzájnd tə prətɛ́kt dɪ́dʒɪtəl ǽsɛts. sàjbərsəkjʊ́rɪtij prəfɛ́ʃənəlz wɜ́rk tə prəvɛ́nt déjtə bríjtʃɪz, ajdɛ́ntɪtij θɛ́ft, ənd dǽmɪdʒ tə hɑ́rdwɛ̀ər, sɔ́ftwɛ̀ər, ənd ɪnfərméjʃən sɪ́stəmz. ðə fíjld həz bəkʌ́m ɪnkríjsɪŋɡlij ɪmpɔ́rtənt æz awər wɜ́rld bəkʌ́mz mɔr dɪ́dʒɪtəlij kənɛ́ktɪd, wɪð θrɛ́ts kɒ́nstəntlij əvɒ́lvɪŋ frəm sɪ́mpəl vájərəsɪz tə səfɪ́stɪkèjtɪd ətǽks lájk rǽnsəmwɛ̀ər, fɪ́ʃɪŋ, ənd sówʃəl ɛ̀ndʒɪnɪ́ərɪŋ. sàjbərsəkjʊ́rɪtij ɪnklúwdz mʌ́ltɪpəl léjərz əv prətɛ́kʃən əkrɔ́s kəmpjúwtərz, prówɡræ̀mz, ənd nɛ́twɜ̀rks, ənd rəkwájərz ɛ̀kspərtíjz ɪn θrɛ́t ɪntɛ́lɪdʒəns, səkjʊ́rɪtij ɒ̀pəréjʃənz, æ̀plɪkéjʃən səkjʊ́rɪtij, ənd dɪzǽstər rəkʌ́vərij plǽnɪŋ. bìjɔ́nd tɛ́knɪkəl səlúwʃənz, ɪt ɔ́lsow ɪnvɒ́lvz ɛ́dʒəkèjtɪŋ júwzərz əbawt səkjʊ́r dɪ́dʒɪtəl bəhéjvjər, æz hjúwmən ɛ́ərər rəméjnz wʌ́n əv ðə ɡréjtəst vʌ̀lnərəbɪ́lɪtijz ɪn ɛ́nij səkjʊ́rɪtij sɪ́stəm."
    },
    {
        "Question": "What is the term for software specifically designed to disrupt, damage, or gain unauthorized access to computer systems?",
        "RightAnswer": "Malware",
        "WrongAnswers": [
            "Shareware",
            "Firmware",
            "Adware",
            "Freeware",
            "Middleware"
        ],
        "Explanation": "Malware, short for 'malicious software,' refers to any program or code intentionally created to cause harm to a computer system, network, or user. This umbrella term encompasses various harmful software types including viruses, worms, trojans, ransomware, spyware, and rootkits. Malware can infiltrate systems through deceptive downloads, email attachments, compromised websites, or network vulnerabilities. Once installed, malware might steal sensitive information, encrypt files for ransom, monitor user activities, or hijack computing resources. Unlike legitimate software that serves constructive purposes, malware operates covertly, often disguising itself as harmless applications or hiding within system processes to avoid detection. Understanding malware and implementing protective measures such as antivirus software, firewalls, and safe browsing practices represent core components of modern cybersecurity.",
        "trans_Question": "wɒt ɪz ðə tɜ́rm fɔr sɔ́ftwɛ̀ər spəsɪ́fɪklij dəzájnd tə dɪsrʌ́pt, dǽmɪdʒ, ɔr ɡéjn ənɔ́θəràjzd ǽksɛ̀s tə kəmpjúwtər sɪ́stəmz?",
        "trans_RightAnswer": "mǽlwɛ̀ər",
        "trans_WrongAnswers": [
            "ʃɛ́ərwɛ̀ər",
            "fɜ́rmwɛ̀ər",
            "ǽdwɛər",
            "fríjwɛ̀ər",
            "mɪ́dəlwɛər"
        ],
        "trans_Explanation": "mǽlwɛ̀ər, ʃɔ́rt fɔr 'məlɪ́ʃəs sɔ́ftwɛ̀ər,' rəfɜ́rz tə ɛ́nij prówɡræ̀m ɔr kówd ɪntɛ́nʃənəlij krijéjtɪd tə kɒ́z hɑ́rm tə ə kəmpjúwtər sɪ́stəm, nɛ́twɜ̀rk, ɔr júwzər. ðɪs ʌ́mbrɛ̀lə tɜ́rm ɛnkʌ́mpəsɪz vɛ́ərijəs hɑ́rmfəl sɔ́ftwɛ̀ər tájps ɪnklúwdɪŋ vájərəsɪz, wɜ́rmz, trówdʒənz, rǽnsəmwɛ̀ər, spájwɛ̀ər, ənd rúwtkɪts. mǽlwɛ̀ər kən ɪ́nfɪltrèjt sɪ́stəmz θrúw dəsɛ́ptɪv dáwnlòwdz, íjmejl ətǽtʃmənts, kɒ́mprəmajzd wɛ́bsàjts, ɔr nɛ́twɜ̀rk vʌ̀lnərəbɪ́lɪtijz. wʌ́ns ɪnstɔ́ld, mǽlwɛ̀ər majt stíjl sɛ́nsɪtɪv ɪnfərméjʃən, ɛnkrɪ́pt fájlz fɔr rǽnsəm, mɒ́nɪtər júwzər æktɪ́vɪtijz, ɔr hájdʒæ̀k kəmpjúwtɪŋ ríjsɔrsɪz. ʌ̀nlájk lədʒɪ́tɪmət sɔ́ftwɛ̀ər ðət sɜ́rvz kənstrʌ́ktɪv pɜ́rpəsɪz, mǽlwɛ̀ər ɒ́pərèjts kowvɜ́rtlij, ɔ́fən dɪsɡájzɪŋ ɪtsɛ́lf æz hɑ́rmləs æ̀plɪkéjʃənz ɔr hájdɪŋ wɪðɪ́n sɪ́stəm prɒ́sɛsɪz tə əvɔ́jd dətɛ́kʃən. ʌ̀ndərstǽndɪŋ mǽlwɛ̀ər ənd ɪ́mpləmɛ̀ntɪŋ prətɛ́ktɪv mɛ́ʒərz sʌtʃ æz æ̀ntijvájərəs sɔ́ftwɛ̀ər, fájərwɔlz, ənd séjf bráwzɪŋ prǽktɪsɪz rɛ̀prəzɛ́nt kɔ́r kəmpównənts əv mɒ́dərn sàjbərsəkjʊ́rɪtij."
    },
    {
        "Question": "What term describes a malicious software program that, like its biological namesake, can replicate itself and spread from one computer to another without user consent?",
        "RightAnswer": "Virus",
        "WrongAnswers": [
            "Firewall",
            "Cookie",
            "Algorithm",
            "Cache",
            "Compiler"
        ],
        "Explanation": "A computer virus is a type of malicious software that, when executed, replicates itself by modifying other computer programs and inserting its own code. When this replication succeeds, the affected areas are then said to be 'infected' with a virus. Viruses can range in severity from causing mildly annoying effects to damaging data or software and causing denial-of-service conditions. Unlike a biological virus, computer viruses do not spontaneously emerge in digital environments but are deliberately created by programmers with intent to cause disruption, gain unauthorized access to systems, or steal sensitive information. Viruses typically require some form of human action to spread, such as opening an infected email attachment or downloading a compromised file. Modern antivirus software works to detect, quarantine, and remove these harmful programs before they can cause damage.",
        "trans_Question": "wɒt tɜ́rm dəskrájbz ə məlɪ́ʃəs sɔ́ftwɛ̀ər prówɡræ̀m ðət, lájk ɪts bàjəlɒ́dʒɪkəl néjmsèjk, kən rɛ́plɪkèjt ɪtsɛ́lf ənd sprɛ́d frəm wʌ́n kəmpjúwtər tə ənʌ́ðər wɪðáwt júwzər kənsɛ́nt?",
        "trans_RightAnswer": "vájərəs",
        "trans_WrongAnswers": [
            "fájərwɒl",
            "kʊ́kij",
            "ǽlɡərɪ̀ðəm",
            "kǽʃ",
            "kəmpájlər"
        ],
        "trans_Explanation": "ə kəmpjúwtər vájərəs ɪz ə tájp əv məlɪ́ʃəs sɔ́ftwɛ̀ər ðət, wɛ́n ɛ́ksəkjùwtɪd, rɛ́plɪkèjts ɪtsɛ́lf baj mɒ́dɪfàjɪŋ ʌ́ðər kəmpjúwtər prówɡræ̀mz ənd ɪnsɜ́rtɪŋ ɪts ówn kówd. wɛ́n ðɪs rɛ̀plɪkéjʃən səksíjdz, ðə əfɛ́ktɪd ɛ́ərijəz ɑr ðɛn sɛ́d tə bij 'ɪnfɛ́ktɪd' wɪð ə vájərəs. vájərəsɪz kən réjndʒ ɪn səvɛ́ərɪtij frəm kɒ́zɪŋ májldlij ənɔ́jɪŋ əfɛ́kts tə dǽmɪdʒɪŋ déjtə ɔr sɔ́ftwɛ̀ər ənd kɒ́zɪŋ dənájəl-əv-sɜ́rvɪs kəndɪ́ʃənz. ʌ̀nlájk ə bàjəlɒ́dʒɪkəl vájərəs, kəmpjúwtər vájərəsɪz dúw nɒt spɒntéjnijəslij əmɜ́rdʒ ɪn dɪ́dʒɪtəl ənvájərənmənts bʌt ɑr dəlɪ́bərətlij krijéjtɪd baj prówɡræ̀mərz wɪð ɪntɛ́nt tə kɒ́z dɪsrʌ́pʃən, ɡéjn ənɔ́θəràjzd ǽksɛ̀s tə sɪ́stəmz, ɔr stíjl sɛ́nsɪtɪv ɪnfərméjʃən. vájərəsɪz tɪ́pɪkəlij rəkwájər sʌm fɔ́rm əv hjúwmən ǽkʃən tə sprɛ́d, sʌtʃ æz ówpənɪŋ ən ɪnfɛ́ktɪd íjmejl ətǽtʃmənt ɔr dáwnlòwdɪŋ ə kɒ́mprəmajzd fájl. mɒ́dərn æ̀ntijvájərəs sɔ́ftwɛ̀ər wɜ́rks tə dətɛ́kt, kwɔ́rəntìjn, ənd rijmúwv ðijz hɑ́rmfəl prówɡræ̀mz bəfɔ́r ðej kən kɒ́z dǽmɪdʒ."
    },
    {
        "Question": "What term describes malicious software that appears legitimate or useful but conceals harmful functionality, often tricking users into installation through social engineering?",
        "RightAnswer": "Trojan",
        "WrongAnswers": [
            "Worm",
            "Rootkit",
            "Spyware",
            "Ransomware",
            "Adware"
        ],
        "Explanation": "A Trojan in computer science is malicious software that disguises itself as legitimate or desirable, much like the mythological Trojan Horse. Unlike viruses, Trojans do not self-replicate but rely on social engineering to trick users into installing them. Once activated, Trojans can perform various harmful actions: stealing sensitive information, creating backdoors for attackers, corrupting files, or monitoring user activity. They often appear as useful applications, email attachments, or downloads from questionable websites. What makes Trojans particularly dangerous is their deceptive nature—users typically install them voluntarily, believing they are benign. Common examples include fake antivirus programs, keyloggers disguised as games, or malicious attachments appearing to be important documents. Protection against Trojans involves caution when downloading files, using reputable security software, and keeping systems updated with security patches.",
        "trans_Question": "wɒt tɜ́rm dəskrájbz məlɪ́ʃəs sɔ́ftwɛ̀ər ðət əpɪ́ərz lədʒɪ́tɪmət ɔr júwsfəl bʌt kənsíjlz hɑ́rmfəl fʌ̀ŋkʃənǽlɪtij, ɔ́fən trɪ́kɪŋ júwzərz ɪntə ɪnstəléjʃən θrúw sówʃəl ɛ̀ndʒɪnɪ́ərɪŋ?",
        "trans_RightAnswer": "trówdʒən",
        "trans_WrongAnswers": [
            "wɜ́rm",
            "rúwtkɪ̀t",
            "spájwɛ̀ər",
            "rǽnsəmwɛ̀ər",
            "ǽdwɛər"
        ],
        "trans_Explanation": "ə trówdʒən ɪn kəmpjúwtər sájəns ɪz məlɪ́ʃəs sɔ́ftwɛ̀ər ðət dɪsɡájzɪz ɪtsɛ́lf æz lədʒɪ́tɪmət ɔr dəzájərəbəl, mʌtʃ lájk ðə mɪ̀θəlɒ́dʒɪkəl trówdʒən hɔ́rs. ʌ̀nlájk vájərəsɪz, trówdʒənz dúw nɒt sɛ́lf-rɛ́plɪkèjt bʌt rəláj ɒn sówʃəl ɛ̀ndʒɪnɪ́ərɪŋ tə trɪ́k júwzərz ɪntə ɪnstɔ́lɪŋ ðɛm. wʌ́ns ǽktɪvèjtɪd, trówdʒənz kən pərfɔ́rm vɛ́ərijəs hɑ́rmfəl ǽkʃənz: stíjlɪŋ sɛ́nsɪtɪv ɪnfərméjʃən, krijéjtɪŋ bǽkdɔ̀rz fɔr ətǽkərz, kərʌ́ptɪŋ fájlz, ɔr mɒ́nɪtərɪŋ júwzər æktɪ́vɪtij. ðej ɔ́fən əpɪ́ər æz júwsfəl æ̀plɪkéjʃənz, íjmejl ətǽtʃmənts, ɔr dáwnlòwdz frəm kwɛ́stʃənəbəl wɛ́bsàjts. wɒt méjks trówdʒənz pərtɪ́kjələrlij déjndʒərəs ɪz ðɛər dəsɛ́ptɪv néjtʃər—júwzərz tɪ́pɪkəlij ɪnstɔ́l ðɛm vɒ̀ləntɛ́ərɪlij, bəlíjvɪŋ ðej ɑr bənájn. kɒ́mən əɡzǽmpəlz ɪnklúwd féjk æ̀ntijvájərəs prówɡræ̀mz, kíjlɔ̀ɡərz dɪsɡájzd æz ɡéjmz, ɔr məlɪ́ʃəs ətǽtʃmənts əpɪ́ərɪŋ tə bij ɪmpɔ́rtənt dɒ́kjəmənts. prətɛ́kʃən əɡéjnst trówdʒənz ɪnvɒ́lvz kɒ́ʃən wɛ́n dáwnlòwdɪŋ fájlz, júwzɪŋ rɛ́pjətəbəl səkjʊ́rɪtij sɔ́ftwɛ̀ər, ənd kíjpɪŋ sɪ́stəmz ʌ́pdèjtɪd wɪð səkjʊ́rɪtij pǽtʃɪz."
    },
    {
        "Question": "What is the name of the security system that monitors and controls incoming and outgoing network traffic based on predetermined security rules, acting as a barrier between a trusted network and untrusted networks?",
        "RightAnswer": "Firewall",
        "WrongAnswers": [
            "Antivirus",
            "Encryption",
            "Router",
            "Gateway",
            "VPN"
        ],
        "Explanation": "A firewall is a crucial network security device that monitors and filters incoming and outgoing network traffic according to an organization's previously established security policies. It essentially establishes a barrier between a trusted internal network and untrusted external networks, such as the internet. Firewalls can be hardware devices, software programs, or a combination of both. They use various techniques to identify and block suspicious network activity, including packet filtering, stateful inspection, and application-level gateways. While traditional firewalls primarily focused on filtering traffic based on IP addresses and ports, modern next-generation firewalls incorporate more advanced features like deep packet inspection, intrusion prevention systems, and application awareness. Firewalls are one of the fundamental components of network security architecture and have been protecting networks since the early days of the internet.",
        "trans_Question": "wɒt ɪz ðə néjm əv ðə səkjʊ́rɪtij sɪ́stəm ðət mɒ́nɪtərz ənd kəntrówlz ɪ́nkʌ̀mɪŋ ənd áwtɡòwɪŋ nɛ́twɜ̀rk trǽfɪk béjst ɒn prìjdətɜ́rmɪnd səkjʊ́rɪtij rúwlz, ǽktɪŋ æz ə bǽrijər bijtwíjn ə trʌ́stɪd nɛ́twɜ̀rk ənd ʌ̀ntrʌ́stɪd nɛ́twɜ̀rks?",
        "trans_RightAnswer": "fájərwɒl",
        "trans_WrongAnswers": [
            "æ̀ntijvájərəs",
            "ɛnkrɪ́pʃən",
            "ráwtər",
            "ɡéjtwèj",
            "VPN"
        ],
        "trans_Explanation": "ə fájərwɒl ɪz ə krúwʃəl nɛ́twɜ̀rk səkjʊ́rɪtij dəvájs ðət mɒ́nɪtərz ənd fɪ́ltərz ɪ́nkʌ̀mɪŋ ənd áwtɡòwɪŋ nɛ́twɜ̀rk trǽfɪk əkɔ́rdɪŋ tə ən ɔ̀rɡənɪzéjʃən'z príjvijəslij əstǽblɪʃt səkjʊ́rɪtij pɒ́lɪsijz. ɪt əsɛ́nʃəlij əstǽblɪʃɪz ə bǽrijər bijtwíjn ə trʌ́stɪd ɪ̀ntɜ́rnəl nɛ́twɜ̀rk ənd ʌ̀ntrʌ́stɪd əkstɜ́rnəl nɛ́twɜ̀rks, sʌtʃ æz ðə ɪ́ntərnɛ̀t. fájərwɔlz kən bij hɑ́rdwɛ̀ər dəvájsɪz, sɔ́ftwɛ̀ər prówɡræ̀mz, ɔr ə kɒ̀mbɪnéjʃən əv bówθ. ðej juwz vɛ́ərijəs tɛkníjks tə ajdɛ́ntɪfàj ənd blɒ́k səspɪ́ʃəs nɛ́twɜ̀rk æktɪ́vɪtij, ɪnklúwdɪŋ pǽkət fɪ́ltərɪŋ, stéjtfəl ɪnspɛ́kʃən, ənd æ̀plɪkéjʃən-lɛ́vəl ɡéjtwèjz. wájl trədɪ́ʃənəl fájərwɔlz prajmɛ́ərɪlij fówkəst ɒn fɪ́ltərɪŋ trǽfɪk béjst ɒn IP ǽdrɛ́sɪz ənd pɔ́rts, mɒ́dərn nɛ́kst-dʒɛ̀nəréjʃən fájərwɔlz ɪnkɔ́rpərejt mɔr ədvǽnst fíjtʃərz lájk díjp pǽkət ɪnspɛ́kʃən, ɪntrúwʒən prəvɛ́nʃən sɪ́stəmz, ənd æ̀plɪkéjʃən əwɛ́ərnəs. fájərwɔlz ɑr wʌ́n əv ðə fʌ̀ndəmɛ́ntəl kəmpównənts əv nɛ́twɜ̀rk səkjʊ́rɪtij ɑ́rkɪtɛ̀ktʃər ənd həv bɪn prətɛ́ktɪŋ nɛ́twɜ̀rks sɪns ðə ɜ́rlij déjz əv ðə ɪ́ntərnɛ̀t."
    },
    {
        "Question": "Which cybersecurity technique involves continuous monitoring of network traffic and system activities to identify potential unauthorized access attempts or malicious activities?",
        "RightAnswer": "Intrusion Detection",
        "WrongAnswers": [
            "Penetration Testing",
            "Data Encryption",
            "Identity Verification",
            "Patch Management",
            "Security Auditing"
        ],
        "Explanation": "Intrusion Detection is a proactive security process designed to identify unauthorized or malicious activities within computer systems or networks. It functions like a security surveillance system for digital environments, constantly monitoring data traffic, user behaviors, and system operations for suspicious patterns. These systems can be network-based, examining traffic flow between devices, or host-based, focusing on activities within individual systems. Intrusion Detection Systems (IDS) use various approaches including signature-based detection, which compares activities against known attack patterns, and anomaly-based detection, which identifies deviations from normal behavior. Upon detecting potential threats, these systems alert security personnel, enabling prompt investigation and response. Unlike firewalls that simply block unauthorized access, intrusion detection systems actively search for evidence of attempted breaches or successful compromises, forming a critical layer in comprehensive cybersecurity strategies.",
        "trans_Question": "wɪ́tʃ sàjbərsəkjʊ́rɪtij tɛkníjk ɪnvɒ́lvz kəntɪ́njuwəs mɒ́nɪtərɪŋ əv nɛ́twɜ̀rk trǽfɪk ənd sɪ́stəm æktɪ́vɪtijz tə ajdɛ́ntɪfàj pətɛ́nʃəl ənɔ́θəràjzd ǽksɛ̀s ətɛ́mpts ɔr məlɪ́ʃəs æktɪ́vɪtijz?",
        "trans_RightAnswer": "ɪntrúwʒən dətɛ́kʃən",
        "trans_WrongAnswers": [
            "pɛ̀nətréjʃən tɛ́stɪŋ",
            "déjtə ɛnkrɪ́pʃən",
            "ajdɛ́ntɪtij vɛ̀ərɪfɪkéjʃən",
            "pǽtʃ mǽnədʒmənt",
            "səkjʊ́rɪtij ɒ́dɪtɪŋ"
        ],
        "trans_Explanation": "ɪntrúwʒən dətɛ́kʃən ɪz ə pròwǽktɪv səkjʊ́rɪtij prɒ́sɛs dəzájnd tə ajdɛ́ntɪfàj ənɔ́θəràjzd ɔr məlɪ́ʃəs æktɪ́vɪtijz wɪðɪ́n kəmpjúwtər sɪ́stəmz ɔr nɛ́twɜ̀rks. ɪt fʌ́ŋkʃənz lájk ə səkjʊ́rɪtij sərvéjləns sɪ́stəm fɔr dɪ́dʒɪtəl ənvájərənmənts, kɒ́nstəntlij mɒ́nɪtərɪŋ déjtə trǽfɪk, júwzər bəhéjvjərz, ənd sɪ́stəm ɒ̀pəréjʃənz fɔr səspɪ́ʃəs pǽtərnz. ðijz sɪ́stəmz kən bij nɛ́twɜ̀rk-béjst, əɡzǽmɪnɪŋ trǽfɪk flów bijtwíjn dəvájsɪz, ɔr hówst-béjst, fówkəsɪŋ ɒn æktɪ́vɪtijz wɪðɪ́n ɪndɪvɪ́dʒəwəl sɪ́stəmz. ɪntrúwʒən dətɛ́kʃən sɪ́stəmz (IDS) juwz vɛ́ərijəs əprówtʃɪz ɪnklúwdɪŋ sɪ́ɡnətʃər-béjst dətɛ́kʃən, wɪ́tʃ kəmpɛ́ərz æktɪ́vɪtijz əɡéjnst nówn ətǽk pǽtərnz, ənd ənɒ́məlij-béjst dətɛ́kʃən, wɪ́tʃ ajdɛ́ntɪfàjz dìjvijéjʃənz frəm nɔ́rməl bəhéjvjər. əpɒ́n dətɛ́ktɪŋ pətɛ́nʃəl θrɛ́ts, ðijz sɪ́stəmz əlɜ́rt səkjʊ́rɪtij pɜ̀rsənɛ́l, ɛnéjbəlɪŋ prɒ́mpt ɪnvɛ̀stɪɡéjʃən ənd rəspɒ́ns. ʌ̀nlájk fájərwɔlz ðət sɪ́mplij blɒ́k ənɔ́θəràjzd ǽksɛ̀s, ɪntrúwʒən dətɛ́kʃən sɪ́stəmz ǽktɪvlij sɜ́rtʃ fɔr ɛ́vɪdəns əv ətɛ́mptɪd bríjtʃɪz ɔr səksɛ́sfəl kɒ́mprəmajzɪz, fɔ́rmɪŋ ə krɪ́tɪkəl léjər ɪn kɒ̀mprəhɛ́nsɪv sàjbərsəkjʊ́rɪtij strǽtədʒijz."
    },
    {
        "Question": "What is the security process that validates a user's identity before granting system access, typically involving credentials like passwords or biometrics?",
        "RightAnswer": "Authentication",
        "WrongAnswers": [
            "Authorization",
            "Encryption",
            "Validation",
            "Verification",
            "Credentialing"
        ],
        "Explanation": "Authentication is the fundamental security process that confirms users are who they claim to be before allowing access to a system or resources. Think of it as the digital equivalent of checking someone's ID at a secure facility. When you log in to your email account or banking app, authentication occurs through various methods: something you know (passwords, PINs), something you have (security tokens, mobile devices), or something you are (fingerprints, facial recognition). This process establishes trust in the digital world by preventing unauthorized access and protecting sensitive information. Authentication differs from authorization, which determines what an authenticated user is permitted to do once their identity is confirmed. Modern authentication systems often employ multi-factor approaches, requiring several forms of proof to enhance security beyond just passwords alone.",
        "trans_Question": "wɒt ɪz ðə səkjʊ́rɪtij prɒ́sɛs ðət vǽlɪdèjts ə júwzər'z ajdɛ́ntɪtij bəfɔ́r ɡrǽntɪŋ sɪ́stəm ǽksɛ̀s, tɪ́pɪkəlij ɪnvɒ́lvɪŋ krədɛ́nʃəlz lájk pǽswɜ̀rdz ɔr bàjowmɛ́trɪks?",
        "trans_RightAnswer": "ɔθɛ̀ntɪkéjʃən",
        "trans_WrongAnswers": [
            "ɔ̀θərɪzéjʃən",
            "ɛnkrɪ́pʃən",
            "væ̀lɪdéjʃən",
            "vɛ̀ərɪfɪkéjʃən",
            "krədɛ́nʃəlɪŋ"
        ],
        "trans_Explanation": "ɔθɛ̀ntɪkéjʃən ɪz ðə fʌ̀ndəmɛ́ntəl səkjʊ́rɪtij prɒ́sɛs ðət kənfɜ́rmz júwzərz ɑr huw ðej kléjm tə bij bəfɔ́r əláwɪŋ ǽksɛ̀s tə ə sɪ́stəm ɔr ríjsɔrsɪz. θɪ́ŋk əv ɪt æz ðə dɪ́dʒɪtəl əkwɪ́vələnt əv tʃɛ́kɪŋ sʌ́mwʌ̀n'z ID æt ə səkjʊ́r fəsɪ́lɪtij. wɛ́n juw lɔ́ɡ ɪn tə jɔr íjmejl əkáwnt ɔr bǽŋkɪŋ ǽp, ɔθɛ̀ntɪkéjʃən əkɜ́rz θrúw vɛ́ərijəs mɛ́θədz: sʌ́mθɪŋ juw nów (pǽswɜ̀rdz, pɪ́nz), sʌ́mθɪŋ juw həv (səkjʊ́rɪtij tówkənz, mówbajl dəvájsɪz), ɔr sʌ́mθɪŋ juw ɑr (fɪ́ŋɡərprɪ̀nts, féjʃəl rɛ̀kəɡnɪ́ʃən). ðɪs prɒ́sɛs əstǽblɪʃɪz trʌ́st ɪn ðə dɪ́dʒɪtəl wɜ́rld baj prəvɛ́ntɪŋ ənɔ́θəràjzd ǽksɛ̀s ənd prətɛ́ktɪŋ sɛ́nsɪtɪv ɪnfərméjʃən. ɔθɛ̀ntɪkéjʃən dɪ́fərz frəm ɔ̀θərɪzéjʃən, wɪ́tʃ dətɜ́rmɪnz wɒt ən ɔθɛ́ntɪkèjtɪd júwzər ɪz pərmɪ́tɪd tə dúw wʌ́ns ðɛər ajdɛ́ntɪtij ɪz kənfɜ́rmd. mɒ́dərn ɔθɛ̀ntɪkéjʃən sɪ́stəmz ɔ́fən ɛmplɔ́j mʌ́ltij-fǽktər əprówtʃɪz, rijkwájərɪŋ sɛ́vərəl fɔ́rmz əv prúwf tə ənhǽns səkjʊ́rɪtij bìjɔ́nd dʒəst pǽswɜ̀rdz əlówn."
    },
    {
        "Question": "In a computer system, the process of determining what resources a user can access and what actions they can perform after their identity has been verified is known as what?",
        "RightAnswer": "Authorization",
        "WrongAnswers": [
            "Authentication",
            "Allocation",
            "Auditing",
            "Access Control List",
            "Attestation"
        ],
        "Explanation": "Authorization is the security mechanism that determines what permissions an authenticated user has within a system. While authentication confirms who a user is, authorization decides what they are allowed to do. It involves checking if the user has the necessary privileges to access specific resources, perform certain operations, or execute particular functions. Authorization systems typically use policies, roles, or permission sets to manage these rights. For example, an employee might be authorized to view documents in a shared folder but not edit them, while a manager might have both viewing and editing privileges. Authorization ensures that users can only access the information and functions appropriate to their role, helping to maintain security and data integrity across computer systems.",
        "trans_Question": "ɪn ə kəmpjúwtər sɪ́stəm, ðə prɒ́sɛs əv dətɜ́rmɪnɪŋ wɒt ríjsɔrsɪz ə júwzər kən ǽksɛ̀s ənd wɒt ǽkʃənz ðej kən pərfɔ́rm ǽftər ðɛər ajdɛ́ntɪtij həz bɪn vɛ́ərɪfajd ɪz nówn æz wɒt?",
        "trans_RightAnswer": "ɔ̀θərɪzéjʃən",
        "trans_WrongAnswers": [
            "ɔθɛ̀ntɪkéjʃən",
            "æ̀ləkéjʃən",
            "ɒ́dɪtɪŋ",
            "ǽksɛ̀s kəntrówl lɪ́st",
            "ətɛ́stejʃən"
        ],
        "trans_Explanation": "ɔ̀θərɪzéjʃən ɪz ðə səkjʊ́rɪtij mɛ́kənɪzəm ðət dətɜ́rmɪnz wɒt pərmɪ́ʃənz ən ɔθɛ́ntɪkèjtɪd júwzər həz wɪðɪ́n ə sɪ́stəm. wájl ɔθɛ̀ntɪkéjʃən kənfɜ́rmz huw ə júwzər ɪz, ɔ̀θərɪzéjʃən dəsájdz wɒt ðej ɑr əláwd tə dúw. ɪt ɪnvɒ́lvz tʃɛ́kɪŋ ɪf ðə júwzər həz ðə nɛ́səsɛ̀ərij prɪ́vɪlədʒɪz tə ǽksɛ̀s spəsɪ́fɪk ríjsɔrsɪz, pərfɔ́rm sɜ́rtən ɒ̀pəréjʃənz, ɔr ɛ́ksəkjùwt pərtɪ́kjələr fʌ́ŋkʃənz. ɔ̀θərɪzéjʃən sɪ́stəmz tɪ́pɪkəlij juwz pɒ́lɪsijz, rówlz, ɔr pərmɪ́ʃən sɛ́ts tə mǽnɪdʒ ðijz rájts. fɔr əɡzǽmpəl, ən ɛmplɔ́jij majt bij ɔ́θəràjzd tə vjúw dɒ́kjəmənts ɪn ə ʃɛ́ərd fówldər bʌt nɒt ɛ́dɪt ðɛm, wájl ə mǽnədʒər majt həv bówθ vjúwɪŋ ənd ɛ́dɪtɪŋ prɪ́vɪlədʒɪz. ɔ̀θərɪzéjʃən ənʃʊ́rz ðət júwzərz kən ównlij ǽksɛ̀s ðə ɪnfərméjʃən ənd fʌ́ŋkʃənz əprówprijèjt tə ðɛər rówl, hɛ́lpɪŋ tə mejntéjn səkjʊ́rɪtij ənd déjtə ɪntɛ́ɡrɪtij əkrɔ́s kəmpjúwtər sɪ́stəmz."
    },
    {
        "Question": "What discipline focuses on protecting computer networks from unauthorized access, misuse, or attacks, often involving firewalls, encryption, and intrusion detection systems?",
        "RightAnswer": "Network Security",
        "WrongAnswers": [
            "Cloud Computing",
            "Database Administration",
            "Software Engineering",
            "Machine Learning",
            "User Interface Design"
        ],
        "Explanation": "Network Security is the specialized field within Computer Science that deals with protecting the integrity, confidentiality, and accessibility of computer networks and data. It encompasses the policies, practices, and technologies designed to prevent, detect, and respond to unauthorized access, misuse, modification, or denial of network resources. Network Security professionals implement various protective measures such as firewalls that filter traffic, encryption that scrambles sensitive data, authentication systems that verify user identities, intrusion detection systems that monitor for suspicious activities, and security protocols that establish secure communication channels. As cyber threats continue to evolve in sophistication and frequency, Network Security has become increasingly crucial for organizations of all sizes to safeguard their digital assets, maintain operational continuity, and protect sensitive information from malicious actors. This field requires continuous learning and adaptation as new vulnerabilities and attack vectors emerge in our increasingly interconnected digital world.",
        "trans_Question": "wɒt dɪ́sɪplɪn fówkəsɪz ɒn prətɛ́ktɪŋ kəmpjúwtər nɛ́twɜ̀rks frəm ənɔ́θəràjzd ǽksɛ̀s, mɪsjúws, ɔr ətǽks, ɔ́fən ɪnvɒ́lvɪŋ fájərwɔlz, ɛnkrɪ́pʃən, ənd ɪntrúwʒən dətɛ́kʃən sɪ́stəmz?",
        "trans_RightAnswer": "nɛ́twɜ̀rk səkjʊ́rɪtij",
        "trans_WrongAnswers": [
            "kláwd kəmpjúwtɪŋ",
            "déjtəbèjs ædmɪ̀nɪstréjʃən",
            "sɔ́ftwɛ̀ər ɛ̀ndʒɪnɪ́ərɪŋ",
            "məʃíjn lɜ́rnɪŋ",
            "júwzər ɪ́ntərfèjs dəzájn"
        ],
        "trans_Explanation": "nɛ́twɜ̀rk səkjʊ́rɪtij ɪz ðə spɛ́ʃəlàjzd fíjld wɪðɪ́n kəmpjúwtər sájəns ðət díjlz wɪð prətɛ́ktɪŋ ðə ɪntɛ́ɡrɪtij, kɒ̀nfɪdɛ́nʃijǽlɪtij, ənd æ̀ksɛsɪbɪ́lɪtij əv kəmpjúwtər nɛ́twɜ̀rks ənd déjtə. ɪt ɛnkʌ́mpəsɪz ðə pɒ́lɪsijz, prǽktɪsɪz, ənd tɛknɒ́lədʒijz dəzájnd tə prəvɛ́nt, dətɛ́kt, ənd rəspɒ́nd tə ənɔ́θəràjzd ǽksɛ̀s, mɪsjúws, mɒ̀dɪfɪkéjʃən, ɔr dənájəl əv nɛ́twɜ̀rk ríjsɔrsɪz. nɛ́twɜ̀rk səkjʊ́rɪtij prəfɛ́ʃənəlz ɪ́mpləmənt vɛ́ərijəs prətɛ́ktɪv mɛ́ʒərz sʌtʃ æz fájərwɔlz ðət fɪ́ltər trǽfɪk, ɛnkrɪ́pʃən ðət skrǽmbəlz sɛ́nsɪtɪv déjtə, ɔθɛ̀ntɪkéjʃən sɪ́stəmz ðət vɛ́ərɪfaj júwzər ajdɛ́ntɪtijz, ɪntrúwʒən dətɛ́kʃən sɪ́stəmz ðət mɒ́nɪtər fɔr səspɪ́ʃəs æktɪ́vɪtijz, ənd səkjʊ́rɪtij prówtəkɔ̀lz ðət əstǽblɪʃ səkjʊ́r kəmjùwnɪkéjʃən tʃǽnəlz. æz sájbər θrɛ́ts kəntɪ́njuw tə əvɒ́lv ɪn səfɪ̀stɪkéjʃən ənd fríjkwənsij, nɛ́twɜ̀rk səkjʊ́rɪtij həz bəkʌ́m ɪnkríjsɪŋɡlij krúwʃəl fɔr ɔ̀rɡənɪzéjʃənz əv ɔl sájzɪz tə séjfɡɑ̀rd ðɛər dɪ́dʒɪtəl ǽsɛts, mejntéjn ɒ̀pəréjʃənəl kɒ̀ntɪnúwɪtij, ənd prətɛ́kt sɛ́nsɪtɪv ɪnfərméjʃən frəm məlɪ́ʃəs ǽktərz. ðɪs fíjld rəkwájərz kəntɪ́njuwəs lɜ́rnɪŋ ənd æ̀dəptéjʃən æz núw vʌ̀lnərəbɪ́lɪtijz ənd ətǽk vɛ́ktərz əmɜ́rdʒ ɪn awər ɪnkríjsɪŋɡlij ɪ̀ntərkənɛ́ktɪd dɪ́dʒɪtəl wɜ́rld."
    },
    {
        "Question": "What is the process of converting plaintext data into an unreadable format to protect it from unauthorized access, especially when transmitted or stored digitally?",
        "RightAnswer": "Encryption",
        "WrongAnswers": [
            "Compression",
            "Serialization",
            "Hashing",
            "Authentication",
            "Normalization"
        ],
        "Explanation": "Encryption is a fundamental security technique in computer science that transforms readable information into a scrambled format that appears random and meaningless without the proper decryption key. It works by applying mathematical algorithms to convert original data into ciphertext, which can only be decoded back to its original form by authorized parties possessing the correct decryption key. This process ensures confidentiality of sensitive information such as passwords, financial data, and personal communications as they travel across networks or rest in storage. Modern encryption systems like AES, RSA, and TLS form the backbone of secure communications on the internet, protecting everything from online banking transactions to private messages. Unlike related concepts such as hashing (which is one-way) or compression (which reduces data size), encryption is specifically designed to be reversible while maintaining strong security properties.",
        "trans_Question": "wɒt ɪz ðə prɒ́sɛs əv kənvɜ́rtɪŋ pléjntɛ̀kst déjtə ɪntə ən ʌ́nríjdəbəl fɔ́rmæ̀t tə prətɛ́kt ɪt frəm ənɔ́θəràjzd ǽksɛ̀s, əspɛ́ʃəlij wɛ́n trænsmɪ́tɪd ɔr stɔ́rd dɪ́dʒɪtəlij?",
        "trans_RightAnswer": "ɛnkrɪ́pʃən",
        "trans_WrongAnswers": [
            "kəmprɛ́ʃən",
            "sɪ̀ərìjəlɪzéjʃən",
            "hǽʃɪŋ",
            "ɔθɛ̀ntɪkéjʃən",
            "nɔ̀rməlɪzéjʃən"
        ],
        "trans_Explanation": "ɛnkrɪ́pʃən ɪz ə fʌ̀ndəmɛ́ntəl səkjʊ́rɪtij tɛkníjk ɪn kəmpjúwtər sájəns ðət trænsfɔ́rmz ríjdəbəl ɪnfərméjʃən ɪntə ə skrǽmbəld fɔ́rmæ̀t ðət əpɪ́ərz rǽndəm ənd míjnɪŋləs wɪðáwt ðə prɒ́pər dəkrɪ́pʃən kíj. ɪt wɜ́rks baj əplájɪŋ mæ̀θəmǽtɪkəl ǽlɡərɪ̀ðəmz tə kɒ́nvɜrt ərɪ́dʒɪnəl déjtə ɪntə sájfərtɛkst, wɪ́tʃ kən ównlij bij dəkówdɪd bǽk tə ɪts ərɪ́dʒɪnəl fɔ́rm baj ɔ́θəràjzd pɑ́rtijz pəzɛ́sɪŋ ðə kərɛ́kt dəkrɪ́pʃən kíj. ðɪs prɒ́sɛs ənʃʊ́rz kɒ̀nfɪdɛ́nʃijǽlɪtij əv sɛ́nsɪtɪv ɪnfərméjʃən sʌtʃ æz pǽswɜ̀rdz, fàjnǽnʃəl déjtə, ənd pɜ́rsənəl kəmjùwnɪkéjʃənz æz ðej trǽvəl əkrɔ́s nɛ́twɜ̀rks ɔr rɛ́st ɪn stɔ́rɪdʒ. mɒ́dərn ɛnkrɪ́pʃən sɪ́stəmz lájk AES, RSA, ənd TLS fɔ́rm ðə bǽkbòwn əv səkjʊ́r kəmjùwnɪkéjʃənz ɒn ðə ɪ́ntərnɛ̀t, prətɛ́ktɪŋ ɛ́vrijθɪ̀ŋ frəm ɔ́nlàjn bǽŋkɪŋ trænzǽkʃənz tə prájvət mɛ́sɪdʒɪz. ʌ̀nlájk rəléjtɪd kɒ́nsɛpts sʌtʃ æz hǽʃɪŋ (wɪ́tʃ ɪz wʌ́n-wej) ɔr kəmprɛ́ʃən (wɪ́tʃ rədjúwsɪz déjtə sájz), ɛnkrɪ́pʃən ɪz spəsɪ́fɪklij dəzájnd tə bij rijvɜ́rsəbəl wájl mejntéjnɪŋ strɔ́ŋ səkjʊ́rɪtij prɒ́pərtijz."
    },
    {
        "Question": "What is the process of converting encoded information from an unreadable format back to its original, readable form using cryptographic algorithms and keys called?",
        "RightAnswer": "Decryption",
        "WrongAnswers": [
            "Encryption",
            "Hashing",
            "Obfuscation",
            "Authentication",
            "Tokenization"
        ],
        "Explanation": "Decryption is the process of transforming information that has been rendered unreadable through encryption back into its original, comprehensible form. It essentially reverses the encryption process by using specific algorithms and a decryption key. When data is encrypted, it becomes scrambled and unintelligible to protect it from unauthorized access. Decryption is the authorized unlocking of this data when it needs to be accessed. For example, when you visit a secure website, your browser decrypts the information it receives from the server so you can view the content. Modern decryption can involve various methods from simple password-based approaches to complex mathematical operations using public and private keys. It forms a fundamental component of cybersecurity and digital privacy protection in our increasingly connected world.",
        "trans_Question": "wɒt ɪz ðə prɒ́sɛs əv kənvɜ́rtɪŋ ɛnkówdɪd ɪnfərméjʃən frəm ən ʌ́nríjdəbəl fɔ́rmæ̀t bǽk tə ɪts ərɪ́dʒɪnəl, ríjdəbəl fɔ́rm júwzɪŋ krɪptɒ́ɡrəfɪk ǽlɡərɪ̀ðəmz ənd kíjz kɔ́ld?",
        "trans_RightAnswer": "dəkrɪ́pʃən",
        "trans_WrongAnswers": [
            "ɛnkrɪ́pʃən",
            "hǽʃɪŋ",
            "ɒ̀bfəskéjʃən",
            "ɔθɛ̀ntɪkéjʃən",
            "tòwkənəzéjʃən"
        ],
        "trans_Explanation": "dəkrɪ́pʃən ɪz ðə prɒ́sɛs əv trænsfɔ́rmɪŋ ɪnfərméjʃən ðət həz bɪn rɛ́ndərd ʌ́nríjdəbəl θrúw ɛnkrɪ́pʃən bǽk ɪntə ɪts ərɪ́dʒɪnəl, kɒ̀mprəhɛ́nsɪbəl fɔ́rm. ɪt əsɛ́nʃəlij rijvɜ́rsɪz ðə ɛnkrɪ́pʃən prɒ́sɛs baj júwzɪŋ spəsɪ́fɪk ǽlɡərɪ̀ðəmz ənd ə dəkrɪ́pʃən kíj. wɛ́n déjtə ɪz ɛnkrɪ́ptɪd, ɪt bəkʌ́mz skrǽmbəld ənd ʌ̀nɪntɛ́lɪdʒəbəl tə prətɛ́kt ɪt frəm ənɔ́θəràjzd ǽksɛ̀s. dəkrɪ́pʃən ɪz ðə ɔ́θəràjzd ʌ̀nlɒ́kɪŋ əv ðɪs déjtə wɛ́n ɪt níjdz tə bij ǽksɛ̀st. fɔr əɡzǽmpəl, wɛ́n juw vɪ́zɪt ə səkjʊ́r wɛ́bsàjt, jɔr bráwzər dijkrɪ́pts ðə ɪnfərméjʃən ɪt rəsíjvz frəm ðə sɜ́rvər sow juw kən vjúw ðə kɒ́ntənt. mɒ́dərn dəkrɪ́pʃən kən ɪnvɒ́lv vɛ́ərijəs mɛ́θədz frəm sɪ́mpəl pǽswɜ̀rd-béjst əprówtʃɪz tə kɒ́mplɛks mæ̀θəmǽtɪkəl ɒ̀pəréjʃənz júwzɪŋ pʌ́blɪk ənd prájvət kíjz. ɪt fɔ́rmz ə fʌ̀ndəmɛ́ntəl kəmpównənt əv sàjbərsəkjʊ́rɪtij ənd dɪ́dʒɪtəl prájvəsij prətɛ́kʃən ɪn awər ɪnkríjsɪŋɡlij kənɛ́ktɪd wɜ́rld."
    },
    {
        "Question": "What technology allows multiple operating systems to run simultaneously on a single physical computer by creating isolated environments that share the underlying hardware resources?",
        "RightAnswer": "Virtualization",
        "WrongAnswers": [
            "Containerization",
            "Parallelization",
            "Cloud Computing",
            "Emulation",
            "Multithreading"
        ],
        "Explanation": "Virtualization is a foundational technology that creates software-based representations of computing resources such as servers, storage, networks, and operating systems. It enables a single physical computer to run multiple virtual machines, each with its own operating system and applications, functioning as if it were a separate physical machine. This is accomplished through a hypervisor, which is software that manages and allocates the physical hardware resources among the virtual machines. Virtualization maximizes hardware efficiency by allowing resources to be shared and utilized more effectively, reduces costs by decreasing the need for physical hardware, simplifies disaster recovery through easy virtual machine backups, and provides isolated environments for testing and development. The technology has revolutionized data centers, cloud computing, and enterprise IT by fundamentally changing how computing resources are deployed, managed, and scaled.",
        "trans_Question": "wɒt tɛknɒ́lədʒij əláwz mʌ́ltɪpəl ɒ́pərèjtɪŋ sɪ́stəmz tə rʌ́n sàjməltéjnijəslij ɒn ə sɪ́ŋɡəl fɪ́zɪkəl kəmpjúwtər baj krijéjtɪŋ ájsəlèjtɪd ənvájərənmənts ðət ʃɛ́ər ðə ʌ̀ndərlájɪŋ hɑ́rdwɛ̀ər ríjsɔrsɪz?",
        "trans_RightAnswer": "vɜ̀rtʃuwəlɪzéjʃən",
        "trans_WrongAnswers": [
            "kəntéjnəràjzɪzéjʃən",
            "pæ̀rələlɪzéjʃən",
            "kláwd kəmpjúwtɪŋ",
            "ɛ̀mjəléjʃən",
            "mʌ̀ltijθrɛ́dɪŋ"
        ],
        "trans_Explanation": "vɜ̀rtʃuwəlɪzéjʃən ɪz ə fawndéjʃənəl tɛknɒ́lədʒij ðət krijéjts sɔ́ftwɛ̀ər-béjst rɛ̀prəzəntéjʃənz əv kəmpjúwtɪŋ ríjsɔrsɪz sʌtʃ æz sɜ́rvərz, stɔ́rɪdʒ, nɛ́twɜ̀rks, ənd ɒ́pərèjtɪŋ sɪ́stəmz. ɪt ɛnéjbəlz ə sɪ́ŋɡəl fɪ́zɪkəl kəmpjúwtər tə rʌ́n mʌ́ltɪpəl vɜ́rtʃuwəl məʃíjnz, ijtʃ wɪð ɪts ówn ɒ́pərèjtɪŋ sɪ́stəm ənd æ̀plɪkéjʃənz, fʌ́ŋkʃənɪŋ æz ɪf ɪt wɜ́r ə sɛ́pərət fɪ́zɪkəl məʃíjn. ðɪs ɪz əkɒ́mplɪʃt θrúw ə hajpɜ́rvajzər, wɪ́tʃ ɪz sɔ́ftwɛ̀ər ðət mǽnɪdʒɪz ənd ǽləkèjts ðə fɪ́zɪkəl hɑ́rdwɛ̀ər ríjsɔrsɪz əmʌ́ŋ ðə vɜ́rtʃuwəl məʃíjnz. vɜ̀rtʃuwəlɪzéjʃən mǽksɪmàjzɪz hɑ́rdwɛ̀ər əfɪ́ʃənsij baj əláwɪŋ ríjsɔrsɪz tə bij ʃɛ́ərd ənd júwtɪlàjzd mɔr əfɛ́ktɪvlij, rədjúwsɪz kɒ́sts baj díjkrìjsɪŋ ðə níjd fɔr fɪ́zɪkəl hɑ́rdwɛ̀ər, sɪ́mpləfajz dɪzǽstər rəkʌ́vərij θrúw íjzij vɜ́rtʃuwəl məʃíjn bǽkʌ̀ps, ənd prəvájdz ájsəlèjtɪd ənvájərənmənts fɔr tɛ́stɪŋ ənd dəvɛ́ləpmənt. ðə tɛknɒ́lədʒij həz rɛ̀vəlúwʃənàjzd déjtə sɛ́ntərz, kláwd kəmpjúwtɪŋ, ənd ɛ́ntərpràjz IT baj fʌ̀ndəmɛ́ntəlij tʃéjndʒɪŋ háw kəmpjúwtɪŋ ríjsɔrsɪz ɑr dəplɔ́jd, mǽnɪdʒd, ənd skéjld."
    },
    {
        "Question": "Which computing paradigm allows users to access and use shared computing resources over the internet without direct active management by the user?",
        "RightAnswer": "Cloud Computing",
        "WrongAnswers": [
            "Edge Computing",
            "Grid Computing",
            "Quantum Computing",
            "Distributed Computing",
            "Fog Computing"
        ],
        "Explanation": "Cloud Computing refers to the delivery of computing services including servers, storage, databases, networking, software, and analytics over the internet, commonly referred to as 'the cloud.' This technology enables organizations to consume computing resources as a utility, similar to electricity, rather than building and maintaining physical computing infrastructures. Cloud Computing operates on a pay-as-you-go model, allowing businesses to scale resources up or down based on demand, which can lead to significant cost savings and flexibility. The technology is typically categorized into three service models: Infrastructure as a Service (IaaS), Platform as a Service (PaaS), and Software as a Service (SaaS). Cloud Computing has revolutionized how businesses operate by eliminating the need for companies to purchase, configure, and manage their own computing infrastructure, while also providing benefits such as increased reliability, global scale capabilities, and improved security measures.",
        "trans_Question": "wɪ́tʃ kəmpjúwtɪŋ pǽrədàjm əláwz júwzərz tə ǽksɛ̀s ənd juwz ʃɛ́ərd kəmpjúwtɪŋ ríjsɔrsɪz ówvər ðə ɪ́ntərnɛ̀t wɪðáwt dɪərɛ́kt ǽktɪv mǽnədʒmənt baj ðə júwzər?",
        "trans_RightAnswer": "kláwd kəmpjúwtɪŋ",
        "trans_WrongAnswers": [
            "ɛ́dʒ kəmpjúwtɪŋ",
            "ɡrɪ́d kəmpjúwtɪŋ",
            "kwɑ́ntəm kəmpjúwtɪŋ",
            "dɪstrɪ́bjətɪd kəmpjúwtɪŋ",
            "fɒ́ɡ kəmpjúwtɪŋ"
        ],
        "trans_Explanation": "kláwd kəmpjúwtɪŋ rəfɜ́rz tə ðə dəlɪ́vərij əv kəmpjúwtɪŋ sɜ́rvɪsɪz ɪnklúwdɪŋ sɜ́rvərz, stɔ́rɪdʒ, déjtəbèjsɪz, nɛ́twɜ̀rkɪŋ, sɔ́ftwɛ̀ər, ənd æ̀nəlɪ́tɪks ówvər ðə ɪ́ntərnɛ̀t, kɒ́mənlij rəfɜ́rd tə æz 'ðə kláwd.' ðɪs tɛknɒ́lədʒij ɛnéjbəlz ɔ̀rɡənɪzéjʃənz tə kənsúwm kəmpjúwtɪŋ ríjsɔrsɪz æz ə juwtɪ́lɪtij, sɪ́mɪlər tə əlɛ̀ktrɪ́sɪtij, rǽðər ðʌn bɪ́ldɪŋ ənd mejntéjnɪŋ fɪ́zɪkəl kəmpjúwtɪŋ ɪnfrəstrʌ́ktʃərz. kláwd kəmpjúwtɪŋ ɒ́pərèjts ɒn ə péj-æz-juw-ɡow mɒ́dəl, əláwɪŋ bɪ́znəsɪz tə skéjl ríjsɔrsɪz ʌp ɔr dawn béjst ɒn dəmǽnd, wɪ́tʃ kən líjd tə sɪɡnɪ́fɪkənt kɒ́st séjvɪŋz ənd flɛ̀ksɪbɪ́lɪtij. ðə tɛknɒ́lədʒij ɪz tɪ́pɪkəlij kǽtəɡəràjzd ɪntə θríj sɜ́rvɪs mɒ́dəlz: ɪnfrəstrʌ́ktʃər æz ə sɜ́rvɪs (ajæ̀z), plǽtfɔ̀rm æz ə sɜ́rvɪs (PAAS), ənd sɔ́ftwɛ̀ər æz ə sɜ́rvɪs (sɒ́s). kláwd kəmpjúwtɪŋ həz rɛ̀vəlúwʃənàjzd háw bɪ́znəsɪz ɒ́pərèjt baj əlɪ́mɪnèjtɪŋ ðə níjd fɔr kʌ́mpənìjz tə pɜ́rtʃəs, kənfɪ́ɡjər, ənd mǽnɪdʒ ðɛər ówn kəmpjúwtɪŋ ɪnfrəstrʌ́ktʃər, wájl ɔ́lsow prəvájdɪŋ bɛ́nəfɪts sʌtʃ æz ɪnkríjst rəlàjəbɪ́lɪtij, ɡlówbəl skéjl kèjpəbɪ́lɪtijz, ənd ɪmprúwvd səkjʊ́rɪtij mɛ́ʒərz."
    },
    {
        "Question": "What computing paradigm brings processing capabilities closer to data sources like IoT devices to reduce latency and bandwidth usage, rather than sending all data to centralized cloud servers?",
        "RightAnswer": "Edge Computing",
        "WrongAnswers": [
            "Distributed Computing",
            "Fog Computing",
            "Grid Computing",
            "Quantum Computing",
            "Serverless Computing"
        ],
        "Explanation": "Edge Computing is a computing paradigm that brings data processing and storage closer to the location where it is needed, typically at the edge of the network near the source of data generation. Unlike traditional cloud computing where data travels to centralized data centers for processing, edge computing performs computation at or near the data source such as IoT devices, sensors, or local servers. This approach significantly reduces latency, conserves bandwidth, enhances privacy, and enables real-time data analysis even in environments with limited connectivity. Edge computing is particularly valuable in applications requiring immediate responses like autonomous vehicles, industrial automation, smart cities, and augmented reality, where milliseconds matter. By distributing computing resources throughout the network rather than concentrating them in distant data centers, edge computing creates a more resilient and responsive system architecture that complements rather than replaces cloud computing.",
        "trans_Question": "wɒt kəmpjúwtɪŋ pǽrədàjm brɪ́ŋz prɒ́sɛsɪŋ kèjpəbɪ́lɪtijz klówsər tə déjtə sɔ́rsɪz lájk ijot dəvájsɪz tə rədjúws léjtənsij ənd bǽndwɪdθ júwsɪdʒ, rǽðər ðʌn sɛ́ndɪŋ ɔl déjtə tə sɛ́ntrəlàjzd kláwd sɜ́rvərz?",
        "trans_RightAnswer": "ɛ́dʒ kəmpjúwtɪŋ",
        "trans_WrongAnswers": [
            "dɪstrɪ́bjətɪd kəmpjúwtɪŋ",
            "fɒ́ɡ kəmpjúwtɪŋ",
            "ɡrɪ́d kəmpjúwtɪŋ",
            "kwɑ́ntəm kəmpjúwtɪŋ",
            "sɜ́rvərləs kəmpjúwtɪŋ"
        ],
        "trans_Explanation": "ɛ́dʒ kəmpjúwtɪŋ ɪz ə kəmpjúwtɪŋ pǽrədàjm ðət brɪ́ŋz déjtə prɒ́sɛsɪŋ ənd stɔ́rɪdʒ klówsər tə ðə lowkéjʃən wɛ́ər ɪt ɪz níjdɪd, tɪ́pɪkəlij æt ðə ɛ́dʒ əv ðə nɛ́twɜ̀rk nɪ́ər ðə sɔ́rs əv déjtə dʒɛ̀nəréjʃən. ʌ̀nlájk trədɪ́ʃənəl kláwd kəmpjúwtɪŋ wɛ́ər déjtə trǽvəlz tə sɛ́ntrəlàjzd déjtə sɛ́ntərz fɔr prɒ́sɛsɪŋ, ɛ́dʒ kəmpjúwtɪŋ pərfɔ́rmz kɒ̀mpjətéjʃən æt ɔr nɪ́ər ðə déjtə sɔ́rs sʌtʃ æz ijot dəvájsɪz, sɛ́nsərz, ɔr lówkəl sɜ́rvərz. ðɪs əprówtʃ sɪɡnɪ́fɪkəntlij rədjúwsɪz léjtənsij, kənsɜ́rvz bǽndwɪdθ, ənhǽnsɪz prájvəsij, ənd ɛnéjbəlz ríjəl-tájm déjtə ənǽlɪsɪs íjvən ɪn ənvájərənmənts wɪð lɪ́mɪtɪd kənɛktɪ́vɪtij. ɛ́dʒ kəmpjúwtɪŋ ɪz pərtɪ́kjələrlij vǽljəbəl ɪn æ̀plɪkéjʃənz rijkwájərɪŋ ɪmíjdijət rəspɒ́nsɪz lájk ɔtɒ́nəməs víjhəkəlz, ɪndʌ́strijəl ɔtəméjʃən, smɑ́rt sɪ́tijz, ənd ɒɡmɛ́ntɪd rìjǽlɪtij, wɛ́ər mɪ́lɪsɛ̀kəndz mǽtər. baj dɪstrɪ́bjuwtɪŋ kəmpjúwtɪŋ ríjsɔrsɪz θruwáwt ðə nɛ́twɜ̀rk rǽðər ðʌn kɒ́nsəntrèjtɪŋ ðɛm ɪn dɪ́stənt déjtə sɛ́ntərz, ɛ́dʒ kəmpjúwtɪŋ krijéjts ə mɔr rəzɪ́ljənt ənd rəspɒ́nsɪv sɪ́stəm ɑ́rkɪtɛ̀ktʃər ðət kɒ́mpləmənts rǽðər ðʌn rəpléjsɪz kláwd kəmpjúwtɪŋ."
    },
    {
        "Question": "What technology underpins cryptocurrencies like Bitcoin by maintaining a decentralized, tamper-resistant record of transactions across multiple computers without requiring a central authority?",
        "RightAnswer": "Distributed Ledger",
        "WrongAnswers": [
            "Virtual Memory System",
            "Content Delivery Network",
            "Remote Procedure Call",
            "Parallel Computing Architecture",
            "Quantum Encryption Protocol"
        ],
        "Explanation": "A Distributed Ledger is a consensus-based digital system where transaction records are stored and synchronized across multiple computers or nodes in a network, rather than being held in a single central location. Each participant in the network maintains an identical copy of the ledger, which updates automatically when new transactions occur. This architecture provides significant advantages: it eliminates the need for a central authority, creates inherent resistance to tampering and revision, and ensures data integrity through cryptographic validation mechanisms. Distributed Ledgers form the technological foundation for blockchain systems like Bitcoin and Ethereum, but extend beyond cryptocurrencies to applications in supply chain management, digital identity verification, and secure record-keeping systems. Unlike traditional databases controlled by a single entity, Distributed Ledgers democratize data control while maintaining security through consensus algorithms where participants collectively validate new entries.",
        "trans_Question": "wɒt tɛknɒ́lədʒij ʌ̀ndərpɪ́nz krɪ̀ptowkɜ́rənsijz lájk bɪ́tkɔ́jn baj mejntéjnɪŋ ə dəsɛ́ntrəlàjzd, tǽmpər-rəzɪ́stənt rɛ́kɔrd əv trænzǽkʃənz əkrɔ́s mʌ́ltɪpəl kəmpjúwtərz wɪðáwt rijkwájərɪŋ ə sɛ́ntrəl əθɔ́rɪtij?",
        "trans_RightAnswer": "dɪstrɪ́bjətɪd lɛ́dʒər",
        "trans_WrongAnswers": [
            "vɜ́rtʃuwəl mɛ́mərij sɪ́stəm",
            "kɒ́ntənt dəlɪ́vərij nɛ́twɜ̀rk",
            "rijmówt prəsíjdʒər kɔ́l",
            "pǽrəlɛ̀l kəmpjúwtɪŋ ɑ́rkɪtɛ̀ktʃər",
            "kwɑ́ntəm ɛnkrɪ́pʃən prówtəkɒ̀l"
        ],
        "trans_Explanation": "ə dɪstrɪ́bjətɪd lɛ́dʒər ɪz ə kənsɛ́nsəs-béjst dɪ́dʒɪtəl sɪ́stəm wɛ́ər trænzǽkʃən rɛ́kərdz ɑr stɔ́rd ənd sɪ́ŋkrənàjzd əkrɔ́s mʌ́ltɪpəl kəmpjúwtərz ɔr nówdz ɪn ə nɛ́twɜ̀rk, rǽðər ðʌn bíjɪŋ hɛ́ld ɪn ə sɪ́ŋɡəl sɛ́ntrəl lowkéjʃən. ijtʃ pɑrtɪ́səpənt ɪn ðə nɛ́twɜ̀rk mejntéjnz ən ajdɛ́ntɪkəl kɒ́pij əv ðə lɛ́dʒər, wɪ́tʃ ʌ́pdèjts ɔ̀təmǽtɪklij wɛ́n núw trænzǽkʃənz əkɜ́r. ðɪs ɑ́rkɪtɛ̀ktʃər prəvájdz sɪɡnɪ́fɪkənt ədvǽntɪdʒɪz: ɪt əlɪ́mɪnèjts ðə níjd fɔr ə sɛ́ntrəl əθɔ́rɪtij, krijéjts ɪnhɛ́ərənt rəzɪ́stəns tə tǽmpərɪŋ ənd rijvɪ́ʒən, ənd ənʃʊ́rz déjtə ɪntɛ́ɡrɪtij θrúw krɪptɒ́ɡrəfɪk væ̀lɪdéjʃən mɛ́kənɪzəmz. dɪstrɪ́bjətɪd lɛ́dʒərz fɔ́rm ðə tɛ̀knəlɒ́dʒɪkəl fawndéjʃən fɔr blɒ́ktʃéjn sɪ́stəmz lájk bɪ́tkɔ́jn ənd ɛθɪəríjəm, bʌt əkstɛ́nd bìjɔ́nd krɪ̀ptowkɜ́rənsijz tə æ̀plɪkéjʃənz ɪn səpláj tʃéjn mǽnədʒmənt, dɪ́dʒɪtəl ajdɛ́ntɪtij vɛ̀ərɪfɪkéjʃən, ənd səkjʊ́r rɛ́kɔrd-kíjpɪŋ sɪ́stəmz. ʌ̀nlájk trədɪ́ʃənəl déjtəbèjsɪz kəntrówld baj ə sɪ́ŋɡəl ɛ́ntɪtij, dɪstrɪ́bjətɪd lɛ́dʒərz dəmɒ́krətàjz déjtə kəntrówl wájl mejntéjnɪŋ səkjʊ́rɪtij θrúw kənsɛ́nsəs ǽlɡərɪ̀ðəmz wɛ́ər pɑrtɪ́səpənts kəlɛ́ktɪvlij vǽlɪdèjt núw ɛ́ntrijz."
    },
    {
        "Question": "What is the name of the self-executing computer program that automatically enforces the terms of an agreement when predefined conditions are met, commonly used in blockchain technology?",
        "RightAnswer": "Smart Contract",
        "WrongAnswers": [
            "Automated Protocol",
            "Blockchain Agreement",
            "Digital Covenant",
            "Executable Ledger",
            "Cryptographic Validator"
        ],
        "Explanation": "A Smart Contract is a self-executing program that runs on a blockchain network, automatically implementing the terms of an agreement between parties when specific conditions are satisfied. Unlike traditional contracts that require human interpretation and enforcement, Smart Contracts use code to automatically execute actions such as transferring digital assets or accessing digital services when triggering conditions occur. They eliminate the need for intermediaries, reduce transaction costs, and increase transparency since their execution is verifiable on the blockchain. Smart Contracts were first conceptualized by Nick Szabo in 1994 but gained practical implementation with the emergence of blockchain platforms like Ethereum. They represent a fundamental innovation in digital trust mechanisms by transforming contractual clauses into computer code that can enforce themselves, though they are limited by the precision of their programming and the 'garbage in, garbage out' principle, meaning they are only as reliable as the data they receive.",
        "trans_Question": "wɒt ɪz ðə néjm əv ðə sɛ́lf-ɛ́ksəkjùwtɪŋ kəmpjúwtər prówɡræ̀m ðət ɔ̀təmǽtɪklij ɛnfɔ́rsɪz ðə tɜ́rmz əv ən əɡríjmənt wɛ́n prìjdəfájnd kəndɪ́ʃənz ɑr mɛ́t, kɒ́mənlij júwzd ɪn blɒ́ktʃéjn tɛknɒ́lədʒij?",
        "trans_RightAnswer": "smɑ́rt kɒ́ntrækt",
        "trans_WrongAnswers": [
            "ɔ́təmèjtɪd prówtəkɒ̀l",
            "blɒ́ktʃéjn əɡríjmənt",
            "dɪ́dʒɪtəl kʌ́vənənt",
            "ɛ́ksəkjùwtəbəl lɛ́dʒər",
            "krɪptɒ́ɡrəfɪk vǽlədejtər"
        ],
        "trans_Explanation": "ə smɑ́rt kɒ́ntrækt ɪz ə sɛ́lf-ɛ́ksəkjùwtɪŋ prówɡræ̀m ðət rʌ́nz ɒn ə blɒ́ktʃéjn nɛ́twɜ̀rk, ɔ̀təmǽtɪklij ɪ́mpləmɛ̀ntɪŋ ðə tɜ́rmz əv ən əɡríjmənt bijtwíjn pɑ́rtijz wɛ́n spəsɪ́fɪk kəndɪ́ʃənz ɑr sǽtɪsfàjd. ʌ̀nlájk trədɪ́ʃənəl kɒ́ntræ̀kts ðət rəkwájər hjúwmən ɪntɜ̀rprətéjʃən ənd ɛnfɔ́rsmənt, smɑ́rt kɒ́ntræ̀kts juwz kówd tə ɔ̀təmǽtɪklij ɛ́ksəkjùwt ǽkʃənz sʌtʃ æz trænsfɜ́rɪŋ dɪ́dʒɪtəl ǽsɛts ɔr ǽksɛ̀sɪŋ dɪ́dʒɪtəl sɜ́rvɪsɪz wɛ́n trɪ́ɡərɪŋ kəndɪ́ʃənz əkɜ́r. ðej əlɪ́mɪnèjt ðə níjd fɔr ɪ̀ntərmíjdijɛ̀ərijz, rədjúws trænzǽkʃən kɒ́sts, ənd ɪnkríjs trænspɛ́ərənsij sɪns ðɛər ɛ̀ksəkjúwʃən ɪz vɛ́ərɪfajəbəl ɒn ðə blɒ́ktʃéjn. smɑ́rt kɒ́ntræ̀kts wɜ́r fɜ́rst kənsɛ́ptjʊəlàjz baj nɪ́k ʃɒ́bow ɪn 1994 bʌt ɡéjnd prǽktɪkəl ɪ̀mpləmɛntéjʃən wɪð ðə əmɜ́rdʒəns əv blɒ́ktʃéjn plǽtfɔ̀rmz lájk ɛθɪəríjəm. ðej rɛ̀prəzɛ́nt ə fʌ̀ndəmɛ́ntəl ɪnəvéjʃən ɪn dɪ́dʒɪtəl trʌ́st mɛ́kənɪzəmz baj trænsfɔ́rmɪŋ kəntrǽktʃuwəl klɔ́zɪz ɪntə kəmpjúwtər kówd ðət kən ɛnfɔ́rs ðəmsɛ́lvz, ðów ðej ɑr lɪ́mɪtɪd baj ðə prəsɪ́ʒən əv ðɛər prówɡræ̀mɪŋ ənd ðə 'ɡɑ́rbɪdʒ ɪn, ɡɑ́rbɪdʒ awt' prɪ́nsɪpəl, míjnɪŋ ðej ɑr ównlij æz rəlájəbəl æz ðə déjtə ðej rəsíjv."
    },
    {
        "Question": "Which term refers to the massive volumes of structured and unstructured data that are so large and complex that traditional data processing applications are inadequate to deal with them?",
        "RightAnswer": "Big Data",
        "WrongAnswers": [
            "Data Mining",
            "Data Warehousing",
            "Cloud Computing",
            "Machine Learning",
            "Data Visualization"
        ],
        "Explanation": "Big Data refers to extremely large and complex datasets that cannot be effectively managed, processed, or analyzed using conventional data processing tools. It is characterized by what industry experts call the 'Three Vs': Volume (enormous amounts of data), Velocity (the speed at which new data is generated and moves), and Variety (different types and formats of data). In recent years, additional Vs have been added, including Veracity (uncertainty of data) and Value (the worth derived from the data). Big Data technologies like Hadoop, Spark, and NoSQL databases enable organizations to extract meaningful insights from these massive datasets, supporting decision-making processes and revealing patterns that would otherwise remain hidden. Industries ranging from healthcare to finance to retail now rely on Big Data analytics to drive innovation and competitive advantage.",
        "trans_Question": "wɪ́tʃ tɜ́rm rəfɜ́rz tə ðə mǽsɪv vɒ́ljuwmz əv strʌ́ktʃərd ənd ʌ̀nstrʌ́kʃərd déjtə ðət ɑr sow lɑ́rdʒ ənd kɒ́mplɛks ðət trədɪ́ʃənəl déjtə prɒ́sɛsɪŋ æ̀plɪkéjʃənz ɑr ɪ̀nǽdəkwèjt tə díjl wɪð ðɛm?",
        "trans_RightAnswer": "bɪ́ɡ déjtə",
        "trans_WrongAnswers": [
            "déjtə májnɪŋ",
            "déjtə wɛ́ərhàwzɪŋ",
            "kláwd kəmpjúwtɪŋ",
            "məʃíjn lɜ́rnɪŋ",
            "déjtə vɪ̀ʒwəlɪzéjʃən"
        ],
        "trans_Explanation": "bɪ́ɡ déjtə rəfɜ́rz tə əkstríjmlij lɑ́rdʒ ənd kɒ́mplɛks déjtəsɛ̀ts ðət kǽnɒt bij əfɛ́ktɪvlij mǽnɪdʒd, prɒ́sɛst, ɔr ǽnəlàjzd júwzɪŋ kənvɛ́nʃənəl déjtə prɒ́sɛsɪŋ túwlz. ɪt ɪz kǽrəktərajzd baj wɒt ɪ́ndəstrij ɛ́kspərts kɔ́l ðə 'θríj vɜ́rsəs': vɒ́ljuwm (ənɔ́rməs əmáwnts əv déjtə), vəlɒ́sɪtij (ðə spíjd æt wɪ́tʃ núw déjtə ɪz dʒɛ́nərèjtɪd ənd múwvz), ənd vərájətij (dɪ́fərənt tájps ənd fɔ́rmæ̀ts əv déjtə). ɪn ríjsənt jɪ́ərz, ədɪ́ʃənəl vɜ́rsəs həv bɪn ǽdɪd, ɪnklúwdɪŋ vərǽsɪtij (ʌ̀nsɜ́rtəntij əv déjtə) ənd vǽljuw (ðə wɜ́rθ dərájvd frəm ðə déjtə). bɪ́ɡ déjtə tɛknɒ́lədʒijz lájk hǽdúwp, spɑ́rk, ənd now-sql déjtəbèjsɪz ɛnéjbəl ɔ̀rɡənɪzéjʃənz tə ɛ́kstrəkt míjnɪŋfəl ɪ́nsàjts frəm ðijz mǽsɪv déjtəsɛ̀ts, səpɔ́rtɪŋ dəsɪ́ʒən-méjkɪŋ prɒ́sɛsɪz ənd rəvíjlɪŋ pǽtərnz ðət wʊd ʌ́ðərwàjz rəméjn hɪ́dən. ɪ́ndəstrijz réjndʒɪŋ frəm hɛ́lθkɛ̀ər tə fájnæ̀ns tə ríjtèjl náw rəláj ɒn bɪ́ɡ déjtə æ̀nəlɪ́tɪks tə drájv ɪnəvéjʃən ənd kəmpɛ́tɪtɪv ədvǽntɪdʒ."
    },
    {
        "Question": "Which computational technique involves extracting patterns and knowledge from vast datasets to support decision-making processes?",
        "RightAnswer": "Data Mining",
        "WrongAnswers": [
            "Network Tunneling",
            "Query Optimization",
            "Memory Paging",
            "Stack Overflow",
            "Protocol Buffering"
        ],
        "Explanation": "Data Mining is the computational process of discovering patterns and extracting valuable information from large datasets. It combines methods from statistics, machine learning, and database systems to transform raw data into actionable insights. Unlike simple data analysis, data mining goes deeper by identifying hidden patterns, correlations, and trends that might not be immediately apparent. Organizations use data mining to make informed business decisions, predict future trends, detect anomalies, and understand customer behavior. The process typically involves several stages: data collection, cleaning, processing, pattern identification, and knowledge interpretation. Common applications include market basket analysis in retail, fraud detection in finance, recommendation systems in e-commerce, and disease pattern recognition in healthcare. Data mining has become increasingly important in the age of big data, where traditional analytical methods struggle to handle the volume, variety, and velocity of information being generated.",
        "trans_Question": "wɪ́tʃ kɒ̀mpjuwtéjʃənəl tɛkníjk ɪnvɒ́lvz əkstrǽktɪŋ pǽtərnz ənd nɒ́lɪdʒ frəm vǽst déjtəsɛ̀ts tə səpɔ́rt dəsɪ́ʒən-méjkɪŋ prɒ́sɛsɪz?",
        "trans_RightAnswer": "déjtə májnɪŋ",
        "trans_WrongAnswers": [
            "nɛ́twɜ̀rk tʌ́nəlɪŋ",
            "kwɛ́ərij ɒptɪmɪzéjʃən",
            "mɛ́mərij péjdʒɪŋ",
            "stǽk ówvərflòw",
            "prówtəkɒ̀l bʌ́fərɪŋ"
        ],
        "trans_Explanation": "déjtə májnɪŋ ɪz ðə kɒ̀mpjuwtéjʃənəl prɒ́sɛs əv dɪskʌ́vərɪŋ pǽtərnz ənd əkstrǽktɪŋ vǽljəbəl ɪnfərméjʃən frəm lɑ́rdʒ déjtəsɛ̀ts. ɪt kəmbájnz mɛ́θədz frəm stətɪ́stɪks, məʃíjn lɜ́rnɪŋ, ənd déjtəbèjs sɪ́stəmz tə trǽnsfɔrm rɔ́ déjtə ɪntə ǽkʃənəbəl ɪ́nsàjts. ʌ̀nlájk sɪ́mpəl déjtə ənǽlɪsɪs, déjtə májnɪŋ ɡówz díjpər baj ajdɛ́ntɪfàjɪŋ hɪ́dən pǽtərnz, kɔ̀rəléjʃənz, ənd trɛ́ndz ðət majt nɒt bij ɪmíjdijətlij əpǽrənt. ɔ̀rɡənɪzéjʃənz juwz déjtə májnɪŋ tə méjk ɪnfɔ́rmd bɪ́znəs dəsɪ́ʒənz, prədɪ́kt fjúwtʃər trɛ́ndz, dətɛ́kt ənɒ́məlijz, ənd ʌ̀ndərstǽnd kʌ́stəmər bəhéjvjər. ðə prɒ́sɛs tɪ́pɪkəlij ɪnvɒ́lvz sɛ́vərəl stéjdʒɪz: déjtə kəlɛ́kʃən, klíjnɪŋ, prɒ́sɛsɪŋ, pǽtərn ajdɛ̀ntɪfɪkéjʃən, ənd nɒ́lɪdʒ ɪntɜ̀rprətéjʃən. kɒ́mən æ̀plɪkéjʃənz ɪnklúwd mɑ́rkət bǽskət ənǽlɪsɪs ɪn ríjtèjl, frɔ́d dətɛ́kʃən ɪn fájnæ̀ns, rɛ̀kəməndéjʃən sɪ́stəmz ɪn e-kɒ́mərs, ənd dɪzíjz pǽtərn rɛ̀kəɡnɪ́ʃən ɪn hɛ́lθkɛ̀ər. déjtə májnɪŋ həz bəkʌ́m ɪnkríjsɪŋɡlij ɪmpɔ́rtənt ɪn ðə éjdʒ əv bɪ́ɡ déjtə, wɛ́ər trədɪ́ʃənəl æ̀nəlɪ́tɪkəl mɛ́θədz strʌ́ɡəl tə hǽndəl ðə vɒ́ljuwm, vərájətij, ənd vəlɒ́sɪtij əv ɪnfərméjʃən bíjɪŋ dʒɛ́nərèjtɪd."
    },
    {
        "Question": "What is the branch of artificial intelligence that enables computers to learn patterns from data and make predictions or decisions without being explicitly programmed for each specific task?",
        "RightAnswer": "Machine Learning",
        "WrongAnswers": [
            "Data Mining",
            "Neural Networking",
            "Algorithmic Programming",
            "Computational Logic",
            "Statistical Modeling"
        ],
        "Explanation": "Machine Learning is a transformative field within computer science that focuses on developing systems that can learn from and improve through experience. Unlike traditional programming where explicit instructions must be provided for every scenario, machine learning algorithms are designed to identify patterns in data and build models that can make predictions or decisions on new, unseen data. This approach enables computers to perform tasks that would be difficult or impossible to accomplish with conventional programming techniques. Machine learning encompasses various techniques including supervised learning (where algorithms learn from labeled examples), unsupervised learning (finding patterns in unlabeled data), and reinforcement learning (learning through trial and error with feedback). Applications of machine learning are vast and growing rapidly, ranging from recommendation systems and natural language processing to computer vision and autonomous vehicles. The power of machine learning lies in its ability to handle complex, real-world problems by extracting meaningful insights from large volumes of data, making it a cornerstone of modern artificial intelligence.",
        "trans_Question": "wɒt ɪz ðə brǽntʃ əv ɑ̀rtɪfɪ́ʃəl ɪntɛ́lɪdʒəns ðət ɛnéjbəlz kəmpjúwtərz tə lɜ́rn pǽtərnz frəm déjtə ənd méjk prədɪ́kʃənz ɔr dəsɪ́ʒənz wɪðáwt bíjɪŋ əksplɪ́sɪtlij prówɡræ̀md fɔr ijtʃ spəsɪ́fɪk tǽsk?",
        "trans_RightAnswer": "məʃíjn lɜ́rnɪŋ",
        "trans_WrongAnswers": [
            "déjtə májnɪŋ",
            "nʊ́rəl nɛ́twɜ̀rkɪŋ",
            "ǽlɡərɪ̀ðəmɪk prówɡræ̀mɪŋ",
            "kɒ̀mpjuwtéjʃənəl lɒ́dʒɪk",
            "stətɪ́stɪkəl mɒ́dəlɪ̀ŋ"
        ],
        "trans_Explanation": "məʃíjn lɜ́rnɪŋ ɪz ə træ̀nsfɔ́rmɒtɪ̀v fíjld wɪðɪ́n kəmpjúwtər sájəns ðət fówkəsɪz ɒn dəvɛ́ləpɪŋ sɪ́stəmz ðət kən lɜ́rn frəm ənd ɪmprúwv θrúw əkspɪ́ərijəns. ʌ̀nlájk trədɪ́ʃənəl prówɡræ̀mɪŋ wɛ́ər əksplɪ́sɪt ɪnstrʌ́kʃənz mʌst bij prəvájdɪd fɔr ɛvərij sənɛ́ərijow, məʃíjn lɜ́rnɪŋ ǽlɡərɪ̀ðəmz ɑr dəzájnd tə ajdɛ́ntɪfàj pǽtərnz ɪn déjtə ənd bɪ́ld mɒ́dəlz ðət kən méjk prədɪ́kʃənz ɔr dəsɪ́ʒənz ɒn núw, ʌ̀nsíjn déjtə. ðɪs əprówtʃ ɛnéjbəlz kəmpjúwtərz tə pərfɔ́rm tǽsks ðət wʊd bij dɪ́fɪkəlt ɔr ɪ̀mpɒ́sɪbəl tə əkɒ́mplɪʃ wɪð kənvɛ́nʃənəl prówɡræ̀mɪŋ tɛkníjks. məʃíjn lɜ́rnɪŋ ɛnkʌ́mpəsɪz vɛ́ərijəs tɛkníjks ɪnklúwdɪŋ súwpərvàjzd lɜ́rnɪŋ (wɛ́ər ǽlɡərɪ̀ðəmz lɜ́rn frəm léjbəld əɡzǽmpəlz), ʌ̀nsúwpərvàjzd lɜ́rnɪŋ (fájndɪŋ pǽtərnz ɪn ʌ̀nléjbəld déjtə), ənd rìjɪnfɔ́rsmənt lɜ́rnɪŋ (lɜ́rnɪŋ θrúw trájəl ənd ɛ́ərər wɪð fíjdbæ̀k). æ̀plɪkéjʃənz əv məʃíjn lɜ́rnɪŋ ɑr vǽst ənd ɡrówɪŋ rǽpɪdlij, réjndʒɪŋ frəm rɛ̀kəməndéjʃən sɪ́stəmz ənd nǽtʃərəl lǽŋɡwədʒ prɒ́sɛsɪŋ tə kəmpjúwtər vɪ́ʒən ənd ɔtɒ́nəməs víjhəkəlz. ðə páwər əv məʃíjn lɜ́rnɪŋ lájz ɪn ɪts əbɪ́lɪtij tə hǽndəl kɒ́mplɛks, ríjəl-wɜ́rld prɒ́bləmz baj əkstrǽktɪŋ míjnɪŋfəl ɪ́nsàjts frəm lɑ́rdʒ vɒ́ljuwmz əv déjtə, méjkɪŋ ɪt ə kɔ́rnərstòwn əv mɒ́dərn ɑ̀rtɪfɪ́ʃəl ɪntɛ́lɪdʒəns."
    },
    {
        "Question": "Which artificial intelligence approach is characterized by using neural networks with multiple layers to learn hierarchical representations of data, enabling breakthroughs in image recognition, natural language processing, and game playing?",
        "RightAnswer": "Deep Learning",
        "WrongAnswers": [
            "Expert Systems",
            "Evolutionary Computation",
            "Fuzzy Logic",
            "Decision Trees",
            "Reinforcement Scheduling"
        ],
        "Explanation": "Deep Learning is a specialized subset of machine learning that uses artificial neural networks with many layers (hence 'deep') to progressively extract higher-level features from raw input. For example, in image recognition, lower layers might detect edges, while higher layers identify more complex patterns like faces or objects. What makes Deep Learning revolutionary is its ability to automatically discover the representations needed for detection or classification, eliminating the need for manual feature engineering. This approach has enabled remarkable advances in fields like computer vision, speech recognition, natural language processing, and game playing. Deep Learning models require substantial computational resources and large datasets to train effectively, but their capacity to solve previously intractable problems has transformed the artificial intelligence landscape. The success of systems like AlphaGo, voice assistants, and advanced translation services all stem from breakthroughs in Deep Learning techniques.",
        "trans_Question": "wɪ́tʃ ɑ̀rtɪfɪ́ʃəl ɪntɛ́lɪdʒəns əprówtʃ ɪz kǽrəktərajzd baj júwzɪŋ nʊ́rəl nɛ́twɜ̀rks wɪð mʌ́ltɪpəl léjərz tə lɜ́rn hàjərɑ́rkɪkəl rɛ̀prəzəntéjʃənz əv déjtə, ɛnéjbəlɪŋ bréjkθrùwz ɪn ɪ́mɪdʒ rɛ̀kəɡnɪ́ʃən, nǽtʃərəl lǽŋɡwədʒ prɒ́sɛsɪŋ, ənd ɡéjm pléjɪŋ?",
        "trans_RightAnswer": "díjp lɜ́rnɪŋ",
        "trans_WrongAnswers": [
            "ɛ́kspərt sɪ́stəmz",
            "ɛ̀vəlúwʃənɛ̀ərij kɒ̀mpjətéjʃən",
            "fʌ́zij lɒ́dʒɪk",
            "dəsɪ́ʒən tríjz",
            "rìjɪnfɔ́rsmənt skɛ́dʒuwlɪŋ"
        ],
        "trans_Explanation": "díjp lɜ́rnɪŋ ɪz ə spɛ́ʃəlàjzd sʌ́bsɛ̀t əv məʃíjn lɜ́rnɪŋ ðət júwsɪz ɑ̀rtɪfɪ́ʃəl nʊ́rəl nɛ́twɜ̀rks wɪð mɛ́nij léjərz (hɛ́ns 'díjp') tə prɒɡrɛ́sɪvlij ɛ́kstrəkt hájər-lɛ́vəl fíjtʃərz frəm rɔ́ ɪ́npʊ̀t. fɔr əɡzǽmpəl, ɪn ɪ́mɪdʒ rɛ̀kəɡnɪ́ʃən, lówər léjərz majt dətɛ́kt ɛ́dʒɪz, wájl hájər léjərz ajdɛ́ntɪfàj mɔr kɒ́mplɛks pǽtərnz lájk féjsɪz ɔr ɒ́bdʒɛkts. wɒt méjks díjp lɜ́rnɪŋ rɛ̀vəlúwʃənɛ̀ərij ɪz ɪts əbɪ́lɪtij tə ɔ̀təmǽtɪklij dɪskʌ́vər ðə rɛ̀prəzəntéjʃənz níjdɪd fɔr dətɛ́kʃən ɔr klæ̀sɪfɪkéjʃən, əlɪ́mɪnèjtɪŋ ðə níjd fɔr mǽnjuwəl fíjtʃər ɛ̀ndʒɪnɪ́ərɪŋ. ðɪs əprówtʃ həz ɛnéjbəld rəmɑ́rkəbəl ədvǽnsɪz ɪn fíjldz lájk kəmpjúwtər vɪ́ʒən, spíjtʃ rɛ̀kəɡnɪ́ʃən, nǽtʃərəl lǽŋɡwədʒ prɒ́sɛsɪŋ, ənd ɡéjm pléjɪŋ. díjp lɜ́rnɪŋ mɒ́dəlz rəkwájər sʌbstǽnʃəl kɒ̀mpjuwtéjʃənəl ríjsɔrsɪz ənd lɑ́rdʒ déjtəsɛ̀ts tə tréjn əfɛ́ktɪvlij, bʌt ðɛər kəpǽsɪtij tə sɒ́lv príjvijəslij ɪ̀ntrǽktəbəl prɒ́bləmz həz trænsfɔ́rmd ðə ɑ̀rtɪfɪ́ʃəl ɪntɛ́lɪdʒəns lǽnskèjp. ðə səksɛ́s əv sɪ́stəmz lájk ǽlfəɡòw, vɔ́js əsɪ́stənts, ənd ədvǽnst trænsléjʃən sɜ́rvɪsɪz ɔl stɛ́m frəm bréjkθrùwz ɪn díjp lɜ́rnɪŋ tɛkníjks."
    },
    {
        "Question": "What computational model is inspired by the human brain, consists of interconnected artificial neurons organized in layers, and has revolutionized tasks like image recognition and natural language processing?",
        "RightAnswer": "Neural Network",
        "WrongAnswers": [
            "Decision Tree",
            "Hash Table",
            "Genetic Algorithm",
            "Support Vector Machine",
            "Random Forest"
        ],
        "Explanation": "A Neural Network is a computational architecture inspired by the biological neural networks in human brains. It consists of interconnected nodes or 'neurons' typically arranged in layers: an input layer that receives data, one or more hidden layers that process it, and an output layer that delivers results. Each connection between neurons has a weight that adjusts during training, allowing the network to learn patterns from data. Neural networks excel at recognizing complex patterns and relationships, making them powerful for tasks like image and speech recognition, natural language processing, and predictive analytics. Unlike traditional algorithms that follow explicit programming instructions, neural networks learn from examples, improving their performance over time through a process called training. This ability to learn and adapt has made neural networks the foundation of many modern artificial intelligence applications, from virtual assistants to autonomous vehicles.",
        "trans_Question": "wɒt kɒ̀mpjuwtéjʃənəl mɒ́dəl ɪz ɪnspájərd baj ðə hjúwmən bréjn, kənsɪ́sts əv ɪ̀ntərkənɛ́ktɪd ɑ̀rtɪfɪ́ʃəl nʊ́rɒnz ɔ́rɡənàjzd ɪn léjərz, ənd həz rɛ̀vəlúwʃənàjzd tǽsks lájk ɪ́mɪdʒ rɛ̀kəɡnɪ́ʃən ənd nǽtʃərəl lǽŋɡwədʒ prɒ́sɛsɪŋ?",
        "trans_RightAnswer": "nʊ́rəl nɛ́twɜ̀rk",
        "trans_WrongAnswers": [
            "dəsɪ́ʒən tríj",
            "hǽʃ téjbəl",
            "dʒənɛ́tɪk ǽlɡərɪ̀ðəm",
            "səpɔ́rt vɛ́ktər məʃíjn",
            "rǽndəm fɔ́rəst"
        ],
        "trans_Explanation": "ə nʊ́rəl nɛ́twɜ̀rk ɪz ə kɒ̀mpjuwtéjʃənəl ɑ́rkɪtɛ̀ktʃər ɪnspájərd baj ðə bàjəlɒ́dʒɪkəl nʊ́rəl nɛ́twɜ̀rks ɪn hjúwmən bréjnz. ɪt kənsɪ́sts əv ɪ̀ntərkənɛ́ktɪd nówdz ɔr 'nʊ́rɒnz' tɪ́pɪkəlij əréjndʒd ɪn léjərz: ən ɪ́npʊ̀t léjər ðət rəsíjvz déjtə, wʌ́n ɔr mɔr hɪ́dən léjərz ðət prɒ́sɛs ɪt, ənd ən áwtpʊ̀t léjər ðət dəlɪ́vərz rəzʌ́lts. ijtʃ kənɛ́kʃən bijtwíjn nʊ́rɒnz həz ə wéjt ðət ədʒʌ́sts dʊ́rɪŋ tréjnɪŋ, əláwɪŋ ðə nɛ́twɜ̀rk tə lɜ́rn pǽtərnz frəm déjtə. nʊ́rəl nɛ́twɜ̀rks əksɛ́l æt rɛ́kəɡnàjzɪŋ kɒ́mplɛks pǽtərnz ənd rəléjʃənʃɪ̀ps, méjkɪŋ ðɛm páwərfəl fɔr tǽsks lájk ɪ́mɪdʒ ənd spíjtʃ rɛ̀kəɡnɪ́ʃən, nǽtʃərəl lǽŋɡwədʒ prɒ́sɛsɪŋ, ənd prədɪ́ktɪv æ̀nəlɪ́tɪks. ʌ̀nlájk trədɪ́ʃənəl ǽlɡərɪ̀ðəmz ðət fɒ́low əksplɪ́sɪt prówɡræ̀mɪŋ ɪnstrʌ́kʃənz, nʊ́rəl nɛ́twɜ̀rks lɜ́rn frəm əɡzǽmpəlz, ɪmprúwvɪŋ ðɛər pərfɔ́rməns ówvər tájm θrúw ə prɒ́sɛs kɔ́ld tréjnɪŋ. ðɪs əbɪ́lɪtij tə lɜ́rn ənd ədǽpt həz méjd nʊ́rəl nɛ́twɜ̀rks ðə fawndéjʃən əv mɛ́nij mɒ́dərn ɑ̀rtɪfɪ́ʃəl ɪntɛ́lɪdʒəns æ̀plɪkéjʃənz, frəm vɜ́rtʃuwəl əsɪ́stənts tə ɔtɒ́nəməs víjhəkəlz."
    },
    {
        "Question": "What is the term for the branch of computer science that aims to create systems capable of performing tasks that typically require human intelligence, such as visual perception, speech recognition, decision-making, and language translation?",
        "RightAnswer": "Artificial Intelligence",
        "WrongAnswers": [
            "Computational Linguistics",
            "Machine Architecture",
            "System Automation",
            "Cognitive Computing",
            "Algorithmic Processing"
        ],
        "Explanation": "Artificial Intelligence refers to the development of computer systems that can perform tasks that would normally require human intelligence. Unlike traditional programming where explicit instructions are provided for every action, AI systems are designed to learn from data, identify patterns, adapt to new inputs, and make decisions with minimal human intervention. Modern AI encompasses various subfields including machine learning, natural language processing, computer vision, and robotics. The goal of AI ranges from creating systems that can perform specific tasks intelligently (narrow AI) to the theoretical pursuit of general AI that could potentially match or exceed human cognitive abilities across all domains. AI has become increasingly prevalent in everyday applications including voice assistants, recommendation systems, autonomous vehicles, and medical diagnosis tools.",
        "trans_Question": "wɒt ɪz ðə tɜ́rm fɔr ðə brǽntʃ əv kəmpjúwtər sájəns ðət éjmz tə krijéjt sɪ́stəmz kéjpəbəl əv pərfɔ́rmɪŋ tǽsks ðət tɪ́pɪkəlij rəkwájər hjúwmən ɪntɛ́lɪdʒəns, sʌtʃ æz vɪ́ʒəwəl pərsɛ́pʃən, spíjtʃ rɛ̀kəɡnɪ́ʃən, dəsɪ́ʒən-méjkɪŋ, ənd lǽŋɡwədʒ trænsléjʃən?",
        "trans_RightAnswer": "ɑ̀rtɪfɪ́ʃəl ɪntɛ́lɪdʒəns",
        "trans_WrongAnswers": [
            "kɒ̀mpjuwtéjʃənəl lɪŋɡwɪ́stɪks",
            "məʃíjn ɑ́rkɪtɛ̀ktʃər",
            "sɪ́stəm ɔtəméjʃən",
            "kɒ́ɡnɪtɪv kəmpjúwtɪŋ",
            "ǽlɡərɪ̀ðəmɪk prɒ́sɛsɪŋ"
        ],
        "trans_Explanation": "ɑ̀rtɪfɪ́ʃəl ɪntɛ́lɪdʒəns rəfɜ́rz tə ðə dəvɛ́ləpmənt əv kəmpjúwtər sɪ́stəmz ðət kən pərfɔ́rm tǽsks ðət wʊd nɔ́rməlij rəkwájər hjúwmən ɪntɛ́lɪdʒəns. ʌ̀nlájk trədɪ́ʃənəl prówɡræ̀mɪŋ wɛ́ər əksplɪ́sɪt ɪnstrʌ́kʃənz ɑr prəvájdɪd fɔr ɛvərij ǽkʃən, AI sɪ́stəmz ɑr dəzájnd tə lɜ́rn frəm déjtə, ajdɛ́ntɪfàj pǽtərnz, ədǽpt tə núw ɪ́npʊ̀ts, ənd méjk dəsɪ́ʒənz wɪð mɪ́nɪməl hjúwmən ɪ̀ntərvɛ́nʃən. mɒ́dərn AI ɛnkʌ́mpəsɪz vɛ́ərijəs sʌ́bfìjldz ɪnklúwdɪŋ məʃíjn lɜ́rnɪŋ, nǽtʃərəl lǽŋɡwədʒ prɒ́sɛsɪŋ, kəmpjúwtər vɪ́ʒən, ənd ròwbɒ́tɪks. ðə ɡówl əv AI réjndʒɪz frəm krijéjtɪŋ sɪ́stəmz ðət kən pərfɔ́rm spəsɪ́fɪk tǽsks ɪntɛ́lɪdʒəntlij (nǽrow AI) tə ðə θìjərɛ́tɪkəl pərsúwt əv dʒɛ́nərəl AI ðət kʊ́d pətɛ́nʃəlij mǽtʃ ɔr əksíjd hjúwmən kɒ́ɡnɪtɪv əbɪ́lɪtìjz əkrɔ́s ɔl dowméjnz. AI həz bəkʌ́m ɪnkríjsɪŋɡlij prɛ́vələnt ɪn ɛ́vrijdéj æ̀plɪkéjʃənz ɪnklúwdɪŋ vɔ́js əsɪ́stənts, rɛ̀kəməndéjʃən sɪ́stəmz, ɔtɒ́nəməs víjhəkəlz, ənd mɛ́dɪkəl dàjəɡnówsɪs túwlz."
    },
    {
        "Question": "Which field of artificial intelligence is specifically focused on enabling computers to understand, interpret, and generate human language in a way that is both meaningful and useful?",
        "RightAnswer": "Natural Language Processing",
        "WrongAnswers": [
            "Algorithm Optimization",
            "Graphical Rendering",
            "Symbolic Logic",
            "Database Querying",
            "Network Topology"
        ],
        "Explanation": "Natural Language Processing (NLP) is a branch of artificial intelligence that focuses on the interaction between computers and human language. It involves developing methods and systems that allow computers to understand, interpret, generate, and respond to human language in a way that is both meaningful and useful. NLP combines computational linguistics with statistical, machine learning, and deep learning models to process and analyze large amounts of natural language data. This field enables applications like machine translation, sentiment analysis, chatbots, voice assistants, text summarization, and information extraction. The ultimate goal of NLP is to bridge the gap between human communication and computer understanding, making technology more accessible and intuitive for everyday users. Recent advances in deep learning have significantly improved NLP systems, allowing for more nuanced understanding of context, ambiguity, and the subtleties of human language.",
        "trans_Question": "wɪ́tʃ fíjld əv ɑ̀rtɪfɪ́ʃəl ɪntɛ́lɪdʒəns ɪz spəsɪ́fɪklij fówkəst ɒn ɛnéjbəlɪŋ kəmpjúwtərz tə ʌ̀ndərstǽnd, ɪntɜ́rprət, ənd dʒɛ́nərèjt hjúwmən lǽŋɡwədʒ ɪn ə wej ðət ɪz bówθ míjnɪŋfəl ənd júwsfəl?",
        "trans_RightAnswer": "nǽtʃərəl lǽŋɡwədʒ prɒ́sɛsɪŋ",
        "trans_WrongAnswers": [
            "ǽlɡərɪ̀ðəm ɒptɪmɪzéjʃən",
            "ɡrǽfɪkəl rɛ́ndərɪŋ",
            "sɪmbɒ́lɪk lɒ́dʒɪk",
            "déjtəbèjs kwɛ́ərijɪŋ",
            "nɛ́twɜ̀rk təpɔ́lədʒij"
        ],
        "trans_Explanation": "nǽtʃərəl lǽŋɡwədʒ prɒ́sɛsɪŋ (NLP) ɪz ə brǽntʃ əv ɑ̀rtɪfɪ́ʃəl ɪntɛ́lɪdʒəns ðət fówkəsɪz ɒn ðə ɪ̀ntərǽkʃən bijtwíjn kəmpjúwtərz ənd hjúwmən lǽŋɡwədʒ. ɪt ɪnvɒ́lvz dəvɛ́ləpɪŋ mɛ́θədz ənd sɪ́stəmz ðət əláw kəmpjúwtərz tə ʌ̀ndərstǽnd, ɪntɜ́rprət, dʒɛ́nərèjt, ənd rəspɒ́nd tə hjúwmən lǽŋɡwədʒ ɪn ə wej ðət ɪz bówθ míjnɪŋfəl ənd júwsfəl. NLP kəmbájnz kɒ̀mpjuwtéjʃənəl lɪŋɡwɪ́stɪks wɪð stətɪ́stɪkəl, məʃíjn lɜ́rnɪŋ, ənd díjp lɜ́rnɪŋ mɒ́dəlz tə prɒ́sɛs ənd ǽnəlàjz lɑ́rdʒ əmáwnts əv nǽtʃərəl lǽŋɡwədʒ déjtə. ðɪs fíjld ɛnéjbəlz æ̀plɪkéjʃənz lájk məʃíjn trænsléjʃən, sɛ́ntɪmənt ənǽlɪsɪs, tʃǽtbɔts, vɔ́js əsɪ́stənts, tɛ́kst sʌ̀mərɪzéjʃən, ənd ɪnfərméjʃən əkstrǽkʃən. ðə ʌ́ltɪmət ɡówl əv NLP ɪz tə brɪ́dʒ ðə ɡǽp bijtwíjn hjúwmən kəmjùwnɪkéjʃən ənd kəmpjúwtər ʌ̀ndərstǽndɪŋ, méjkɪŋ tɛknɒ́lədʒij mɔr æksɛ́sɪbəl ənd ɪntúwɪtɪv fɔr ɛ́vrijdéj júwzərz. ríjsənt ədvǽnsɪz ɪn díjp lɜ́rnɪŋ həv sɪɡnɪ́fɪkəntlij ɪmprúwvd NLP sɪ́stəmz, əláwɪŋ fɔr mɔr njúwɑnst ʌ̀ndərstǽndɪŋ əv kɒ́ntɛkst, æ̀mbɪɡjúwɪtij, ənd ðə sʌ́təltijz əv hjúwmən lǽŋɡwədʒ."
    },
    {
        "Question": "Which branch of computer science focuses on enabling computers to interpret and understand visual information from the real world, including tasks like object recognition, scene understanding, and image processing?",
        "RightAnswer": "Computer Vision",
        "WrongAnswers": [
            "Database Systems",
            "Network Security",
            "Compiler Design",
            "Operating Systems",
            "Quantum Computing"
        ],
        "Explanation": "Computer Vision is the field of computer science concerned with teaching computers to 'see' and interpret visual information from the world. It involves developing algorithms and systems that can process, analyze, and understand digital images and videos in the same way that humans do. Computer Vision enables machines to extract meaningful information from visual data, recognize patterns, identify objects, track movements, and make decisions based on visual inputs. The discipline combines elements of artificial intelligence, machine learning, and image processing to solve complex problems like facial recognition, autonomous driving, medical image analysis, and augmented reality. Rather than merely storing or displaying images, Computer Vision aims to comprehend the content and context of visual scenes, bridging the gap between the physical world we perceive and the digital world computers operate in.",
        "trans_Question": "wɪ́tʃ brǽntʃ əv kəmpjúwtər sájəns fówkəsɪz ɒn ɛnéjbəlɪŋ kəmpjúwtərz tə ɪntɜ́rprət ənd ʌ̀ndərstǽnd vɪ́ʒəwəl ɪnfərméjʃən frəm ðə ríjəl wɜ́rld, ɪnklúwdɪŋ tǽsks lájk ɒ́bdʒəkt rɛ̀kəɡnɪ́ʃən, síjn ʌ̀ndərstǽndɪŋ, ənd ɪ́mɪdʒ prɒ́sɛsɪŋ?",
        "trans_RightAnswer": "kəmpjúwtər vɪ́ʒən",
        "trans_WrongAnswers": [
            "déjtəbèjs sɪ́stəmz",
            "nɛ́twɜ̀rk səkjʊ́rɪtij",
            "kəmpájlər dəzájn",
            "ɒ́pərèjtɪŋ sɪ́stəmz",
            "kwɑ́ntəm kəmpjúwtɪŋ"
        ],
        "trans_Explanation": "kəmpjúwtər vɪ́ʒən ɪz ðə fíjld əv kəmpjúwtər sájəns kənsɜ́rnd wɪð tíjtʃɪŋ kəmpjúwtərz tə 'síj' ənd ɪntɜ́rprət vɪ́ʒəwəl ɪnfərméjʃən frəm ðə wɜ́rld. ɪt ɪnvɒ́lvz dəvɛ́ləpɪŋ ǽlɡərɪ̀ðəmz ənd sɪ́stəmz ðət kən prɒ́sɛs, ǽnəlàjz, ənd ʌ̀ndərstǽnd dɪ́dʒɪtəl ɪ́mɪdʒɪz ənd vɪ́dijowz ɪn ðə séjm wej ðət hjúwmənz dúw. kəmpjúwtər vɪ́ʒən ɛnéjbəlz məʃíjnz tə ɛ́kstrəkt míjnɪŋfəl ɪnfərméjʃən frəm vɪ́ʒəwəl déjtə, rɛ́kəɡnàjz pǽtərnz, ajdɛ́ntɪfàj ɒ́bdʒɛkts, trǽk múwvmənts, ənd méjk dəsɪ́ʒənz béjst ɒn vɪ́ʒəwəl ɪ́npʊ̀ts. ðə dɪ́sɪplɪn kəmbájnz ɛ́ləmənts əv ɑ̀rtɪfɪ́ʃəl ɪntɛ́lɪdʒəns, məʃíjn lɜ́rnɪŋ, ənd ɪ́mɪdʒ prɒ́sɛsɪŋ tə sɒ́lv kɒ́mplɛks prɒ́bləmz lájk féjʃəl rɛ̀kəɡnɪ́ʃən, ɔtɒ́nəməs drájvɪŋ, mɛ́dɪkəl ɪ́mɪdʒ ənǽlɪsɪs, ənd ɒɡmɛ́ntɪd rìjǽlɪtij. rǽðər ðʌn mɪ́ərlij stɔ́rɪŋ ɔr dɪspléjɪŋ ɪ́mɪdʒɪz, kəmpjúwtər vɪ́ʒən éjmz tə kɒ̀mprəhɛ́nd ðə kɒ́ntənt ənd kɒ́ntɛkst əv vɪ́ʒəwəl síjnz, brɪ́dʒɪŋ ðə ɡǽp bijtwíjn ðə fɪ́zɪkəl wɜ́rld wij pərsíjv ənd ðə dɪ́dʒɪtəl wɜ́rld kəmpjúwtərz ɒ́pərèjt ɪn."
    },
    {
        "Question": "Which machine learning paradigm is characterized by an agent learning to make decisions by taking actions in an environment to maximize cumulative rewards, often through trial and error?",
        "RightAnswer": "Reinforcement Learning",
        "WrongAnswers": [
            "Supervised Learning",
            "Unsupervised Learning",
            "Transfer Learning",
            "Federated Learning",
            "Ensemble Learning"
        ],
        "Explanation": "Reinforcement Learning is a computational approach to learning where an agent learns to behave optimally in an environment by performing actions and observing the results. Unlike supervised learning, where the system learns from labeled examples, reinforcement learning involves discovering which actions yield the greatest rewards by interacting with the environment. The agent receives feedback in the form of rewards or penalties and adapts its strategy to maximize long-term rewards. This trial-and-error approach mirrors how humans and animals naturally learn, making it particularly effective for sequential decision-making problems like game playing, robotics control, and resource management. The agent must balance exploration of unknown options with exploitation of known successful strategies, a fundamental challenge known as the exploration-exploitation dilemma. Popular reinforcement learning techniques include Q-learning, policy gradients, and deep reinforcement learning, which combines neural networks with reinforcement learning principles.",
        "trans_Question": "wɪ́tʃ məʃíjn lɜ́rnɪŋ pǽrədàjm ɪz kǽrəktərajzd baj ən éjdʒənt lɜ́rnɪŋ tə méjk dəsɪ́ʒənz baj téjkɪŋ ǽkʃənz ɪn ən ənvájərənmənt tə mǽksɪmàjz kjúwmjələtɪv rəwɔ́rdz, ɔ́fən θrúw trájəl ənd ɛ́ərər?",
        "trans_RightAnswer": "rìjɪnfɔ́rsmənt lɜ́rnɪŋ",
        "trans_WrongAnswers": [
            "súwpərvàjzd lɜ́rnɪŋ",
            "ʌ̀nsúwpərvàjzd lɜ́rnɪŋ",
            "trǽnsfər lɜ́rnɪŋ",
            "fɛ́dərèjtɪd lɜ́rnɪŋ",
            "ɒnsɒ́mbəl lɜ́rnɪŋ"
        ],
        "trans_Explanation": "rìjɪnfɔ́rsmənt lɜ́rnɪŋ ɪz ə kɒ̀mpjuwtéjʃənəl əprówtʃ tə lɜ́rnɪŋ wɛ́ər ən éjdʒənt lɜ́rnz tə bəhéjv ɒ́ptɪməlij ɪn ən ənvájərənmənt baj pərfɔ́rmɪŋ ǽkʃənz ənd əbzɜ́rvɪŋ ðə rəzʌ́lts. ʌ̀nlájk súwpərvàjzd lɜ́rnɪŋ, wɛ́ər ðə sɪ́stəm lɜ́rnz frəm léjbəld əɡzǽmpəlz, rìjɪnfɔ́rsmənt lɜ́rnɪŋ ɪnvɒ́lvz dɪskʌ́vərɪŋ wɪ́tʃ ǽkʃənz jíjld ðə ɡréjtəst rəwɔ́rdz baj ɪ̀ntərǽktɪŋ wɪð ðə ənvájərənmənt. ðə éjdʒənt rəsíjvz fíjdbæ̀k ɪn ðə fɔ́rm əv rəwɔ́rdz ɔr pɛ́nəltijz ənd ədǽpts ɪts strǽtədʒij tə mǽksɪmàjz lɔ́ŋ-tɜ́rm rəwɔ́rdz. ðɪs trájəl-ənd-ɛ́ərər əprówtʃ mɪ́ərərz háw hjúwmənz ənd ǽnɪməlz nǽtʃərəlij lɜ́rn, méjkɪŋ ɪt pərtɪ́kjələrlij əféktɪv fɔr səkwɛ́nʃəl dəsɪ́ʒən-méjkɪŋ prɒ́bləmz lájk ɡéjm pléjɪŋ, ròwbɒ́tɪks kəntrówl, ənd ríjsɔrs mǽnədʒmənt. ðə éjdʒənt mʌst bǽləns ɛ̀kspləréjʃən əv ʌ̀nnówn ɒ́pʃənz wɪð ɛ̀ksplɔ̀jtéjʃən əv nówn səksɛ́sfəl strǽtədʒijz, ə fʌ̀ndəmɛ́ntəl tʃǽləndʒ nówn æz ðə ɛ̀kspləréjʃən-ɛ̀ksplɔ̀jtéjʃən dajlɛ́mə. pɒ́pjələr rìjɪnfɔ́rsmənt lɜ́rnɪŋ tɛkníjks ɪnklúwd q-lɜ́rnɪŋ, pɒ́lɪsij ɡréjdijənts, ənd díjp rìjɪnfɔ́rsmənt lɜ́rnɪŋ, wɪ́tʃ kəmbájnz nʊ́rəl nɛ́twɜ̀rks wɪð rìjɪnfɔ́rsmənt lɜ́rnɪŋ prɪ́nsɪpəlz."
    },
    {
        "Question": "Which machine learning approach requires labeled training data where inputs are paired with their corresponding correct outputs?",
        "RightAnswer": "Supervised Learning",
        "WrongAnswers": [
            "Reinforcement Learning",
            "Unsupervised Learning",
            "Self-Organizing Learning",
            "Transfer Learning",
            "Semi-Structured Learning"
        ],
        "Explanation": "Supervised Learning is a fundamental approach in machine learning where an algorithm learns from a training dataset that contains examples with known outcomes or labels. Think of it like learning with a teacher who provides both the questions and correct answers. The algorithm studies these input-output pairs to discover patterns and relationships, ultimately developing the ability to make predictions on new, unseen data. For instance, when training an email spam filter, the system learns from thousands of emails already classified as 'spam' or 'not spam' to develop rules for classifying future emails. What distinguishes supervised learning from other approaches is this explicit feedback loop with labeled examples, allowing the system to measure its accuracy and adjust accordingly until it can reliably predict outcomes for new inputs. Common supervised learning tasks include classification, where outputs are categorical labels, and regression, where outputs are continuous values.",
        "trans_Question": "wɪ́tʃ məʃíjn lɜ́rnɪŋ əprówtʃ rəkwájərz léjbəld tréjnɪŋ déjtə wɛ́ər ɪ́npʊ̀ts ɑr pɛ́ərd wɪð ðɛər kɔ̀rəspɒ́ndɪŋ kərɛ́kt áwtpʊ̀ts?",
        "trans_RightAnswer": "súwpərvàjzd lɜ́rnɪŋ",
        "trans_WrongAnswers": [
            "rìjɪnfɔ́rsmənt lɜ́rnɪŋ",
            "ʌ̀nsúwpərvàjzd lɜ́rnɪŋ",
            "sɛ́lf-ɔ́rɡənàjzɪŋ lɜ́rnɪŋ",
            "trǽnsfər lɜ́rnɪŋ",
            "sɛ́maj-strʌ́ktʃərd lɜ́rnɪŋ"
        ],
        "trans_Explanation": "súwpərvàjzd lɜ́rnɪŋ ɪz ə fʌ̀ndəmɛ́ntəl əprówtʃ ɪn məʃíjn lɜ́rnɪŋ wɛ́ər ən ǽlɡərɪ̀ðəm lɜ́rnz frəm ə tréjnɪŋ déjtəsɛ̀t ðət kəntéjnz əɡzǽmpəlz wɪð nówn áwtkʌ̀mz ɔr léjbəlz. θɪ́ŋk əv ɪt lájk lɜ́rnɪŋ wɪð ə tíjtʃər huw prəvájdz bówθ ðə kwɛ́stʃənz ənd kərɛ́kt ǽnsərz. ðə ǽlɡərɪ̀ðəm stʌ́dijz ðijz ɪ́npʊ̀t-áwtpʊ̀t pɛ́ərz tə dɪskʌ́vər pǽtərnz ənd rəléjʃənʃɪ̀ps, ʌ́ltɪmətlij dəvɛ́ləpɪŋ ðə əbɪ́lɪtij tə méjk prədɪ́kʃənz ɒn núw, ʌ̀nsíjn déjtə. fɔr ɪ́nstəns, wɛ́n tréjnɪŋ ən íjmejl spǽm fɪ́ltər, ðə sɪ́stəm lɜ́rnz frəm θáwzəndz əv íjmejlz ɔ̀lrɛ́dij klǽsɪfàjd æz 'spǽm' ɔr 'nɒt spǽm' tə dəvɛ́ləp rúwlz fɔr klǽsɪfàjɪŋ fjúwtʃər íjmejlz. wɒt dɪstɪ́ŋɡwɪʃɪz súwpərvàjzd lɜ́rnɪŋ frəm ʌ́ðər əprówtʃɪz ɪz ðɪs əksplɪ́sɪt fíjdbæ̀k lúwp wɪð léjbəld əɡzǽmpəlz, əláwɪŋ ðə sɪ́stəm tə mɛ́ʒər ɪts ǽkjərəsij ənd ədʒʌ́st əkɔ́rdɪŋlij əntɪ́l ɪt kən rəlájəblij prədɪ́kt áwtkʌ̀mz fɔr núw ɪ́npʊ̀ts. kɒ́mən súwpərvàjzd lɜ́rnɪŋ tǽsks ɪnklúwd klæ̀sɪfɪkéjʃən, wɛ́ər áwtpʊ̀ts ɑr kæ̀təɡɑ́rɪkəl léjbəlz, ənd rəɡrɛ́ʃən, wɛ́ər áwtpʊ̀ts ɑr kəntɪ́njuwəs vǽljuwz."
    },
    {
        "Question": "Which machine learning paradigm discovers patterns and structures in data without requiring labeled examples or specific target outputs?",
        "RightAnswer": "Unsupervised Learning",
        "WrongAnswers": [
            "Reinforcement Learning",
            "Supervised Learning",
            "Transfer Learning",
            "Semi-Supervised Learning",
            "Federated Learning"
        ],
        "Explanation": "Unsupervised Learning is a fundamental approach in machine learning where algorithms work with data that has no predefined labels or outcomes. Unlike supervised learning, which requires labeled training examples, unsupervised learning attempts to identify inherent structures, patterns, or relationships within data on its own. Common applications include clustering similar data points together, reducing dimensionality of complex datasets, detecting anomalies, and discovering hidden patterns. For example, an unsupervised algorithm might group customers with similar purchasing behaviors without being told in advance what those groups should be. This approach is particularly valuable when working with large volumes of unlabeled data where manual labeling would be impractical or when researchers want to discover previously unknown patterns without imposing preconceived categories on the data. Popular unsupervised learning algorithms include k-means clustering, hierarchical clustering, principal component analysis, and various types of neural network-based approaches such as autoencoders.",
        "trans_Question": "wɪ́tʃ məʃíjn lɜ́rnɪŋ pǽrədàjm dɪskʌ́vərz pǽtərnz ənd strʌ́ktʃərz ɪn déjtə wɪðáwt rijkwájərɪŋ léjbəld əɡzǽmpəlz ɔr spəsɪ́fɪk tɑ́rɡət áwtpʊ̀ts?",
        "trans_RightAnswer": "ʌ̀nsúwpərvàjzd lɜ́rnɪŋ",
        "trans_WrongAnswers": [
            "rìjɪnfɔ́rsmənt lɜ́rnɪŋ",
            "súwpərvàjzd lɜ́rnɪŋ",
            "trǽnsfər lɜ́rnɪŋ",
            "sɛ́maj-súwpərvàjzd lɜ́rnɪŋ",
            "fɛ́dərèjtɪd lɜ́rnɪŋ"
        ],
        "trans_Explanation": "ʌ̀nsúwpərvàjzd lɜ́rnɪŋ ɪz ə fʌ̀ndəmɛ́ntəl əprówtʃ ɪn məʃíjn lɜ́rnɪŋ wɛ́ər ǽlɡərɪ̀ðəmz wɜ́rk wɪð déjtə ðət həz now prìjdəfájnd léjbəlz ɔr áwtkʌ̀mz. ʌ̀nlájk súwpərvàjzd lɜ́rnɪŋ, wɪ́tʃ rəkwájərz léjbəld tréjnɪŋ əɡzǽmpəlz, ʌ̀nsúwpərvàjzd lɜ́rnɪŋ ətɛ́mpts tə ajdɛ́ntɪfàj ɪnhɛ́ərənt strʌ́ktʃərz, pǽtərnz, ɔr rəléjʃənʃɪ̀ps wɪðɪ́n déjtə ɒn ɪts ówn. kɒ́mən æ̀plɪkéjʃənz ɪnklúwd klʌ́stərɪŋ sɪ́mɪlər déjtə pɔ́jnts təɡɛ́ðər, rədjúwsɪŋ dajmɛ̀nʃənǽlɪtij əv kɒ́mplɛks déjtəsɛ̀ts, dətɛ́ktɪŋ ənɒ́məlijz, ənd dɪskʌ́vərɪŋ hɪ́dən pǽtərnz. fɔr əɡzǽmpəl, ən ʌ̀nsúwpərvàjzd ǽlɡərɪ̀ðəm majt ɡrúwp kʌ́stəmərz wɪð sɪ́mɪlər pɜ́rtʃəsɪŋ bəhéjvjərz wɪðáwt bíjɪŋ tówld ɪn ədvǽns wɒt ðowz ɡrúwps ʃʊd bij. ðɪs əprówtʃ ɪz pərtɪ́kjələrlij vǽljəbəl wɛ́n wɜ́rkɪŋ wɪð lɑ́rdʒ vɒ́ljuwmz əv ʌ̀nléjbəld déjtə wɛ́ər mǽnjuwəl léjbəlɪŋ wʊd bij ɪ̀mprǽktɪkəl ɔr wɛ́n ríjsərtʃərz wɒ́nt tə dɪskʌ́vər príjvijəslij ʌ̀nnówn pǽtərnz wɪðáwt ɪ̀mpówzɪŋ prìjkənsíjvd kǽtəɡɔ̀rijz ɒn ðə déjtə. pɒ́pjələr ʌ̀nsúwpərvàjzd lɜ́rnɪŋ ǽlɡərɪ̀ðəmz ɪnklúwd k-míjnz klʌ́stərɪŋ, hàjərɑ́rkɪkəl klʌ́stərɪŋ, prɪ́nsɪpəl kəmpównənt ənǽlɪsɪs, ənd vɛ́ərijəs tájps əv nʊ́rəl nɛ́twɜ̀rk-béjst əprówtʃɪz sʌtʃ æz ɔ̀towənkówdərz."
    },
    {
        "Question": "When a machine learning model is trained using a small amount of labeled data combined with a large pool of unlabeled data to improve its performance, which learning approach is being implemented?",
        "RightAnswer": "Semi-Supervised Learning",
        "WrongAnswers": [
            "Reinforcement Learning",
            "Transfer Learning",
            "Fully Supervised Learning",
            "Self-Supervised Learning",
            "Unsupervised Feature Learning"
        ],
        "Explanation": "Semi-Supervised Learning is a machine learning approach that bridges the gap between supervised and unsupervised learning. It leverages a small amount of labeled data alongside a much larger amount of unlabeled data during the training process. This approach is particularly valuable in real-world scenarios where labeled data is expensive, time-consuming, or difficult to obtain, while unlabeled data is abundant. The core principle is that the underlying structure revealed by the unlabeled data can help the model generate better decision boundaries. Common techniques in semi-supervised learning include self-training (where the model's most confident predictions on unlabeled data are iteratively added to the training set), co-training (using multiple views of the data), and graph-based methods (leveraging relationships between data points). This approach has proven effective in various applications including image classification, natural language processing, and medical diagnosis, often achieving performance comparable to fully supervised methods while requiring significantly less labeled data.",
        "trans_Question": "wɛ́n ə məʃíjn lɜ́rnɪŋ mɒ́dəl ɪz tréjnd júwzɪŋ ə smɔ́l əmáwnt əv léjbəld déjtə kəmbájnd wɪð ə lɑ́rdʒ púwl əv ʌ̀nléjbəld déjtə tə ɪmprúwv ɪts pərfɔ́rməns, wɪ́tʃ lɜ́rnɪŋ əprówtʃ ɪz bíjɪŋ ɪ́mpləmɛ̀ntɪd?",
        "trans_RightAnswer": "sɛ́maj-súwpərvàjzd lɜ́rnɪŋ",
        "trans_WrongAnswers": [
            "rìjɪnfɔ́rsmənt lɜ́rnɪŋ",
            "trǽnsfər lɜ́rnɪŋ",
            "fʊ́lij súwpərvàjzd lɜ́rnɪŋ",
            "sɛ́lf-súwpərvàjzd lɜ́rnɪŋ",
            "ʌ̀nsúwpərvàjzd fíjtʃər lɜ́rnɪŋ"
        ],
        "trans_Explanation": "sɛ́maj-súwpərvàjzd lɜ́rnɪŋ ɪz ə məʃíjn lɜ́rnɪŋ əprówtʃ ðət brɪ́dʒɪz ðə ɡǽp bijtwíjn súwpərvàjzd ənd ʌ̀nsúwpərvàjzd lɜ́rnɪŋ. ɪt lɛ́vərɪdʒɪz ə smɔ́l əmáwnt əv léjbəld déjtə əlɔ́ŋsájd ə mʌtʃ lɑ́rdʒər əmáwnt əv ʌ̀nléjbəld déjtə dʊ́rɪŋ ðə tréjnɪŋ prɒ́sɛs. ðɪs əprówtʃ ɪz pərtɪ́kjələrlij vǽljəbəl ɪn ríjəl-wɜ́rld sənɛ́ərijowz wɛ́ər léjbəld déjtə ɪz əkspɛ́nsɪv, tájm-kənsúwmɪŋ, ɔr dɪ́fɪkəlt tə əbtéjn, wájl ʌ̀nléjbəld déjtə ɪz əbʌ́ndənt. ðə kɔ́r prɪ́nsɪpəl ɪz ðət ðə ʌ̀ndərlájɪŋ strʌ́ktʃər rəvíjld baj ðə ʌ̀nléjbəld déjtə kən hɛ́lp ðə mɒ́dəl dʒɛ́nərèjt bɛ́tər dəsɪ́ʒən báwndərijz. kɒ́mən tɛkníjks ɪn sɛ́maj-súwpərvàjzd lɜ́rnɪŋ ɪnklúwd sɛ́lf-tréjnɪŋ (wɛ́ər ðə mɒ́dəl'z mówst kɒ́nfɪdənt prədɪ́kʃənz ɒn ʌ̀nléjbəld déjtə ɑr ɪ́tərətɪvlij ǽdɪd tə ðə tréjnɪŋ sɛ́t), ków-tréjnɪŋ (júwzɪŋ mʌ́ltɪpəl vjúwz əv ðə déjtə), ənd ɡrǽf-béjst mɛ́θədz (lɛ́vərɪdʒɪŋ rəléjʃənʃɪ̀ps bijtwíjn déjtə pɔ́jnts). ðɪs əprówtʃ həz prúwvən əféktɪv ɪn vɛ́ərijəs æ̀plɪkéjʃənz ɪnklúwdɪŋ ɪ́mɪdʒ klæ̀sɪfɪkéjʃən, nǽtʃərəl lǽŋɡwədʒ prɒ́sɛsɪŋ, ənd mɛ́dɪkəl dàjəɡnówsɪs, ɔ́fən ətʃíjvɪŋ pərfɔ́rməns kɒ́mpərəbəl tə fʊ́lij súwpərvàjzd mɛ́θədz wájl rijkwájərɪŋ sɪɡnɪ́fɪkəntlij lɛ́s léjbəld déjtə."
    },
    {
        "Question": "In machine learning, what is the process of selecting, transforming, or combining features from raw data to create more meaningful representations that enhance model performance?",
        "RightAnswer": "Feature Extraction",
        "WrongAnswers": [
            "Data Normalization",
            "Model Optimization",
            "Pattern Recognition",
            "Dimension Enrichment",
            "Information Encoding"
        ],
        "Explanation": "Feature Extraction is a fundamental technique in computer science and machine learning where we derive new, more informative representations from raw data. Instead of using all available data directly, feature extraction identifies and isolates the most relevant patterns or characteristics that best represent the underlying information. For example, when processing images, rather than using raw pixel values, we might extract edges, textures, or shapes. In text analysis, instead of using individual words, we might extract semantic themes or sentiment. The goal is to reduce dimensionality while preserving or enhancing the information that's most useful for the task at hand, making models more efficient, accurate, and sometimes more interpretable. Feature extraction differs from feature selection, which only chooses existing features rather than creating new ones. Common approaches include Principal Component Analysis, which finds linear combinations of features that capture maximum variance, and various neural network architectures that can learn complex feature representations automatically.",
        "trans_Question": "ɪn məʃíjn lɜ́rnɪŋ, wɒt ɪz ðə prɒ́sɛs əv səlɛ́ktɪŋ, trænsfɔ́rmɪŋ, ɔr kəmbájnɪŋ fíjtʃərz frəm rɔ́ déjtə tə krijéjt mɔr míjnɪŋfəl rɛ̀prəzəntéjʃənz ðət ənhǽns mɒ́dəl pərfɔ́rməns?",
        "trans_RightAnswer": "fíjtʃər əkstrǽkʃən",
        "trans_WrongAnswers": [
            "déjtə nɔ̀rməlɪzéjʃən",
            "mɒ́dəl ɒptɪmɪzéjʃən",
            "pǽtərn rɛ̀kəɡnɪ́ʃən",
            "dajmɛ́nʃən ɛnrɪ́tʃmənt",
            "ɪnfərméjʃən ɛnkówdɪŋ"
        ],
        "trans_Explanation": "fíjtʃər əkstrǽkʃən ɪz ə fʌ̀ndəmɛ́ntəl tɛkníjk ɪn kəmpjúwtər sájəns ənd məʃíjn lɜ́rnɪŋ wɛ́ər wij dərájv núw, mɔr ɪnfɔ́rmətɪv rɛ̀prəzəntéjʃənz frəm rɔ́ déjtə. ɪnstɛ́d əv júwzɪŋ ɔl əvéjləbəl déjtə dɪərɛ́klij, fíjtʃər əkstrǽkʃən ajdɛ́ntɪfàjz ənd ájsəlèjts ðə mówst rɛ́ləvənt pǽtərnz ɔr kæ̀rəktərɪ́stɪks ðət bɛ́st rɛ̀prəzɛ́nt ðə ʌ̀ndərlájɪŋ ɪnfərméjʃən. fɔr əɡzǽmpəl, wɛ́n prɒ́sɛsɪŋ ɪ́mɪdʒɪz, rǽðər ðʌn júwzɪŋ rɔ́ pɪ́ksəl vǽljuwz, wij majt ɛ́kstrəkt ɛ́dʒɪz, tɛ́kstʃərz, ɔr ʃéjps. ɪn tɛ́kst ənǽlɪsɪs, ɪnstɛ́d əv júwzɪŋ ɪndɪvɪ́dʒəwəl wɜ́rdz, wij majt ɛ́kstrəkt səmǽntɪk θíjmz ɔr sɛ́ntɪmənt. ðə ɡówl ɪz tə rədjúws dajmɛ̀nʃənǽlɪtij wájl prəzɜ́rvɪŋ ɔr ɛnhǽnsɪŋ ðə ɪnfərméjʃən ðət's mówst júwsfəl fɔr ðə tǽsk æt hǽnd, méjkɪŋ mɒ́dəlz mɔr əfɪ́ʃənt, ǽkjərət, ənd sʌ́mtàjmz mɔr ɪntɜ́rprətəbəl. fíjtʃər əkstrǽkʃən dɪ́fərz frəm fíjtʃər səlɛ́kʃən, wɪ́tʃ ównlij tʃúwzɪz əɡzɪ́stɪŋ fíjtʃərz rǽðər ðʌn krijéjtɪŋ núw wʌ́nz. kɒ́mən əprówtʃɪz ɪnklúwd prɪ́nsɪpəl kəmpównənt ənǽlɪsɪs, wɪ́tʃ fájndz lɪ́nijər kɒ̀mbɪnéjʃənz əv fíjtʃərz ðət kǽptʃər mǽksɪməm vɛ́ərijəns, ənd vɛ́ərijəs nʊ́rəl nɛ́twɜ̀rk ɑ́rkɪtɛ̀ktʃərz ðət kən lɜ́rn kɒ́mplɛks fíjtʃər rɛ̀prəzəntéjʃənz ɔ̀təmǽtɪklij."
    },
    {
        "Question": "Which fundamental process in data science involves cleaning, transforming, and organizing raw data before it can be effectively used in machine learning algorithms?",
        "RightAnswer": "Data Preprocessing",
        "WrongAnswers": [
            "Data Warehousing",
            "Algorithm Training",
            "Model Deployment",
            "Feature Engineering",
            "Data Visualization"
        ],
        "Explanation": "Data Preprocessing is a crucial first step in the data science pipeline that transforms raw, messy data into a clean, structured format suitable for analysis. It encompasses a variety of techniques including handling missing values, removing duplicates, standardizing formats, normalizing values, and encoding categorical variables. Think of it as preparing ingredients before cooking a meal—data scientists must first clean, sort, and prepare their data before they can extract meaningful insights or build effective models. Without proper preprocessing, algorithms may produce inaccurate or misleading results due to outliers, inconsistencies, or irrelevant information in the dataset. This foundational process typically consumes a significant portion of a data scientist's workflow but is essential for ensuring the quality and reliability of subsequent analyses and predictions.",
        "trans_Question": "wɪ́tʃ fʌ̀ndəmɛ́ntəl prɒ́sɛs ɪn déjtə sájəns ɪnvɒ́lvz klíjnɪŋ, trænsfɔ́rmɪŋ, ənd ɔ́rɡənàjzɪŋ rɔ́ déjtə bəfɔ́r ɪt kən bij əfɛ́ktɪvlij júwzd ɪn məʃíjn lɜ́rnɪŋ ǽlɡərɪ̀ðəmz?",
        "trans_RightAnswer": "déjtə prijprɒ́sɛsɪŋ",
        "trans_WrongAnswers": [
            "déjtə wɛ́ərhàwzɪŋ",
            "ǽlɡərɪ̀ðəm tréjnɪŋ",
            "mɒ́dəl dəplɔ́jmənt",
            "fíjtʃər ɛ̀ndʒɪnɪ́ərɪŋ",
            "déjtə vɪ̀ʒwəlɪzéjʃən"
        ],
        "trans_Explanation": "déjtə prijprɒ́sɛsɪŋ ɪz ə krúwʃəl fɜ́rst stɛ́p ɪn ðə déjtə sájəns pájplàjn ðət trænsfɔ́rmz rɔ́, mɛ́sij déjtə ɪntə ə klíjn, strʌ́ktʃərd fɔ́rmæ̀t súwtəbəl fɔr ənǽlɪsɪs. ɪt ɛnkʌ́mpəsɪz ə vərájətij əv tɛkníjks ɪnklúwdɪŋ hǽndəlɪŋ mɪ́sɪŋ vǽljuwz, rijmúwvɪŋ djúwplɪkèjts, stǽndərdàjzɪŋ fɔ́rmæ̀ts, nɔ́rməlàjzɪŋ vǽljuwz, ənd ɛnkówdɪŋ kæ̀təɡɑ́rɪkəl vɛ́ərijəbəlz. θɪ́ŋk əv ɪt æz prəpɛ́ərɪŋ ɪnɡríjdijənts bəfɔ́r kʊ́kɪŋ ə míjl—déjtə sájəntɪsts mʌst fɜ́rst klíjn, sɔ́rt, ənd prəpɛ́ər ðɛər déjtə bəfɔ́r ðej kən ɛ́kstrəkt míjnɪŋfəl ɪ́nsàjts ɔr bɪ́ld əféktɪv mɒ́dəlz. wɪðáwt prɒ́pər prijprɒ́sɛsɪŋ, ǽlɡərɪ̀ðəmz mej prədúws ɪ̀nǽkjərət ɔr mɪ̀slíjdɪŋ rəzʌ́lts djúw tə áwtlajərz, ɪ̀ŋkɒ́nsɪstɛ̀nsijz, ɔr ɪ̀ərɛ́ləvənt ɪnfərméjʃən ɪn ðə déjtəsɛ̀t. ðɪs fawndéjʃənəl prɒ́sɛs tɪ́pɪkəlij kənsúwmz ə sɪɡnɪ́fɪkənt pɔ́rʃən əv ə déjtə sájəntɪst's wɜ́rkflòw bʌt ɪz əsɛ́nʃəl fɔr ɛnʃʊ́rɪŋ ðə kwɑ́lɪtij ənd rəlàjəbɪ́lɪtij əv sʌ́bsəkwənt ənǽlɪsìjz ənd prədɪ́kʃənz."
    },
    {
        "Question": "Which field of computer science focuses on creating graphical representations of data to make complex information more accessible and comprehensible to humans?",
        "RightAnswer": "Data Visualization",
        "WrongAnswers": [
            "Machine Learning",
            "Database Normalization",
            "Algorithm Complexity",
            "Network Topology",
            "Memory Management"
        ],
        "Explanation": "Data Visualization is the practice of transforming raw data into visual contexts such as charts, graphs, maps, and interactive dashboards. This interdisciplinary field combines elements of computer science, statistics, and graphic design to help people understand the significance of data by placing it in a visual context. Unlike raw numbers or spreadsheets, visualizations leverage human visual perception capabilities to identify patterns, trends, outliers, and relationships that might otherwise remain hidden. In computer science, data visualization involves creating algorithms and tools that can efficiently process large datasets and render them visually. Modern data visualization often incorporates interactive elements, allowing users to manipulate views, filter information, and explore data at different levels of detail. This field has become increasingly important in the age of big data, where organizations and researchers need effective ways to make sense of massive, complex datasets that would be incomprehensible in their raw form.",
        "trans_Question": "wɪ́tʃ fíjld əv kəmpjúwtər sájəns fówkəsɪz ɒn krijéjtɪŋ ɡrǽfɪkəl rɛ̀prəzəntéjʃənz əv déjtə tə méjk kɒ́mplɛks ɪnfərméjʃən mɔr æksɛ́sɪbəl ənd kɒ̀mprəhɛ́nsɪbəl tə hjúwmənz?",
        "trans_RightAnswer": "déjtə vɪ̀ʒwəlɪzéjʃən",
        "trans_WrongAnswers": [
            "məʃíjn lɜ́rnɪŋ",
            "déjtəbèjs nɔ̀rməlɪzéjʃən",
            "ǽlɡərɪ̀ðəm kəmplɛ́ksɪtij",
            "nɛ́twɜ̀rk təpɔ́lədʒij",
            "mɛ́mərij mǽnədʒmənt"
        ],
        "trans_Explanation": "déjtə vɪ̀ʒwəlɪzéjʃən ɪz ðə prǽktɪs əv trænsfɔ́rmɪŋ rɔ́ déjtə ɪntə vɪ́ʒəwəl kɒ́ntɛ̀ksts sʌtʃ æz tʃɑ́rts, ɡrǽfs, mǽps, ənd ɪ̀ntərǽktɪv dǽʃbɔ̀rdz. ðɪs ɪ̀ntərdɪ́sɪplənɛ̀ərij fíjld kəmbájnz ɛ́ləmənts əv kəmpjúwtər sájəns, stətɪ́stɪks, ənd ɡrǽfɪk dəzájn tə hɛ́lp píjpəl ʌ̀ndərstǽnd ðə sɪɡnɪ́fɪkəns əv déjtə baj pléjsɪŋ ɪt ɪn ə vɪ́ʒəwəl kɒ́ntɛkst. ʌ̀nlájk rɔ́ nʌ́mbərz ɔr sprɛ́dʃìjts, vɪ̀ʒwəlɪzéjʃənz lɛ́vərɪdʒ hjúwmən vɪ́ʒəwəl pərsɛ́pʃən kèjpəbɪ́lɪtijz tə ajdɛ́ntɪfàj pǽtərnz, trɛ́ndz, áwtlajərz, ənd rəléjʃənʃɪ̀ps ðət majt ʌ́ðərwàjz rəméjn hɪ́dən. ɪn kəmpjúwtər sájəns, déjtə vɪ̀ʒwəlɪzéjʃən ɪnvɒ́lvz krijéjtɪŋ ǽlɡərɪ̀ðəmz ənd túwlz ðət kən əfɪ́ʃəntlij prɒ́sɛs lɑ́rdʒ déjtəsɛ̀ts ənd rɛ́ndər ðɛm vɪ́ʒwəlij. mɒ́dərn déjtə vɪ̀ʒwəlɪzéjʃən ɔ́fən ɪnkɔ́rpərejts ɪ̀ntərǽktɪv ɛ́ləmənts, əláwɪŋ júwzərz tə mənɪ́pjəlèjt vjúwz, fɪ́ltər ɪnfərméjʃən, ənd əksplɔ́r déjtə æt dɪ́fərənt lɛ́vəlz əv díjtejl. ðɪs fíjld həz bəkʌ́m ɪnkríjsɪŋɡlij ɪmpɔ́rtənt ɪn ðə éjdʒ əv bɪ́ɡ déjtə, wɛ́ər ɔ̀rɡənɪzéjʃənz ənd ríjsərtʃərz níjd əféktɪv wéjz tə méjk sɛ́ns əv mǽsɪv, kɒ́mplɛks déjtəsɛ̀ts ðət wʊd bij ɪ̀ŋkɒ̀mprəhɛ́nsɪbəl ɪn ðɛər rɔ́ fɔ́rm."
    },
    {
        "Question": "What describes the computational approach that uses mathematics to represent relationships between variables in data and to estimate the likelihood of different outcomes?",
        "RightAnswer": "Statistical Modeling",
        "WrongAnswers": [
            "Data Scraping",
            "Procedural Abstraction",
            "Digital Cryptography",
            "Object Serialization",
            "Network Topology"
        ],
        "Explanation": "Statistical Modeling is a fundamental computational approach that creates mathematical representations of real-world processes to understand relationships in data. In computer science, it involves using statistical methods to develop models that can identify patterns, make predictions, and quantify uncertainty in data. These models range from simple linear relationships to complex machine learning algorithms that can find hidden structures in massive datasets. Statistical modeling serves as the backbone for many applications including predictive analytics, recommendation systems, natural language processing, and computer vision. By building statistical models, computer scientists can transform raw data into actionable insights, enabling systems to make informed decisions based on probability rather than deterministic rules. This approach is particularly valuable when dealing with incomplete information or when trying to generalize from sample data to larger populations.",
        "trans_Question": "wɒt dəskrájbz ðə kɒ̀mpjuwtéjʃənəl əprówtʃ ðət júwsɪz mæ̀θəmǽtɪks tə rɛ̀prəzɛ́nt rəléjʃənʃɪ̀ps bijtwíjn vɛ́ərijəbəlz ɪn déjtə ənd tə ɛ́stɪmèjt ðə lájklijhʊ̀d əv dɪ́fərənt áwtkʌ̀mz?",
        "trans_RightAnswer": "stətɪ́stɪkəl mɒ́dəlɪ̀ŋ",
        "trans_WrongAnswers": [
            "déjtə skréjpɪŋ",
            "prəsíjdʒərəl æbstrǽkʃən",
            "dɪ́dʒɪtəl krɪptɒ́ɡrəfij",
            "ɒ́bdʒəkt sɪ̀ərìjəlɪzéjʃən",
            "nɛ́twɜ̀rk təpɔ́lədʒij"
        ],
        "trans_Explanation": "stətɪ́stɪkəl mɒ́dəlɪ̀ŋ ɪz ə fʌ̀ndəmɛ́ntəl kɒ̀mpjuwtéjʃənəl əprówtʃ ðət krijéjts mæ̀θəmǽtɪkəl rɛ̀prəzəntéjʃənz əv ríjəl-wɜ́rld prɒ́sɛsɪz tə ʌ̀ndərstǽnd rəléjʃənʃɪ̀ps ɪn déjtə. ɪn kəmpjúwtər sájəns, ɪt ɪnvɒ́lvz júwzɪŋ stətɪ́stɪkəl mɛ́θədz tə dəvɛ́ləp mɒ́dəlz ðət kən ajdɛ́ntɪfàj pǽtərnz, méjk prədɪ́kʃənz, ənd kwɑ́ntɪfàj ʌ̀nsɜ́rtəntij ɪn déjtə. ðijz mɒ́dəlz réjndʒ frəm sɪ́mpəl lɪ́nijər rəléjʃənʃɪ̀ps tə kɒ́mplɛks məʃíjn lɜ́rnɪŋ ǽlɡərɪ̀ðəmz ðət kən fájnd hɪ́dən strʌ́ktʃərz ɪn mǽsɪv déjtəsɛ̀ts. stətɪ́stɪkəl mɒ́dəlɪ̀ŋ sɜ́rvz æz ðə bǽkbòwn fɔr mɛ́nij æ̀plɪkéjʃənz ɪnklúwdɪŋ prədɪ́ktɪv æ̀nəlɪ́tɪks, rɛ̀kəməndéjʃən sɪ́stəmz, nǽtʃərəl lǽŋɡwədʒ prɒ́sɛsɪŋ, ənd kəmpjúwtər vɪ́ʒən. baj bɪ́ldɪŋ stətɪ́stɪkəl mɒ́dəlz, kəmpjúwtər sájəntɪsts kən trǽnsfɔrm rɔ́ déjtə ɪntə ǽkʃənəbəl ɪ́nsàjts, ɛnéjbəlɪŋ sɪ́stəmz tə méjk ɪnfɔ́rmd dəsɪ́ʒənz béjst ɒn prɒ̀bəbɪ́lɪtij rǽðər ðʌn dətɜ̀rmɪnɪ́stɪk rúwlz. ðɪs əprówtʃ ɪz pərtɪ́kjələrlij vǽljəbəl wɛ́n díjlɪŋ wɪð ɪ̀nkəmplíjt ɪnfərméjʃən ɔr wɛ́n trájɪŋ tə dʒɛ́nərəlàjz frəm sǽmpəl déjtə tə lɑ́rdʒər pɒ̀pjəléjʃənz."
    },
    {
        "Question": "Which mathematical framework provides the foundation for analyzing algorithms that produce uncertain outcomes, enables reasoning about random events in machine learning, and forms the basis for concepts like expected running time in computing?",
        "RightAnswer": "Probability Theory",
        "WrongAnswers": [
            "Automata Theory",
            "Complexity Theory",
            "Relational Algebra",
            "Lambda Calculus",
            "Category Theory"
        ],
        "Explanation": "Probability Theory is a branch of mathematics concerned with analyzing and quantifying uncertainty, which has profound applications in computer science. In computing contexts, it provides essential tools for reasoning about random processes, making decisions under uncertainty, and analyzing the expected behavior of algorithms. It underpins many fundamental computing concepts: randomized algorithms use probability to achieve efficiency gains; machine learning systems use probabilistic models to make predictions; cryptographic systems rely on probabilistic hardness assumptions; and even basic analysis of algorithms often involves probabilistic techniques to reason about average-case performance. Beyond these technical applications, Probability Theory gives computer scientists a language to express degrees of belief and uncertainty in systems that interact with an unpredictable world. It's the mathematical framework that allows computers to reason in situations where complete certainty is impossible but informed decisions must still be made.",
        "trans_Question": "wɪ́tʃ mæ̀θəmǽtɪkəl fréjmwɜ̀rk prəvájdz ðə fawndéjʃən fɔr ǽnəlàjzɪŋ ǽlɡərɪ̀ðəmz ðət prədúws ʌ̀nsɜ́rtən áwtkʌ̀mz, ɛnéjbəlz ríjzənɪŋ əbawt rǽndəm əvɛ́nts ɪn məʃíjn lɜ́rnɪŋ, ənd fɔ́rmz ðə béjsɪs fɔr kɒ́nsɛpts lájk əkspɛ́ktɪd rʌ́nɪŋ tájm ɪn kəmpjúwtɪŋ?",
        "trans_RightAnswer": "prɒ̀bəbɪ́lɪtij θíjərij",
        "trans_WrongAnswers": [
            "ɔtɒ́mətə θíjərij",
            "kəmplɛ́ksɪtij θíjərij",
            "rəléjʃənəl ǽldʒəbrə",
            "lǽmdə kǽlkjələs",
            "kǽtəɡɔ̀rij θíjərij"
        ],
        "trans_Explanation": "prɒ̀bəbɪ́lɪtij θíjərij ɪz ə brǽntʃ əv mæ̀θəmǽtɪks kənsɜ́rnd wɪð ǽnəlàjzɪŋ ənd kwɑ́ntɪfàjɪŋ ʌ̀nsɜ́rtəntij, wɪ́tʃ həz prowfáwnd æ̀plɪkéjʃənz ɪn kəmpjúwtər sájəns. ɪn kəmpjúwtɪŋ kɒ́ntɛ̀ksts, ɪt prəvájdz əsɛ́nʃəl túwlz fɔr ríjzənɪŋ əbawt rǽndəm prɒ́sɛsɪz, méjkɪŋ dəsɪ́ʒənz ʌ́ndər ʌ̀nsɜ́rtəntij, ənd ǽnəlàjzɪŋ ðə əkspɛ́ktɪd bəhéjvjər əv ǽlɡərɪ̀ðəmz. ɪt ʌ̀ndərpɪ́nz mɛ́nij fʌ̀ndəmɛ́ntəl kəmpjúwtɪŋ kɒ́nsɛpts: rǽndəmàjzd ǽlɡərɪ̀ðəmz juwz prɒ̀bəbɪ́lɪtij tə ətʃíjv əfɪ́ʃənsij ɡéjnz; məʃíjn lɜ́rnɪŋ sɪ́stəmz juwz prɒ̀bəbɪlɪ́stɪk mɒ́dəlz tə méjk prədɪ́kʃənz; krɪptɒ́ɡrəfɪk sɪ́stəmz rəláj ɒn prɒ̀bəbɪlɪ́stɪk hɑ́rdnəs əsʌ́mpʃənz; ənd íjvən béjsɪk ənǽlɪsɪs əv ǽlɡərɪ̀ðəmz ɔ́fən ɪnvɒ́lvz prɒ̀bəbɪlɪ́stɪk tɛkníjks tə ríjzən əbawt ǽvərɪdʒ-kéjs pərfɔ́rməns. bìjɔ́nd ðijz tɛ́knɪkəl æ̀plɪkéjʃənz, prɒ̀bəbɪ́lɪtij θíjərij ɡɪ́vz kəmpjúwtər sájəntɪsts ə lǽŋɡwədʒ tə əksprɛ́s dəɡríjz əv bəlíjf ənd ʌ̀nsɜ́rtəntij ɪn sɪ́stəmz ðət ɪ̀ntərǽkt wɪð ən ʌ̀nprədɪ́ktəbəl wɜ́rld. ɪt's ðə mæ̀θəmǽtɪkəl fréjmwɜ̀rk ðət əláwz kəmpjúwtərz tə ríjzən ɪn sɪ̀tʃuwéjʃənz wɛ́ər kəmplíjt sɜ́rtəntij ɪz ɪ̀mpɒ́sɪbəl bʌt ɪnfɔ́rmd dəsɪ́ʒənz mʌst stɪ́l bij méjd."
    },
    {
        "Question": "What statistical approach updates belief probabilities based on new evidence and is commonly used in machine learning algorithms for prediction and classification tasks?",
        "RightAnswer": "Bayesian Inference",
        "WrongAnswers": [
            "Frequentist Analysis",
            "Monte Carlo Simulation",
            "Maximum Likelihood Estimation",
            "Gradient Descent Optimization",
            "Decision Tree Pruning"
        ],
        "Explanation": "Bayesian Inference is a statistical method that uses Bayes' theorem to update the probability of a hypothesis as more evidence becomes available. Unlike traditional statistical approaches that rely on fixed probabilities, Bayesian methods treat probabilities as degrees of belief that change when new data is observed. In computer science and machine learning, Bayesian Inference provides a formal framework for reasoning under uncertainty. It allows systems to make predictions by combining prior knowledge with observed data, making it particularly valuable for tasks like spam filtering, recommendation systems, and natural language processing. For example, a Bayesian spam filter starts with initial beliefs about which words indicate spam, then continuously refines these beliefs as users mark emails as spam or not spam. This approach is powerful because it naturally handles incomplete information, quantifies uncertainty in predictions, and incorporates domain knowledge. The growing popularity of Bayesian methods in computing reflects their ability to make robust predictions even with limited data, while providing interpretable measures of confidence in those predictions.",
        "trans_Question": "wɒt stətɪ́stɪkəl əprówtʃ ʌ́pdèjts bəlíjf prɒ̀bəbɪ́lɪtìjz béjst ɒn núw ɛ́vɪdəns ənd ɪz kɒ́mənlij júwzd ɪn məʃíjn lɜ́rnɪŋ ǽlɡərɪ̀ðəmz fɔr prədɪ́kʃən ənd klæ̀sɪfɪkéjʃən tǽsks?",
        "trans_RightAnswer": "béjʒən ɪ́nfərəns",
        "trans_WrongAnswers": [
            "fríjkwəntɪst ənǽlɪsɪs",
            "mɒ́ntij kɑ́rlow sɪ̀mjəléjʃən",
            "mǽksɪməm lájklijhʊ̀d ɛ̀stɪméjʃən",
            "ɡréjdijənt dəsɛ́nt ɒptɪmɪzéjʃən",
            "dəsɪ́ʒən tríj prúwnɪŋ"
        ],
        "trans_Explanation": "béjʒən ɪ́nfərəns ɪz ə stətɪ́stɪkəl mɛ́θəd ðət júwsɪz béjz' θɪ́ərəm tə əpdéjt ðə prɒ̀bəbɪ́lɪtij əv ə hajpɒ́θəsɪs æz mɔr ɛ́vɪdəns bəkʌ́mz əvéjləbəl. ʌ̀nlájk trədɪ́ʃənəl stətɪ́stɪkəl əprówtʃɪz ðət rəláj ɒn fɪ́kst prɒ̀bəbɪ́lɪtìjz, béjʒən mɛ́θədz tríjt prɒ̀bəbɪ́lɪtìjz æz dəɡríjz əv bəlíjf ðət tʃéjndʒ wɛ́n núw déjtə ɪz əbzɜ́rvd. ɪn kəmpjúwtər sájəns ənd məʃíjn lɜ́rnɪŋ, béjʒən ɪ́nfərəns prəvájdz ə fɔ́rməl fréjmwɜ̀rk fɔr ríjzənɪŋ ʌ́ndər ʌ̀nsɜ́rtəntij. ɪt əláwz sɪ́stəmz tə méjk prədɪ́kʃənz baj kəmbájnɪŋ prájər nɒ́lɪdʒ wɪð əbzɜ́rvd déjtə, méjkɪŋ ɪt pərtɪ́kjələrlij vǽljəbəl fɔr tǽsks lájk spǽm fɪ́ltərɪŋ, rɛ̀kəməndéjʃən sɪ́stəmz, ənd nǽtʃərəl lǽŋɡwədʒ prɒ́sɛsɪŋ. fɔr əɡzǽmpəl, ə béjʒən spǽm fɪ́ltər stɑ́rts wɪð ɪnɪ́ʃəl bəlíjfs əbawt wɪ́tʃ wɜ́rdz ɪ́ndɪkèjt spǽm, ðɛn kəntɪ́njuwəslij rəfájnz ðijz bəlíjfs æz júwzərz mɑ́rk íjmejlz æz spǽm ɔr nɒt spǽm. ðɪs əprówtʃ ɪz páwərfəl bəkɒ́z ɪt nǽtʃərəlij hǽndəlz ɪ̀nkəmplíjt ɪnfərméjʃən, kwɑ́ntɪfajz ʌ̀nsɜ́rtəntij ɪn prədɪ́kʃənz, ənd ɪnkɔ́rpərejts dowméjn nɒ́lɪdʒ. ðə ɡrówɪŋ pɒ̀pjəlɛ́ərɪtij əv béjʒən mɛ́θədz ɪn kəmpjúwtɪŋ rəflɛ́kts ðɛər əbɪ́lɪtij tə méjk rowbʌ́st prədɪ́kʃənz íjvən wɪð lɪ́mɪtɪd déjtə, wájl prəvájdɪŋ ɪntɜ́rprətəbəl mɛ́ʒərz əv kɒ́nfɪdəns ɪn ðowz prədɪ́kʃənz."
    },
    {
        "Question": "Which machine learning algorithm organizes data into a hierarchical, branching structure where each internal node represents a decision based on a feature and each leaf node represents a predicted outcome?",
        "RightAnswer": "Decision Tree",
        "WrongAnswers": [
            "Neural Network",
            "Support Vector Machine",
            "K-means Clustering",
            "Linear Regression",
            "Random Walk"
        ],
        "Explanation": "A Decision Tree is a supervised machine learning algorithm that resembles an upside-down tree, breaking down complex decisions into simpler choices. Starting from a root node, it splits data based on feature values, creating branches that lead to further decision nodes or final outcome leaves. Decision Trees excel at classification and regression tasks by creating a flowchart-like structure that's both visually interpretable and computationally efficient. They're particularly valuable because they mirror human decision-making processes, allowing us to follow the logic path from input to prediction. While they can suffer from overfitting on complex datasets, techniques like pruning and ensemble methods like Random Forests help mitigate these limitations. Their intuitive nature makes them excellent teaching tools and practical solutions for many real-world problems in fields ranging from medical diagnosis to customer behavior prediction.",
        "trans_Question": "wɪ́tʃ məʃíjn lɜ́rnɪŋ ǽlɡərɪ̀ðəm ɔ́rɡənàjzɪz déjtə ɪntə ə hàjərɑ́rkɪkəl, brǽntʃɪŋ strʌ́ktʃər wɛ́ər ijtʃ ɪ̀ntɜ́rnəl nówd rɛ̀prəzɛ́nts ə dəsɪ́ʒən béjst ɒn ə fíjtʃər ənd ijtʃ líjf nówd rɛ̀prəzɛ́nts ə prədɪ́ktɪd áwtkʌ̀m?",
        "trans_RightAnswer": "dəsɪ́ʒən tríj",
        "trans_WrongAnswers": [
            "nʊ́rəl nɛ́twɜ̀rk",
            "səpɔ́rt vɛ́ktər məʃíjn",
            "k-míjnz klʌ́stərɪŋ",
            "lɪ́nijər rəɡrɛ́ʃən",
            "rǽndəm wɒ́k"
        ],
        "trans_Explanation": "ə dəsɪ́ʒən tríj ɪz ə súwpərvàjzd məʃíjn lɜ́rnɪŋ ǽlɡərɪ̀ðəm ðət rijzɛ́mbəlz ən ʌ́psájd-dawn tríj, bréjkɪŋ dawn kɒ́mplɛks dəsɪ́ʒənz ɪntə sɪ́mplər tʃɔ́jsɪz. stɑ́rtɪŋ frəm ə rúwt nówd, ɪt splɪ́ts déjtə béjst ɒn fíjtʃər vǽljuwz, krijéjtɪŋ brǽntʃɪz ðət líjd tə fɜ́rðər dəsɪ́ʒən nówdz ɔr fájnəl áwtkʌ̀m líjvz. dəsɪ́ʒən tríjz əksɛ́l æt klæ̀sɪfɪkéjʃən ənd rəɡrɛ́ʃən tǽsks baj krijéjtɪŋ ə flówtʃɑ̀rt-lájk strʌ́ktʃər ðət's bówθ vɪ́ʒwəlij ɪntɜ́rprətəbəl ənd kɒ̀mpjətéjʃənəlij əfɪ́ʃənt. ðɛ́ər pərtɪ́kjələrlij vǽljəbəl bəkɒ́z ðej mɪ́ərər hjúwmən dəsɪ́ʒən-méjkɪŋ prɒ́sɛsɪz, əláwɪŋ US tə fɒ́low ðə lɒ́dʒɪk pǽθ frəm ɪ́npʊ̀t tə prədɪ́kʃən. wájl ðej kən sʌ́fər frəm òwvərfɪ́tɪŋ ɒn kɒ́mplɛks déjtəsɛ̀ts, tɛkníjks lájk prúwnɪŋ ənd ɒnsɒ́mbəl mɛ́θədz lájk rǽndəm fɔ́rəsts hɛ́lp mɪ́tɪɡèjt ðijz lɪ̀mɪtéjʃənz. ðɛər ɪntúwɪtɪv néjtʃər méjks ðɛm ɛ́ksələnt tíjtʃɪŋ túwlz ənd prǽktɪkəl səlúwʃənz fɔr mɛ́nij ríjəl-wɜ́rld prɒ́bləmz ɪn fíjldz réjndʒɪŋ frəm mɛ́dɪkəl dàjəɡnówsɪs tə kʌ́stəmər bəhéjvjər prədɪ́kʃən."
    },
    {
        "Question": "Which machine learning algorithm combines multiple decision trees and uses random subsampling of data and features to reduce overfitting?",
        "RightAnswer": "Random Forest",
        "WrongAnswers": [
            "Neural Network",
            "Support Vector Machine",
            "K-Means Clustering",
            "Gradient Boosting",
            "Logistic Regression"
        ],
        "Explanation": "Random Forest is an ensemble learning method in machine learning that works by constructing numerous decision trees during training and outputting the class that is the mode of the classes or mean prediction of the individual trees. The 'random' aspect comes from two key elements: each tree is built from a random subset of the training data, and at each node in a tree, only a random subset of features is considered for splitting. This randomness helps create diverse trees that collectively make more accurate and robust predictions than any single tree could alone. Random Forests excel at handling large datasets with high dimensionality, are less prone to overfitting, and can provide insights into feature importance. They're widely used in classification and regression tasks across various domains including finance, healthcare, and image recognition due to their accuracy, efficiency, and interpretability.",
        "trans_Question": "wɪ́tʃ məʃíjn lɜ́rnɪŋ ǽlɡərɪ̀ðəm kəmbájnz mʌ́ltɪpəl dəsɪ́ʒən tríjz ənd júwsɪz rǽndəm sʌ́bsæ̀mplɪŋ əv déjtə ənd fíjtʃərz tə rədjúws òwvərfɪ́tɪŋ?",
        "trans_RightAnswer": "rǽndəm fɔ́rəst",
        "trans_WrongAnswers": [
            "nʊ́rəl nɛ́twɜ̀rk",
            "səpɔ́rt vɛ́ktər məʃíjn",
            "k-míjnz klʌ́stərɪŋ",
            "ɡréjdijənt búwstɪŋ",
            "lədʒɪ́stɪk rəɡrɛ́ʃən"
        ],
        "trans_Explanation": "rǽndəm fɔ́rəst ɪz ən ɒnsɒ́mbəl lɜ́rnɪŋ mɛ́θəd ɪn məʃíjn lɜ́rnɪŋ ðət wɜ́rks baj kənstrʌ́ktɪŋ njúwmərəs dəsɪ́ʒən tríjz dʊ́rɪŋ tréjnɪŋ ənd àwtpʊ́tɪŋ ðə klǽs ðət ɪz ðə mówd əv ðə klǽsɪz ɔr míjn prədɪ́kʃən əv ðə ɪndɪvɪ́dʒəwəl tríjz. ðə 'rǽndəm' ǽspɛkt kʌ́mz frəm túw kíj ɛ́ləmənts: ijtʃ tríj ɪz bɪ́lt frəm ə rǽndəm sʌ́bsɛ̀t əv ðə tréjnɪŋ déjtə, ənd æt ijtʃ nówd ɪn ə tríj, ównlij ə rǽndəm sʌ́bsɛ̀t əv fíjtʃərz ɪz kənsɪ́dərd fɔr splɪ́tɪŋ. ðɪs rǽndəmnəs hɛ́lps krijéjt dajvɜ́rs tríjz ðət kəlɛ́ktɪvlij méjk mɔr ǽkjərət ənd rowbʌ́st prədɪ́kʃənz ðʌn ɛ́nij sɪ́ŋɡəl tríj kʊ́d əlówn. rǽndəm fɔ́rəsts əksɛ́l æt hǽndəlɪŋ lɑ́rdʒ déjtəsɛ̀ts wɪð háj dajmɛ̀nʃənǽlɪtij, ɑr lɛ́s prówn tə òwvərfɪ́tɪŋ, ənd kən prəvájd ɪ́nsàjts ɪntə fíjtʃər ɪmpɔ́rtəns. ðɛ́ər wájdlij júwzd ɪn klæ̀sɪfɪkéjʃən ənd rəɡrɛ́ʃən tǽsks əkrɔ́s vɛ́ərijəs dowméjnz ɪnklúwdɪŋ fájnæ̀ns, hɛ́lθkɛ̀ər, ənd ɪ́mɪdʒ rɛ̀kəɡnɪ́ʃən djúw tə ðɛər ǽkjərəsij, əfɪ́ʃənsij, ənd ɪntɜ̀rprɛtəbɪ́lɪtij."
    },
    {
        "Question": "Which machine learning algorithm finds the optimal hyperplane that maximizes the margin between different classes of data points in a feature space?",
        "RightAnswer": "Support Vector Machine",
        "WrongAnswers": [
            "Random Forest",
            "K-Means Clustering",
            "Neural Network",
            "Gradient Boosting",
            "Principal Component Analysis"
        ],
        "Explanation": "A Support Vector Machine (SVM) is a powerful supervised machine learning algorithm used for classification and regression tasks. It works by finding the optimal boundary or hyperplane that separates different classes of data while maximizing the margin between them. The 'support vectors' are the data points that lie closest to this decision boundary and effectively support or define its position. What makes SVMs special is their ability to transform data into higher-dimensional spaces using kernel functions, allowing them to find complex boundaries even when the data isn't linearly separable in its original form. SVMs are particularly valuable when working with smaller datasets that have clear margins of separation, and they're resistant to overfitting because they focus on the boundary cases rather than trying to model the entire dataset. This makes them both efficient and effective for many classification problems in computer science applications ranging from image recognition to text categorization.",
        "trans_Question": "wɪ́tʃ məʃíjn lɜ́rnɪŋ ǽlɡərɪ̀ðəm fájndz ðə ɒ́ptɪməl hájpərpléjn ðət mǽksɪmàjzɪz ðə mɑ́rdʒɪn bijtwíjn dɪ́fərənt klǽsɪz əv déjtə pɔ́jnts ɪn ə fíjtʃər spéjs?",
        "trans_RightAnswer": "səpɔ́rt vɛ́ktər məʃíjn",
        "trans_WrongAnswers": [
            "rǽndəm fɔ́rəst",
            "k-míjnz klʌ́stərɪŋ",
            "nʊ́rəl nɛ́twɜ̀rk",
            "ɡréjdijənt búwstɪŋ",
            "prɪ́nsɪpəl kəmpównənt ənǽlɪsɪs"
        ],
        "trans_Explanation": "ə səpɔ́rt vɛ́ktər məʃíjn (SVM) ɪz ə páwərfəl súwpərvàjzd məʃíjn lɜ́rnɪŋ ǽlɡərɪ̀ðəm júwzd fɔr klæ̀sɪfɪkéjʃən ənd rəɡrɛ́ʃən tǽsks. ɪt wɜ́rks baj fájndɪŋ ðə ɒ́ptɪməl báwndərij ɔr hájpərpléjn ðət sɛ́pərèjts dɪ́fərənt klǽsɪz əv déjtə wájl mǽksɪmàjzɪŋ ðə mɑ́rdʒɪn bijtwíjn ðɛm. ðə 'səpɔ́rt vɛ́ktərz' ɑr ðə déjtə pɔ́jnts ðət láj klówsəst tə ðɪs dəsɪ́ʒən báwndərij ənd əfɛ́ktɪvlij səpɔ́rt ɔr dəfájn ɪts pəzɪ́ʃən. wɒt méjks SVMs spɛ́ʃəl ɪz ðɛər əbɪ́lɪtij tə trǽnsfɔrm déjtə ɪntə hájər-dajmɛ́nʃənəl spéjsɪz júwzɪŋ kɜ́rnəl fʌ́ŋkʃənz, əláwɪŋ ðɛm tə fájnd kɒ́mplɛks báwndərijz íjvən wɛ́n ðə déjtə ɪzənt lɪ́nijərlij sɛ́pərəbəl ɪn ɪts ərɪ́dʒɪnəl fɔ́rm. SVMs ɑr pərtɪ́kjələrlij vǽljəbəl wɛ́n wɜ́rkɪŋ wɪð smɔ́lər déjtəsɛ̀ts ðət həv klɪ́ər mɑ́rdʒɪnz əv sɛ̀pərèjʃən, ənd ðɛ́ər rəzɪ́stənt tə òwvərfɪ́tɪŋ bəkɒ́z ðej fówkəs ɒn ðə báwndərij kéjsɪz rǽðər ðʌn trájɪŋ tə mɒ́dəl ðə əntájər déjtəsɛ̀t. ðɪs méjks ðɛm bówθ əfɪ́ʃənt ənd əféktɪv fɔr mɛ́nij klæ̀sɪfɪkéjʃən prɒ́bləmz ɪn kəmpjúwtər sájəns æ̀plɪkéjʃənz réjndʒɪŋ frəm ɪ́mɪdʒ rɛ̀kəɡnɪ́ʃən tə tɛ́kst kæ̀təɡərɪzéjʃən."
    },
    {
        "Question": "What technique in computer science involves grouping similar data points together based on their characteristics without prior labeled examples?",
        "RightAnswer": "Clustering",
        "WrongAnswers": [
            "Regression",
            "Classification",
            "Normalization",
            "Tokenization",
            "Serialization"
        ],
        "Explanation": "Clustering is a fundamental technique in unsupervised machine learning that automatically groups similar objects or data points together based on their inherent characteristics or patterns, without requiring pre-labeled examples. Unlike classification, clustering discovers natural groupings within data rather than assigning data to predefined categories. Common clustering algorithms include K-means, hierarchical clustering, and DBSCAN. Clustering helps identify hidden structures in data and is widely used in customer segmentation, anomaly detection, document organization, image processing, and pattern recognition. The essence of clustering is finding 'birds of a feather' in data—items that belong together based on their similarities, while ensuring different clusters remain meaningfully distinct from each other.",
        "trans_Question": "wɒt tɛkníjk ɪn kəmpjúwtər sájəns ɪnvɒ́lvz ɡrúwpɪŋ sɪ́mɪlər déjtə pɔ́jnts təɡɛ́ðər béjst ɒn ðɛər kæ̀rəktərɪ́stɪks wɪðáwt prájər léjbəld əɡzǽmpəlz?",
        "trans_RightAnswer": "klʌ́stərɪŋ",
        "trans_WrongAnswers": [
            "rəɡrɛ́ʃən",
            "klæ̀sɪfɪkéjʃən",
            "nɔ̀rməlɪzéjʃən",
            "tòwkənəzéjʃən",
            "sɪ̀ərìjəlɪzéjʃən"
        ],
        "trans_Explanation": "klʌ́stərɪŋ ɪz ə fʌ̀ndəmɛ́ntəl tɛkníjk ɪn ʌ̀nsúwpərvàjzd məʃíjn lɜ́rnɪŋ ðət ɔ̀təmǽtɪklij ɡrúwps sɪ́mɪlər ɒ́bdʒɛkts ɔr déjtə pɔ́jnts təɡɛ́ðər béjst ɒn ðɛər ɪnhɛ́ərənt kæ̀rəktərɪ́stɪks ɔr pǽtərnz, wɪðáwt rijkwájərɪŋ príj-léjbəld əɡzǽmpəlz. ʌ̀nlájk klæ̀sɪfɪkéjʃən, klʌ́stərɪŋ dɪskʌ́vərz nǽtʃərəl ɡrúwpɪŋz wɪðɪ́n déjtə rǽðər ðʌn əsájnɪŋ déjtə tə prìjdəfájnd kǽtəɡɔ̀rijz. kɒ́mən klʌ́stərɪŋ ǽlɡərɪ̀ðəmz ɪnklúwd k-míjnz, hàjərɑ́rkɪkəl klʌ́stərɪŋ, ənd DBSCAN. klʌ́stərɪŋ hɛ́lps ajdɛ́ntɪfàj hɪ́dən strʌ́ktʃərz ɪn déjtə ənd ɪz wájdlij júwzd ɪn kʌ́stəmər sɛ̀ɡməntéjʃən, ənɒ́məlij dətɛ́kʃən, dɒ́kjəmɛnt ɔ̀rɡənɪzéjʃən, ɪ́mɪdʒ prɒ́sɛsɪŋ, ənd pǽtərn rɛ̀kəɡnɪ́ʃən. ðə ɛ́səns əv klʌ́stərɪŋ ɪz fájndɪŋ 'bɜ́rdz əv ə fɛ́ðər' ɪn déjtə—ájtəmz ðət bəlɔ́ŋ təɡɛ́ðər béjst ɒn ðɛər sɪ̀mɪlɛ́ərɪtijz, wájl ɛnʃʊ́rɪŋ dɪ́fərənt klʌ́stərz rəméjn míjnɪŋfəlij dɪstɪ́ŋkt frəm ijtʃ ʌ́ðər."
    },
    {
        "Question": "Which clustering algorithm partitions data into K groups by iteratively assigning points to the nearest centroid and then recalculating those centroids?",
        "RightAnswer": "K-means",
        "WrongAnswers": [
            "Random Forest",
            "Gradient Descent",
            "PageRank",
            "Dijkstra's Algorithm",
            "Alpha-Beta Pruning"
        ],
        "Explanation": "K-means is a popular unsupervised machine learning algorithm used for clustering data into groups. It works by first selecting K initial points as cluster centers (centroids). The algorithm then iteratively performs two steps: first, it assigns each data point to its nearest centroid, forming K clusters; second, it recalculates each centroid by taking the mean of all points assigned to that cluster. These steps repeat until the centroids stabilize or a maximum number of iterations is reached. K-means is widely used in data mining, image segmentation, and customer segmentation due to its simplicity and efficiency, though it requires the number of clusters (K) to be specified in advance and works best with spherical clusters of similar sizes. The algorithm aims to minimize the sum of distances between data points and their assigned cluster centers, producing compact and well-separated groupings.",
        "trans_Question": "wɪ́tʃ klʌ́stərɪŋ ǽlɡərɪ̀ðəm pɑrtɪ́ʃənz déjtə ɪntə K ɡrúwps baj ɪ́tərətɪvlij əsájnɪŋ pɔ́jnts tə ðə nɪ́ərəst sɛ́ntrɔjd ənd ðɛn rijkǽlkjəlèjtɪŋ ðowz sɛ́ntrɔjdz?",
        "trans_RightAnswer": "k-míjnz",
        "trans_WrongAnswers": [
            "rǽndəm fɔ́rəst",
            "ɡréjdijənt dəsɛ́nt",
            "péjdʒræŋk",
            "dájkstrə'z ǽlɡərɪ̀ðəm",
            "ǽlfə-béjtə prúwnɪŋ"
        ],
        "trans_Explanation": "k-míjnz ɪz ə pɒ́pjələr ʌ̀nsúwpərvàjzd məʃíjn lɜ́rnɪŋ ǽlɡərɪ̀ðəm júwzd fɔr klʌ́stərɪŋ déjtə ɪntə ɡrúwps. ɪt wɜ́rks baj fɜ́rst səlɛ́ktɪŋ K ɪnɪ́ʃəl pɔ́jnts æz klʌ́stər sɛ́ntərz (sɛ́ntrɔjdz). ðə ǽlɡərɪ̀ðəm ðɛn ɪ́tərətɪvlij pərfɔ́rmz túw stɛ́ps: fɜ́rst, ɪt əsájnz ijtʃ déjtə pɔ́jnt tə ɪts nɪ́ərəst sɛ́ntrɔjd, fɔ́rmɪŋ K klʌ́stərz; sɛ́kənd, ɪt rijkǽlkjəlejts ijtʃ sɛ́ntrɔjd baj téjkɪŋ ðə míjn əv ɔl pɔ́jnts əsájnd tə ðət klʌ́stər. ðijz stɛ́ps rəpíjt əntɪ́l ðə sɛ́ntrɔjdz stéjbɪlàjz ɔr ə mǽksɪməm nʌ́mbər əv ɪ̀təréjʃənz ɪz ríjtʃt. k-míjnz ɪz wájdlij júwzd ɪn déjtə májnɪŋ, ɪ́mɪdʒ sɛ̀ɡməntéjʃən, ənd kʌ́stəmər sɛ̀ɡməntéjʃən djúw tə ɪts sɪmplɪ́sɪtij ənd əfɪ́ʃənsij, ðów ɪt rəkwájərz ðə nʌ́mbər əv klʌ́stərz (K) tə bij spɛ́sɪfàjd ɪn ədvǽns ənd wɜ́rks bɛ́st wɪð sfɛ́ərɪkəl klʌ́stərz əv sɪ́mɪlər sájzɪz. ðə ǽlɡərɪ̀ðəm éjmz tə mɪ́nɪmàjz ðə sʌ́m əv dɪ́stənsɪz bijtwíjn déjtə pɔ́jnts ənd ðɛər əsájnd klʌ́stər sɛ́ntərz, prədúwsɪŋ kɒ́mpækt ənd wɛ́l-sɛ́pərèjtɪd ɡrúwpɪŋz."
    },
    {
        "Question": "What data mining technique builds a tree-like data structure by progressively grouping similar objects together based on distance metrics and doesn't require a predefined number of clusters?",
        "RightAnswer": "Hierarchical Clustering",
        "WrongAnswers": [
            "K-means Partitioning",
            "Decision Tree Classification",
            "Principal Component Analysis",
            "Random Forest Aggregation",
            "Support Vector Decomposition"
        ],
        "Explanation": "Hierarchical Clustering is an unsupervised machine learning technique that organizes data into a tree-like structure of nested clusters. Unlike other clustering algorithms such as K-means, it doesn't require you to specify the number of clusters beforehand. There are two main approaches: agglomerative (bottom-up), which starts with each data point as its own cluster and progressively merges the closest ones, and divisive (top-down), which begins with all data in one cluster and recursively divides it. The result is typically visualized as a dendrogram, a tree diagram showing the arrangement of clusters and the distance at which clusters merge or split. This technique is particularly valuable when exploring data with natural hierarchical relationships or when you want to understand the multi-level structure within your data. It's widely used in fields like document organization, customer segmentation, and biological taxonomy within computational applications.",
        "trans_Question": "wɒt déjtə májnɪŋ tɛkníjk bɪ́ldz ə tríj-lájk déjtə strʌ́ktʃər baj prɒɡrɛ́sɪvlij ɡrúwpɪŋ sɪ́mɪlər ɒ́bdʒɛkts təɡɛ́ðər béjst ɒn dɪ́stəns mɛ́trɪks ənd dʌ́zənt rəkwájər ə prìjdəfájnd nʌ́mbər əv klʌ́stərz?",
        "trans_RightAnswer": "hàjərɑ́rkɪkəl klʌ́stərɪŋ",
        "trans_WrongAnswers": [
            "k-míjnz pɑrtɪ́ʃənɪŋ",
            "dəsɪ́ʒən tríj klæ̀sɪfɪkéjʃən",
            "prɪ́nsɪpəl kəmpównənt ənǽlɪsɪs",
            "rǽndəm fɔ́rəst æ̀ɡrəɡéjʃən",
            "səpɔ́rt vɛ́ktər dìjkəmpəzɪ́ʃən"
        ],
        "trans_Explanation": "hàjərɑ́rkɪkəl klʌ́stərɪŋ ɪz ən ʌ̀nsúwpərvàjzd məʃíjn lɜ́rnɪŋ tɛkníjk ðət ɔ́rɡənàjzɪz déjtə ɪntə ə tríj-lájk strʌ́ktʃər əv nɛ́stɪd klʌ́stərz. ʌ̀nlájk ʌ́ðər klʌ́stərɪŋ ǽlɡərɪ̀ðəmz sʌtʃ æz k-míjnz, ɪt dʌ́zənt rəkwájər juw tə spɛ́sɪfàj ðə nʌ́mbər əv klʌ́stərz bəfɔ́rhæ̀nd. ðɛər ɑr túw méjn əprówtʃɪz: əɡlɒ́mərətɪv (bɒ́təm-ʌp), wɪ́tʃ stɑ́rts wɪð ijtʃ déjtə pɔ́jnt æz ɪts ówn klʌ́stər ənd prɒɡrɛ́sɪvlij mɜ́rdʒɪz ðə klówsəst wʌ́nz, ənd dɪvájsɪv (tɒ́p-dawn), wɪ́tʃ bəɡɪ́nz wɪð ɔl déjtə ɪn wʌ́n klʌ́stər ənd rəkɜ́rsɪvlij dɪvájdz ɪt. ðə rəzʌ́lt ɪz tɪ́pɪkəlij vɪ́ʒwəlàjzd æz ə dɛ́ndrəɡræm, ə tríj dájəɡræ̀m ʃówɪŋ ðə əréjndʒmənt əv klʌ́stərz ənd ðə dɪ́stəns æt wɪ́tʃ klʌ́stərz mɜ́rdʒ ɔr splɪ́t. ðɪs tɛkníjk ɪz pərtɪ́kjələrlij vǽljəbəl wɛ́n əksplɔ́rɪŋ déjtə wɪð nǽtʃərəl hàjərɑ́rkɪkəl rəléjʃənʃɪ̀ps ɔr wɛ́n juw wɒ́nt tə ʌ̀ndərstǽnd ðə mʌ́ltij-lɛ́vəl strʌ́ktʃər wɪðɪ́n jɔr déjtə. ɪt's wájdlij júwzd ɪn fíjldz lájk dɒ́kjəmɛnt ɔ̀rɡənɪzéjʃən, kʌ́stəmər sɛ̀ɡməntéjʃən, ənd bàjəlɒ́dʒɪkəl tæ̀ksɔ́nəmìj wɪðɪ́n kɒ̀mpjuwtéjʃənəl æ̀plɪkéjʃənz."
    },
    {
        "Question": "In a machine learning project, you need to tackle high-dimensional data with thousands of features that is causing slow performance and overfitting. Which technique would you apply to reduce the number of variables while preserving the most important information?",
        "RightAnswer": "Dimensionality Reduction",
        "WrongAnswers": [
            "Data Normalization",
            "Feature Engineering",
            "Data Augmentation",
            "Ensemble Learning",
            "Hyperparameter Tuning"
        ],
        "Explanation": "Dimensionality Reduction refers to techniques that transform high-dimensional data into a lower-dimensional form while retaining meaningful properties of the original data. It helps address the 'curse of dimensionality'—problems that arise when analyzing data with many features. These techniques work by either selecting the most important features (feature selection) or creating new features that capture the essence of the original data (feature extraction). Common approaches include Principal Component Analysis (PCA), which identifies directions of maximum variance, and t-SNE, which preserves local relationships between data points. Dimensionality Reduction improves computational efficiency, reduces overfitting, eliminates noise, and makes visualization possible. It's widely used in image processing, text analysis, genomics, and other fields where high-dimensional data is common.",
        "trans_Question": "ɪn ə məʃíjn lɜ́rnɪŋ prɒ́dʒɛkt, juw níjd tə tǽkəl háj-dajmɛ́nʃənəl déjtə wɪð θáwzəndz əv fíjtʃərz ðət ɪz kɒ́zɪŋ slów pərfɔ́rməns ənd òwvərfɪ́tɪŋ. wɪ́tʃ tɛkníjk wʊd juw əpláj tə rədjúws ðə nʌ́mbər əv vɛ́ərijəbəlz wájl prəzɜ́rvɪŋ ðə mówst ɪmpɔ́rtənt ɪnfərméjʃən?",
        "trans_RightAnswer": "dajmɛ̀nʃənǽlɪtij rədʌ́kʃən",
        "trans_WrongAnswers": [
            "déjtə nɔ̀rməlɪzéjʃən",
            "fíjtʃər ɛ̀ndʒɪnɪ́ərɪŋ",
            "déjtə ɒ̀ɡmɛntéjʃən",
            "ɒnsɒ́mbəl lɜ́rnɪŋ",
            "hàjpərpǽrəmətər túwnɪŋ"
        ],
        "trans_Explanation": "dajmɛ̀nʃənǽlɪtij rədʌ́kʃən rəfɜ́rz tə tɛkníjks ðət trǽnsfɔrm háj-dajmɛ́nʃənəl déjtə ɪntə ə lówər-dajmɛ́nʃənəl fɔ́rm wájl rijtéjnɪŋ míjnɪŋfəl prɒ́pərtijz əv ðə ərɪ́dʒɪnəl déjtə. ɪt hɛ́lps æ̀drɛ́s ðə 'kɜ́rs əv dajmɛ̀nʃənǽlɪtij'—prɒ́bləmz ðət ərájz wɛ́n ǽnəlàjzɪŋ déjtə wɪð mɛ́nij fíjtʃərz. ðijz tɛkníjks wɜ́rk baj ájðər səlɛ́ktɪŋ ðə mówst ɪmpɔ́rtənt fíjtʃərz (fíjtʃər səlɛ́kʃən) ɔr krijéjtɪŋ núw fíjtʃərz ðət kǽptʃər ðə ɛ́səns əv ðə ərɪ́dʒɪnəl déjtə (fíjtʃər əkstrǽkʃən). kɒ́mən əprówtʃɪz ɪnklúwd prɪ́nsɪpəl kəmpównənt ənǽlɪsɪs (PCA), wɪ́tʃ ajdɛ́ntɪfàjz dɪərɛ́kʃənz əv mǽksɪməm vɛ́ərijəns, ənd t-SNE, wɪ́tʃ prəzɜ́rvz lówkəl rəléjʃənʃɪ̀ps bijtwíjn déjtə pɔ́jnts. dajmɛ̀nʃənǽlɪtij rədʌ́kʃən ɪmprúwvz kɒ̀mpjuwtéjʃənəl əfɪ́ʃənsij, rədjúwsɪz òwvərfɪ́tɪŋ, əlɪ́mɪnèjts nɔ́jz, ənd méjks vɪ̀ʒwəlɪzéjʃən pɒ́sɪbəl. ɪt's wájdlij júwzd ɪn ɪ́mɪdʒ prɒ́sɛsɪŋ, tɛ́kst ənǽlɪsɪs, dʒìjnówmɪks, ənd ʌ́ðər fíjldz wɛ́ər háj-dajmɛ́nʃənəl déjtə ɪz kɒ́mən."
    },
    {
        "Question": "Which data analysis technique is primarily used to reduce the dimensionality of large datasets while preserving as much variance as possible?",
        "RightAnswer": "Principal Component Analysis",
        "WrongAnswers": [
            "Random Forest Decomposition",
            "Hierarchical Cluster Analysis",
            "Singular Value Integration",
            "Vector Space Normalization",
            "Dimensional Frequency Mapping"
        ],
        "Explanation": "Principal Component Analysis (PCA) is a powerful statistical technique used in computer science and data analysis to simplify complex datasets. It works by transforming a large set of possibly correlated variables into a smaller set of uncorrelated variables called principal components. These components are ordered so that the first few retain most of the variation present in all of the original variables. Essentially, PCA finds the directions (or components) along which your data varies the most, allowing you to reduce dimensionality while losing as little information as possible. This makes it invaluable for data visualization, compression, and as a preprocessing step for many machine learning algorithms. By reducing the number of features, PCA can help mitigate the curse of dimensionality, improve computational efficiency, and reduce noise in datasets, ultimately making patterns more discernible and analysis more tractable.",
        "trans_Question": "wɪ́tʃ déjtə ənǽlɪsɪs tɛkníjk ɪz prajmɛ́ərɪlij júwzd tə rədjúws ðə dajmɛ̀nʃənǽlɪtij əv lɑ́rdʒ déjtəsɛ̀ts wájl prəzɜ́rvɪŋ æz mʌtʃ vɛ́ərijəns æz pɒ́sɪbəl?",
        "trans_RightAnswer": "prɪ́nsɪpəl kəmpównənt ənǽlɪsɪs",
        "trans_WrongAnswers": [
            "rǽndəm fɔ́rəst dìjkəmpəzɪ́ʃən",
            "hàjərɑ́rkɪkəl klʌ́stər ənǽlɪsɪs",
            "sɪ́ŋɡjələr vǽljuw ɪntəɡrejʃən",
            "vɛ́ktər spéjs nɔ̀rməlɪzéjʃən",
            "dajmɛ́nʃənəl fríjkwənsij mǽpɪŋ"
        ],
        "trans_Explanation": "prɪ́nsɪpəl kəmpównənt ənǽlɪsɪs (PCA) ɪz ə páwərfəl stətɪ́stɪkəl tɛkníjk júwzd ɪn kəmpjúwtər sájəns ənd déjtə ənǽlɪsɪs tə sɪ́mpləfaj kɒ́mplɛks déjtəsɛ̀ts. ɪt wɜ́rks baj trænsfɔ́rmɪŋ ə lɑ́rdʒ sɛ́t əv pɒ́sɪblij kɔ́rəlèjtɪd vɛ́ərijəbəlz ɪntə ə smɔ́lər sɛ́t əv ʌ̀nkɔ́rəlèjtɪd vɛ́ərijəbəlz kɔ́ld prɪ́nsɪpəl kəmpównənts. ðijz kəmpównənts ɑr ɔ́rdərd sow ðət ðə fɜ́rst fjúw rijtéjn mówst əv ðə vɛ̀ərijéjʃən prɛ́zənt ɪn ɔl əv ðə ərɪ́dʒɪnəl vɛ́ərijəbəlz. əsɛ́nʃəlij, PCA fájndz ðə dɪərɛ́kʃənz (ɔr kəmpównənts) əlɔ́ŋ wɪ́tʃ jɔr déjtə vɛ́ərijz ðə mówst, əláwɪŋ juw tə rədjúws dajmɛ̀nʃənǽlɪtij wájl lúwzɪŋ æz lɪ́təl ɪnfərméjʃən æz pɒ́sɪbəl. ðɪs méjks ɪt ɪ̀nvǽljəbəl fɔr déjtə vɪ̀ʒwəlɪzéjʃən, kəmprɛ́ʃən, ənd æz ə prijprɒ́sɛsɪŋ stɛ́p fɔr mɛ́nij məʃíjn lɜ́rnɪŋ ǽlɡərɪ̀ðəmz. baj rədjúwsɪŋ ðə nʌ́mbər əv fíjtʃərz, PCA kən hɛ́lp mɪ́tɪɡèjt ðə kɜ́rs əv dajmɛ̀nʃənǽlɪtij, ɪmprúwv kɒ̀mpjuwtéjʃənəl əfɪ́ʃənsij, ənd rədjúws nɔ́jz ɪn déjtəsɛ̀ts, ʌ́ltɪmətlij méjkɪŋ pǽtərnz mɔr dɪsɜ́rnɪbəl ənd ənǽlɪsɪs mɔr trǽktəbəl."
    },
    {
        "Question": "Which mathematical technique is commonly used in data compression, recommendation systems, and facial recognition to reduce dimensionality while preserving important relationships?",
        "RightAnswer": "Singular Value Decomposition",
        "WrongAnswers": [
            "Principal Component Analysis",
            "Fast Fourier Transform",
            "Dimensionality Reduction Transform",
            "Eigenvalue Factorization",
            "Matrix Diagonalization Method"
        ],
        "Explanation": "Singular Value Decomposition (SVD) is a powerful mathematical technique used in computer science to break down a complex matrix into simpler, meaningful components. Think of it as a way to identify the most important patterns in data. SVD decomposes a matrix into three separate matrices that, when multiplied together, reconstruct the original data. The middle matrix contains 'singular values' that represent the importance of each pattern. By keeping only the largest singular values and their corresponding vectors, we can create lower-dimensional approximations of the original data that maintain the most significant relationships. This makes SVD invaluable for applications like image compression (where it helps identify which visual information can be discarded), recommendation systems (finding hidden relationships between users and items), noise reduction, and facial recognition. While mathematically sophisticated, SVD's power lies in its ability to reveal the underlying structure of data, allowing computer scientists to work with more manageable representations of complex information without losing essential features.",
        "trans_Question": "wɪ́tʃ mæ̀θəmǽtɪkəl tɛkníjk ɪz kɒ́mənlij júwzd ɪn déjtə kəmprɛ́ʃən, rɛ̀kəməndéjʃən sɪ́stəmz, ənd féjʃəl rɛ̀kəɡnɪ́ʃən tə rədjúws dajmɛ̀nʃənǽlɪtij wájl prəzɜ́rvɪŋ ɪmpɔ́rtənt rəléjʃənʃɪ̀ps?",
        "trans_RightAnswer": "sɪ́ŋɡjələr vǽljuw dìjkəmpəzɪ́ʃən",
        "trans_WrongAnswers": [
            "prɪ́nsɪpəl kəmpównənt ənǽlɪsɪs",
            "fǽst fʊ́rijèj trǽnsfɔrm",
            "dajmɛ̀nʃənǽlɪtij rədʌ́kʃən trǽnsfɔrm",
            "ájɡənvæ̀ljuw fæ̀ktərajzéjʃən",
            "méjtrɪks dajǽɡənəlajzéjʃən mɛ́θəd"
        ],
        "trans_Explanation": "sɪ́ŋɡjələr vǽljuw dìjkəmpəzɪ́ʃən (SVD) ɪz ə páwərfəl mæ̀θəmǽtɪkəl tɛkníjk júwzd ɪn kəmpjúwtər sájəns tə bréjk dawn ə kɒ́mplɛks méjtrɪks ɪntə sɪ́mplər, míjnɪŋfəl kəmpównənts. θɪ́ŋk əv ɪt æz ə wej tə ajdɛ́ntɪfàj ðə mówst ɪmpɔ́rtənt pǽtərnz ɪn déjtə. SVD dìjkəmpówzɪz ə méjtrɪks ɪntə θríj sɛ́pərət méjtrɪsɪz ðət, wɛ́n mʌ́ltɪplàjd təɡɛ́ðər, rìjkənstrʌ́kt ðə ərɪ́dʒɪnəl déjtə. ðə mɪ́dəl méjtrɪks kəntéjnz 'sɪ́ŋɡjələr vǽljuwz' ðət rɛ̀prəzɛ́nt ðə ɪmpɔ́rtəns əv ijtʃ pǽtərn. baj kíjpɪŋ ównlij ðə lɑ́rdʒəst sɪ́ŋɡjələr vǽljuwz ənd ðɛər kɔ̀rəspɒ́ndɪŋ vɛ́ktərz, wij kən krijéjt lówər-dajmɛ́nʃənəl əprɒ̀ksəméjʃənz əv ðə ərɪ́dʒɪnəl déjtə ðət mejntéjn ðə mówst sɪɡnɪ́fɪkənt rəléjʃənʃɪ̀ps. ðɪs méjks SVD ɪ̀nvǽljəbəl fɔr æ̀plɪkéjʃənz lájk ɪ́mɪdʒ kəmprɛ́ʃən (wɛ́ər ɪt hɛ́lps ajdɛ́ntɪfàj wɪ́tʃ vɪ́ʒəwəl ɪnfərméjʃən kən bij dɪskɑ́rdɪd), rɛ̀kəməndéjʃən sɪ́stəmz (fájndɪŋ hɪ́dən rəléjʃənʃɪ̀ps bijtwíjn júwzərz ənd ájtəmz), nɔ́jz rədʌ́kʃən, ənd féjʃəl rɛ̀kəɡnɪ́ʃən. wájl mæ̀θəmǽtɪkəlij səfɪ́stɪkèjtɪd, SVD'z páwər lájz ɪn ɪts əbɪ́lɪtij tə rəvíjl ðə ʌ̀ndərlájɪŋ strʌ́ktʃər əv déjtə, əláwɪŋ kəmpjúwtər sájəntɪsts tə wɜ́rk wɪð mɔr mǽnədʒəbəl rɛ̀prəzəntéjʃənz əv kɒ́mplɛks ɪnfərméjʃən wɪðáwt lúwzɪŋ əsɛ́nʃəl fíjtʃərz."
    },
    {
        "Question": "Which data analysis technique is primarily used to model relationships between dependent and independent variables, allowing for predictions of continuous values based on historical data patterns?",
        "RightAnswer": "Regression Analysis",
        "WrongAnswers": [
            "Binary Classification",
            "Cluster Sampling",
            "Decision Tree Pruning",
            "Dimensionality Augmentation",
            "Ensemble Stratification"
        ],
        "Explanation": "Regression Analysis is a statistical method used in computer science and data science to examine relationships between variables. It helps us understand how the value of a dependent variable changes when one or more independent variables are modified. In computer science applications, regression analysis is fundamental to predictive modeling and machine learning. It allows systems to learn patterns from existing data and make numerical predictions about future outcomes. For example, regression can predict house prices based on features like square footage and location, estimate sales based on advertising spend, or forecast website traffic based on historical patterns. Unlike classification, which predicts categorical outcomes, regression specifically deals with continuous numerical values. Common types include linear regression, which assumes a straight-line relationship between variables, and more complex forms like polynomial regression or ridge regression that can capture more nuanced relationships in data. Regression analysis serves as the foundation for many predictive algorithms in data science and artificial intelligence applications.",
        "trans_Question": "wɪ́tʃ déjtə ənǽlɪsɪs tɛkníjk ɪz prajmɛ́ərɪlij júwzd tə mɒ́dəl rəléjʃənʃɪ̀ps bijtwíjn dəpɛ́ndənt ənd ɪndəpɛ́ndənt vɛ́ərijəbəlz, əláwɪŋ fɔr prədɪ́kʃənz əv kəntɪ́njuwəs vǽljuwz béjst ɒn hɪstɔ́rɪkəl déjtə pǽtərnz?",
        "trans_RightAnswer": "rəɡrɛ́ʃən ənǽlɪsɪs",
        "trans_WrongAnswers": [
            "bájnərij klæ̀sɪfɪkéjʃən",
            "klʌ́stər sǽmplɪŋ",
            "dəsɪ́ʒən tríj prúwnɪŋ",
            "dajmɛ̀nʃənǽlɪtij ɒ̀ɡmɛntéjʃən",
            "ɒnsɒ́mbəl stræ̀tɪfɪkéjʃən"
        ],
        "trans_Explanation": "rəɡrɛ́ʃən ənǽlɪsɪs ɪz ə stətɪ́stɪkəl mɛ́θəd júwzd ɪn kəmpjúwtər sájəns ənd déjtə sájəns tə əɡzǽmɪn rəléjʃənʃɪ̀ps bijtwíjn vɛ́ərijəbəlz. ɪt hɛ́lps US ʌ̀ndərstǽnd háw ðə vǽljuw əv ə dəpɛ́ndənt vɛ́ərijəbəl tʃéjndʒɪz wɛ́n wʌ́n ɔr mɔr ɪndəpɛ́ndənt vɛ́ərijəbəlz ɑr mɒ́dɪfàjd. ɪn kəmpjúwtər sájəns æ̀plɪkéjʃənz, rəɡrɛ́ʃən ənǽlɪsɪs ɪz fʌ̀ndəmɛ́ntəl tə prədɪ́ktɪv mɒ́dəlɪ̀ŋ ənd məʃíjn lɜ́rnɪŋ. ɪt əláwz sɪ́stəmz tə lɜ́rn pǽtərnz frəm əɡzɪ́stɪŋ déjtə ənd méjk njuwmɛ́ərɪkəl prədɪ́kʃənz əbawt fjúwtʃər áwtkʌ̀mz. fɔr əɡzǽmpəl, rəɡrɛ́ʃən kən prədɪ́kt haws prájsɪz béjst ɒn fíjtʃərz lájk skwɛ́ər fʊ́tɪdʒ ənd lowkéjʃən, ɛ́stɪmèjt séjlz béjst ɒn ǽdvərtàjzɪŋ spɛ́nd, ɔr fɔ́rkæ̀st wɛ́bsàjt trǽfɪk béjst ɒn hɪstɔ́rɪkəl pǽtərnz. ʌ̀nlájk klæ̀sɪfɪkéjʃən, wɪ́tʃ prədɪ́kts kæ̀təɡɑ́rɪkəl áwtkʌ̀mz, rəɡrɛ́ʃən spəsɪ́fɪklij díjlz wɪð kəntɪ́njuwəs njuwmɛ́ərɪkəl vǽljuwz. kɒ́mən tájps ɪnklúwd lɪ́nijər rəɡrɛ́ʃən, wɪ́tʃ əsúwmz ə stréjt-lájn rəléjʃənʃɪ̀p bijtwíjn vɛ́ərijəbəlz, ənd mɔr kɒ́mplɛks fɔ́rmz lájk pɒ̀lijnówmijəl rəɡrɛ́ʃən ɔr rɪ́dʒ rəɡrɛ́ʃən ðət kən kǽptʃər mɔr njúwɑnst rəléjʃənʃɪ̀ps ɪn déjtə. rəɡrɛ́ʃən ənǽlɪsɪs sɜ́rvz æz ðə fawndéjʃən fɔr mɛ́nij prədɪ́ktɪv ǽlɡərɪ̀ðəmz ɪn déjtə sájəns ənd ɑ̀rtɪfɪ́ʃəl ɪntɛ́lɪdʒəns æ̀plɪkéjʃənz."
    },
    {
        "Question": "Which machine learning algorithm establishes a straight-line relationship between input variables and a continuous output variable, attempting to minimize the sum of squared differences between predicted and actual values?",
        "RightAnswer": "Linear Regression",
        "WrongAnswers": [
            "K-Means Clustering",
            "Decision Tree",
            "Random Forest",
            "Support Vector Machine",
            "Neural Network"
        ],
        "Explanation": "Linear Regression is a fundamental supervised learning algorithm in computer science that models the relationship between independent variables (inputs) and a dependent variable (output) by fitting a linear equation to the observed data. It works by finding the best-fitting straight line through the points that minimizes the total prediction error. This error is typically measured as the sum of squared differences between the predicted values and the actual values. Linear Regression is particularly useful for prediction tasks where the output is a continuous value, such as predicting house prices, sales forecasts, or temperature trends. Its simplicity makes it computationally efficient and interpretable, as the coefficients of the model directly indicate the effect each input variable has on the output. While it assumes a linear relationship between variables and can underperform with complex, non-linear data patterns, Linear Regression remains a powerful starting point for many predictive modeling tasks and serves as a foundation for more advanced regression techniques.",
        "trans_Question": "wɪ́tʃ məʃíjn lɜ́rnɪŋ ǽlɡərɪ̀ðəm əstǽblɪʃɪz ə stréjt-lájn rəléjʃənʃɪ̀p bijtwíjn ɪ́npʊ̀t vɛ́ərijəbəlz ənd ə kəntɪ́njuwəs áwtpʊ̀t vɛ́ərijəbəl, ətɛ́mptɪŋ tə mɪ́nɪmàjz ðə sʌ́m əv skwɛ́ərd dɪ́fərənsɪz bijtwíjn prədɪ́ktɪd ənd ǽktʃəl vǽljuwz?",
        "trans_RightAnswer": "lɪ́nijər rəɡrɛ́ʃən",
        "trans_WrongAnswers": [
            "k-míjnz klʌ́stərɪŋ",
            "dəsɪ́ʒən tríj",
            "rǽndəm fɔ́rəst",
            "səpɔ́rt vɛ́ktər məʃíjn",
            "nʊ́rəl nɛ́twɜ̀rk"
        ],
        "trans_Explanation": "lɪ́nijər rəɡrɛ́ʃən ɪz ə fʌ̀ndəmɛ́ntəl súwpərvàjzd lɜ́rnɪŋ ǽlɡərɪ̀ðəm ɪn kəmpjúwtər sájəns ðət mɒ́dəlz ðə rəléjʃənʃɪ̀p bijtwíjn ɪndəpɛ́ndənt vɛ́ərijəbəlz (ɪ́npʊ̀ts) ənd ə dəpɛ́ndənt vɛ́ərijəbəl (áwtpʊ̀t) baj fɪ́tɪŋ ə lɪ́nijər əkwéjʒən tə ðə əbzɜ́rvd déjtə. ɪt wɜ́rks baj fájndɪŋ ðə bɛ́st-fɪ́tɪŋ stréjt lájn θrúw ðə pɔ́jnts ðət mɪ́nɪmàjzɪz ðə tówtəl prədɪ́kʃən ɛ́ərər. ðɪs ɛ́ərər ɪz tɪ́pɪkəlij mɛ́ʒərd æz ðə sʌ́m əv skwɛ́ərd dɪ́fərənsɪz bijtwíjn ðə prədɪ́ktɪd vǽljuwz ənd ðə ǽktʃəl vǽljuwz. lɪ́nijər rəɡrɛ́ʃən ɪz pərtɪ́kjələrlij júwsfəl fɔr prədɪ́kʃən tǽsks wɛ́ər ðə áwtpʊ̀t ɪz ə kəntɪ́njuwəs vǽljuw, sʌtʃ æz prədɪ́ktɪŋ haws prájsɪz, séjlz fɔ́rkæ̀s, ɔr tɛ́mpərətʃər trɛ́ndz. ɪts sɪmplɪ́sɪtij méjks ɪt kɒ̀mpjətéjʃənəlij əfɪ́ʃənt ənd ɪntɜ́rprətəbəl, æz ðə kòwəfɪ́ʃənts əv ðə mɒ́dəl dɪərɛ́klij ɪ́ndɪkèjt ðə əfɛ́kt ijtʃ ɪ́npʊ̀t vɛ́ərijəbəl həz ɒn ðə áwtpʊ̀t. wájl ɪt əsúwmz ə lɪ́nijər rəléjʃənʃɪ̀p bijtwíjn vɛ́ərijəbəlz ənd kən ʌ́ndərpərfɔ̀rm wɪð kɒ́mplɛks, nɒn-lɪ́nijər déjtə pǽtərnz, lɪ́nijər rəɡrɛ́ʃən rəméjnz ə páwərfəl stɑ́rtɪŋ pɔ́jnt fɔr mɛ́nij prədɪ́ktɪv mɒ́dəlɪ̀ŋ tǽsks ənd sɜ́rvz æz ə fawndéjʃən fɔr mɔr ədvǽnst rəɡrɛ́ʃən tɛkníjks."
    },
    {
        "Question": "Which machine learning algorithm is specifically designed for binary classification problems and outputs probabilities between 0 and 1 using a sigmoid function?",
        "RightAnswer": "Logistic Regression",
        "WrongAnswers": [
            "K-Means Clustering",
            "Principal Component Analysis",
            "Random Forest",
            "Linear Regression",
            "Support Vector Machine"
        ],
        "Explanation": "Logistic Regression is a fundamental supervised machine learning algorithm used primarily for binary classification problems despite its name containing the word 'regression'. Unlike linear regression that predicts continuous values, logistic regression predicts the probability that an instance belongs to a particular class. It transforms its output using the sigmoid function to return a probability value between 0 and 1. This makes it particularly useful for yes/no decisions such as spam detection, disease diagnosis, or customer churn prediction. The algorithm works by finding the best weights for input features to maximize the likelihood of observing the sample values. While simple compared to more complex algorithms like neural networks, logistic regression remains popular in data science due to its interpretability, efficiency, and effectiveness for many classification tasks. It serves as both a practical tool for real-world applications and an important foundational concept for understanding more advanced classification techniques.",
        "trans_Question": "wɪ́tʃ məʃíjn lɜ́rnɪŋ ǽlɡərɪ̀ðəm ɪz spəsɪ́fɪklij dəzájnd fɔr bájnərij klæ̀sɪfɪkéjʃən prɒ́bləmz ənd áwtpʊ̀ts prɒ̀bəbɪ́lɪtìjz bijtwíjn 0 ənd 1 júwzɪŋ ə sɪ́ɡmɔ̀jd fʌ́ŋkʃən?",
        "trans_RightAnswer": "lədʒɪ́stɪk rəɡrɛ́ʃən",
        "trans_WrongAnswers": [
            "k-míjnz klʌ́stərɪŋ",
            "prɪ́nsɪpəl kəmpównənt ənǽlɪsɪs",
            "rǽndəm fɔ́rəst",
            "lɪ́nijər rəɡrɛ́ʃən",
            "səpɔ́rt vɛ́ktər məʃíjn"
        ],
        "trans_Explanation": "lədʒɪ́stɪk rəɡrɛ́ʃən ɪz ə fʌ̀ndəmɛ́ntəl súwpərvàjzd məʃíjn lɜ́rnɪŋ ǽlɡərɪ̀ðəm júwzd prajmɛ́ərɪlij fɔr bájnərij klæ̀sɪfɪkéjʃən prɒ́bləmz dəspájt ɪts néjm kəntéjnɪŋ ðə wɜ́rd 'rəɡrɛ́ʃən'. ʌ̀nlájk lɪ́nijər rəɡrɛ́ʃən ðət prədɪ́kts kəntɪ́njuwəs vǽljuwz, lədʒɪ́stɪk rəɡrɛ́ʃən prədɪ́kts ðə prɒ̀bəbɪ́lɪtij ðət ən ɪ́nstəns bəlɔ́ŋz tə ə pərtɪ́kjələr klǽs. ɪt trænsfɔ́rmz ɪts áwtpʊ̀t júwzɪŋ ðə sɪ́ɡmɔ̀jd fʌ́ŋkʃən tə rətɜ́rn ə prɒ̀bəbɪ́lɪtij vǽljuw bijtwíjn 0 ənd 1. ðɪs méjks ɪt pərtɪ́kjələrlij júwsfəl fɔr jɛs/now dəsɪ́ʒənz sʌtʃ æz spǽm dətɛ́kʃən, dɪzíjz dàjəɡnówsɪs, ɔr kʌ́stəmər tʃɜ́rn prədɪ́kʃən. ðə ǽlɡərɪ̀ðəm wɜ́rks baj fájndɪŋ ðə bɛ́st wéjts fɔr ɪ́npʊ̀t fíjtʃərz tə mǽksɪmàjz ðə lájklijhʊ̀d əv əbzɜ́rvɪŋ ðə sǽmpəl vǽljuwz. wájl sɪ́mpəl kəmpɛ́ərd tə mɔr kɒ́mplɛks ǽlɡərɪ̀ðəmz lájk nʊ́rəl nɛ́twɜ̀rks, lədʒɪ́stɪk rəɡrɛ́ʃən rəméjnz pɒ́pjələr ɪn déjtə sájəns djúw tə ɪts ɪntɜ̀rprɛtəbɪ́lɪtij, əfɪ́ʃənsij, ənd əfɛ́ktɪvnəs fɔr mɛ́nij klæ̀sɪfɪkéjʃən tǽsks. ɪt sɜ́rvz æz bówθ ə prǽktɪkəl túwl fɔr ríjəl-wɜ́rld æ̀plɪkéjʃənz ənd ən ɪmpɔ́rtənt fawndéjʃənəl kɒ́nsɛpt fɔr ʌ̀ndərstǽndɪŋ mɔr ədvǽnst klæ̀sɪfɪkéjʃən tɛkníjks."
    },
    {
        "Question": "Which phenomenon occurs when a machine learning model captures noise and random fluctuations in training data, leading to poor performance on new data despite high accuracy on training data?",
        "RightAnswer": "Overfitting",
        "WrongAnswers": [
            "Underfitting",
            "Data leakage",
            "Feature saturation",
            "Model convergence",
            "Hyperparameter drift"
        ],
        "Explanation": "Overfitting is a common challenge in machine learning where a model learns the training data too well. Rather than identifying meaningful patterns that generalize to new data, an overfit model essentially memorizes the training examples, including their noise and random variations. This creates a deceptive situation where the model shows excellent performance metrics on training data but fails to make accurate predictions when faced with new, unseen data. Think of it like a student who memorizes specific exam questions instead of understanding the underlying concepts—they'll excel on those exact questions but struggle with new problems. Overfitting typically occurs when models are too complex relative to the amount of training data available, allowing them to create highly specific decision boundaries that don't represent the true relationship between features and outcomes. Data scientists combat overfitting through techniques like cross-validation, regularization, early stopping, and ensuring sufficient training data.",
        "trans_Question": "wɪ́tʃ fənɒ́mənɒn əkɜ́rz wɛ́n ə məʃíjn lɜ́rnɪŋ mɒ́dəl kǽptʃərz nɔ́jz ənd rǽndəm flʌ̀ktʃuwéjʃənz ɪn tréjnɪŋ déjtə, líjdɪŋ tə pɔ́r pərfɔ́rməns ɒn núw déjtə dəspájt háj ǽkjərəsij ɒn tréjnɪŋ déjtə?",
        "trans_RightAnswer": "òwvərfɪ́tɪŋ",
        "trans_WrongAnswers": [
            "ʌ̀ndərfɪ́tɪŋ",
            "déjtə líjkɪdʒ",
            "fíjtʃər sæ̀tʃəréjʃən",
            "mɒ́dəl kənvɜ́rdʒəns",
            "hàjpərpǽrəmətər drɪ́ft"
        ],
        "trans_Explanation": "òwvərfɪ́tɪŋ ɪz ə kɒ́mən tʃǽləndʒ ɪn məʃíjn lɜ́rnɪŋ wɛ́ər ə mɒ́dəl lɜ́rnz ðə tréjnɪŋ déjtə túw wɛ́l. rǽðər ðʌn ajdɛ́ntɪfàjɪŋ míjnɪŋfəl pǽtərnz ðət dʒɛ́nərəlàjz tə núw déjtə, ən ówvərfɪt mɒ́dəl əsɛ́nʃəlij mɛ́məràjzɪz ðə tréjnɪŋ əɡzǽmpəlz, ɪnklúwdɪŋ ðɛər nɔ́jz ənd rǽndəm vɛ̀ərijéjʃənz. ðɪs krijéjts ə dəsɛ́ptɪv sɪ̀tʃuwéjʃən wɛ́ər ðə mɒ́dəl ʃówz ɛ́ksələnt pərfɔ́rməns mɛ́trɪks ɒn tréjnɪŋ déjtə bʌt féjlz tə méjk ǽkjərət prədɪ́kʃənz wɛ́n féjst wɪð núw, ʌ̀nsíjn déjtə. θɪ́ŋk əv ɪt lájk ə stúwdənt huw mɛ́məràjzɪz spəsɪ́fɪk əɡzǽm kwɛ́stʃənz ɪnstɛ́d əv ʌ̀ndərstǽndɪŋ ðə ʌ̀ndərlájɪŋ kɒ́nsɛpts—ðéjl əksɛ́l ɒn ðowz əɡzǽkt kwɛ́stʃənz bʌt strʌ́ɡəl wɪð núw prɒ́bləmz. òwvərfɪ́tɪŋ tɪ́pɪkəlij əkɜ́rz wɛ́n mɒ́dəlz ɑr túw kɒ́mplɛks rɛ́lətɪv tə ðə əmáwnt əv tréjnɪŋ déjtə əvéjləbəl, əláwɪŋ ðɛm tə krijéjt hájlij spəsɪ́fɪk dəsɪ́ʒən báwndərijz ðət dównt rɛ̀prəzɛ́nt ðə trúw rəléjʃənʃɪ̀p bijtwíjn fíjtʃərz ənd áwtkʌ̀mz. déjtə sájəntɪsts kɒ́mbæt òwvərfɪ́tɪŋ θrúw tɛkníjks lájk krɔ́s-væ̀lɪdéjʃən, rèɡjəlɛ̀ərɪzéjʃən, ɜ́rlij stɒ́pɪŋ, ənd ɛnʃʊ́rɪŋ səfɪ́ʃənt tréjnɪŋ déjtə."
    },
    {
        "Question": "What term describes the phenomenon in machine learning where a model is too simplistic to capture the underlying patterns in the training data, resulting in poor performance on both training and test sets?",
        "RightAnswer": "Underfitting",
        "WrongAnswers": [
            "Overfitting",
            "Regularization",
            "Cross-validation",
            "Feature scaling",
            "Data augmentation"
        ],
        "Explanation": "Underfitting occurs when a machine learning model is too simple to capture the important relationships in the data. This could happen when using a linear model for complex nonlinear data, or when training a neural network with too few layers or neurons. An underfit model performs poorly on both training data and new, unseen data because it has failed to learn the underlying patterns. It's essentially making too many generalized assumptions and missing important nuances. Imagine trying to draw a complex landscape using only straight lines - the result would be a crude approximation that misses critical details. In machine learning, addressing underfitting typically involves increasing model complexity, training for more epochs, or providing more relevant features to help the model better understand the data's true structure.",
        "trans_Question": "wɒt tɜ́rm dəskrájbz ðə fənɒ́mənɒn ɪn məʃíjn lɜ́rnɪŋ wɛ́ər ə mɒ́dəl ɪz túw sɪmplɪ́stɪk tə kǽptʃər ðə ʌ̀ndərlájɪŋ pǽtərnz ɪn ðə tréjnɪŋ déjtə, rəzʌ́ltɪŋ ɪn pɔ́r pərfɔ́rməns ɒn bówθ tréjnɪŋ ənd tɛ́st sɛ́ts?",
        "trans_RightAnswer": "ʌ̀ndərfɪ́tɪŋ",
        "trans_WrongAnswers": [
            "òwvərfɪ́tɪŋ",
            "rèɡjəlɛ̀ərɪzéjʃən",
            "krɔ́s-væ̀lɪdéjʃən",
            "fíjtʃər skéjlɪŋ",
            "déjtə ɒ̀ɡmɛntéjʃən"
        ],
        "trans_Explanation": "ʌ̀ndərfɪ́tɪŋ əkɜ́rz wɛ́n ə məʃíjn lɜ́rnɪŋ mɒ́dəl ɪz túw sɪ́mpəl tə kǽptʃər ðə ɪmpɔ́rtənt rəléjʃənʃɪ̀ps ɪn ðə déjtə. ðɪs kʊ́d hǽpən wɛ́n júwzɪŋ ə lɪ́nijər mɒ́dəl fɔr kɒ́mplɛks nɒnlɪ́nìjər déjtə, ɔr wɛ́n tréjnɪŋ ə nʊ́rəl nɛ́twɜ̀rk wɪð túw fjúw léjərz ɔr nʊ́rɒnz. ən ʌ̀ndərfɪ́t mɒ́dəl pərfɔ́rmz pɔ́rlij ɒn bówθ tréjnɪŋ déjtə ənd núw, ʌ̀nsíjn déjtə bəkɒ́z ɪt həz féjld tə lɜ́rn ðə ʌ̀ndərlájɪŋ pǽtərnz. ɪt's əsɛ́nʃəlij méjkɪŋ túw mɛ́nij dʒɛ́nərəlàjzd əsʌ́mpʃənz ənd mɪ́sɪŋ ɪmpɔ́rtənt njúwɑnsɪz. ɪmǽdʒɪn trájɪŋ tə drɔ́ ə kɒ́mplɛks lǽnskèjp júwzɪŋ ównlij stréjt lájnz - ðə rəzʌ́lt wʊd bij ə krúwd əprɒ̀ksəméjʃən ðət mɪ́sɪz krɪ́tɪkəl díjtejlz. ɪn məʃíjn lɜ́rnɪŋ, ədrɛ́sɪŋ ʌ̀ndərfɪ́tɪŋ tɪ́pɪkəlij ɪnvɒ́lvz ɪnkríjsɪŋ mɒ́dəl kəmplɛ́ksɪtij, tréjnɪŋ fɔr mɔr ɛ́pəks, ɔr prəvájdɪŋ mɔr rɛ́ləvənt fíjtʃərz tə hɛ́lp ðə mɒ́dəl bɛ́tər ʌ̀ndərstǽnd ðə déjtə'z trúw strʌ́ktʃər."
    },
    {
        "Question": "In machine learning, which technique involves partitioning data into subsets to evaluate algorithm performance on unseen data, helping prevent overfitting?",
        "RightAnswer": "Cross-Validation",
        "WrongAnswers": [
            "Data Normalization",
            "Feature Engineering",
            "Grid Search",
            "Ensemble Learning",
            "Hyperparameter Tuning"
        ],
        "Explanation": "Cross-Validation is a fundamental statistical method in machine learning where the available data is systematically divided into multiple subsets. The model is then trained on some of these subsets and tested on the remaining ones. This process is typically repeated several times, with different partitions of the data serving as training and testing sets each time. The key benefit of cross-validation is that it provides a more accurate estimate of how well a model will perform on new, unseen data. This helps data scientists identify and prevent overfitting, which occurs when a model performs exceptionally well on training data but poorly on new data because it has essentially memorized the training examples rather than learning the underlying patterns. Common approaches include k-fold cross-validation, where data is split into k equal parts, and leave-one-out cross-validation, where each data point gets a chance to be the test case. By incorporating cross-validation into the model development process, practitioners can build more robust and generalizable machine learning solutions.",
        "trans_Question": "ɪn məʃíjn lɜ́rnɪŋ, wɪ́tʃ tɛkníjk ɪnvɒ́lvz pɑrtɪ́ʃənɪŋ déjtə ɪntə sʌ́bsɛ̀ts tə əvǽljuwèjt ǽlɡərɪ̀ðəm pərfɔ́rməns ɒn ʌ̀nsíjn déjtə, hɛ́lpɪŋ prəvɛ́nt òwvərfɪ́tɪŋ?",
        "trans_RightAnswer": "krɔ́s-væ̀lɪdéjʃən",
        "trans_WrongAnswers": [
            "déjtə nɔ̀rməlɪzéjʃən",
            "fíjtʃər ɛ̀ndʒɪnɪ́ərɪŋ",
            "ɡrɪ́d sɜ́rtʃ",
            "ɒnsɒ́mbəl lɜ́rnɪŋ",
            "hàjpərpǽrəmətər túwnɪŋ"
        ],
        "trans_Explanation": "krɔ́s-væ̀lɪdéjʃən ɪz ə fʌ̀ndəmɛ́ntəl stətɪ́stɪkəl mɛ́θəd ɪn məʃíjn lɜ́rnɪŋ wɛ́ər ðə əvéjləbəl déjtə ɪz sɪ̀stəmǽtɪklij dɪvájdɪd ɪntə mʌ́ltɪpəl sʌ́bsɛ̀ts. ðə mɒ́dəl ɪz ðɛn tréjnd ɒn sʌm əv ðijz sʌ́bsɛ̀ts ənd tɛ́stɪd ɒn ðə rəméjnɪŋ wʌ́nz. ðɪs prɒ́sɛs ɪz tɪ́pɪkəlij rəpíjtɪd sɛ́vərəl tájmz, wɪð dɪ́fərənt pɑrtɪ́ʃənz əv ðə déjtə sɜ́rvɪŋ æz tréjnɪŋ ənd tɛ́stɪŋ sɛ́ts ijtʃ tájm. ðə kíj bɛ́nəfɪt əv krɔ́s-væ̀lɪdéjʃən ɪz ðət ɪt prəvájdz ə mɔr ǽkjərət ɛ́stɪmèjt əv háw wɛ́l ə mɒ́dəl wɪl pərfɔ́rm ɒn núw, ʌ̀nsíjn déjtə. ðɪs hɛ́lps déjtə sájəntɪsts ajdɛ́ntɪfàj ənd prəvɛ́nt òwvərfɪ́tɪŋ, wɪ́tʃ əkɜ́rz wɛ́n ə mɒ́dəl pərfɔ́rmz əksɛ́pʃənəlij wɛ́l ɒn tréjnɪŋ déjtə bʌt pɔ́rlij ɒn núw déjtə bəkɒ́z ɪt həz əsɛ́nʃəlij mɛ́məràjzd ðə tréjnɪŋ əɡzǽmpəlz rǽðər ðʌn lɜ́rnɪŋ ðə ʌ̀ndərlájɪŋ pǽtərnz. kɒ́mən əprówtʃɪz ɪnklúwd k-fówld krɔ́s-væ̀lɪdéjʃən, wɛ́ər déjtə ɪz splɪ́t ɪntə k íjkwəl pɑ́rts, ənd líjv-wʌ́n-awt krɔ́s-væ̀lɪdéjʃən, wɛ́ər ijtʃ déjtə pɔ́jnt ɡɛ́ts ə tʃǽns tə bij ðə tɛ́st kéjs. baj ɪnkɔ́rpərejtɪŋ krɔ́s-væ̀lɪdéjʃən ɪntə ðə mɒ́dəl dəvɛ́ləpmənt prɒ́sɛs, præktɪ́ʃənərz kən bɪ́ld mɔr rowbʌ́st ənd dʒɛ́nrəlàjzəbəl məʃíjn lɜ́rnɪŋ səlúwʃənz."
    },
    {
        "Question": "In machine learning, what is the process of systematically searching for the optimal configuration of model settings that are not learned during training?",
        "RightAnswer": "Hyperparameter Tuning",
        "WrongAnswers": [
            "Feature Engineering",
            "Gradient Optimization",
            "Model Compression",
            "Parameter Initialization",
            "Ensemble Bootstrapping"
        ],
        "Explanation": "Hyperparameter Tuning is the methodical process of finding the optimal configuration of hyperparameters for a machine learning algorithm. Unlike regular parameters that are learned during model training, hyperparameters are set before the learning process begins and control aspects of the algorithm itself. For example, in a neural network, hyperparameters might include the learning rate, number of hidden layers, or regularization strength. Tuning these values is crucial because they significantly impact model performance, but there's rarely a one-size-fits-all configuration. Data scientists typically use techniques like grid search, random search, or Bayesian optimization to efficiently explore different hyperparameter combinations, evaluating each on validation data to find the settings that produce the best model. Effective hyperparameter tuning can be the difference between a mediocre model and one that achieves state-of-the-art results.",
        "trans_Question": "ɪn məʃíjn lɜ́rnɪŋ, wɒt ɪz ðə prɒ́sɛs əv sɪ̀stəmǽtɪklij sɜ́rtʃɪŋ fɔr ðə ɒ́ptɪməl kənfɪ̀ɡjəréjʃən əv mɒ́dəl sɛ́tɪŋz ðət ɑr nɒt lɜ́rnd dʊ́rɪŋ tréjnɪŋ?",
        "trans_RightAnswer": "hàjpərpǽrəmətər túwnɪŋ",
        "trans_WrongAnswers": [
            "fíjtʃər ɛ̀ndʒɪnɪ́ərɪŋ",
            "ɡréjdijənt ɒptɪmɪzéjʃən",
            "mɒ́dəl kəmprɛ́ʃən",
            "pərǽmətər ɪnɪ́ʃəlɪzéjʃən",
            "ɒnsɒ́mbəl búwtstræ̀pɪŋ"
        ],
        "trans_Explanation": "hàjpərpǽrəmətər túwnɪŋ ɪz ðə məθɒ́dɪkəl prɒ́sɛs əv fájndɪŋ ðə ɒ́ptɪməl kənfɪ̀ɡjəréjʃən əv hàjpərpǽrəmətərz fɔr ə məʃíjn lɜ́rnɪŋ ǽlɡərɪ̀ðəm. ʌ̀nlájk rɛ́ɡjələr pərǽmətərz ðət ɑr lɜ́rnd dʊ́rɪŋ mɒ́dəl tréjnɪŋ, hàjpərpǽrəmətərz ɑr sɛ́t bəfɔ́r ðə lɜ́rnɪŋ prɒ́sɛs bəɡɪ́nz ənd kəntrówl ǽspɛkts əv ðə ǽlɡərɪ̀ðəm ɪtsɛ́lf. fɔr əɡzǽmpəl, ɪn ə nʊ́rəl nɛ́twɜ̀rk, hàjpərpǽrəmətərz majt ɪnklúwd ðə lɜ́rnɪŋ réjt, nʌ́mbər əv hɪ́dən léjərz, ɔr rèɡjəlɛ̀ərɪzéjʃən strɛ́ŋθ. túwnɪŋ ðijz vǽljuwz ɪz krúwʃəl bəkɒ́z ðej sɪɡnɪ́fɪkəntlij ɪ́mpækt mɒ́dəl pərfɔ́rməns, bʌt ðɛər'z rɛ́ərlij ə wʌ́n-sájz-fɪ́ts-ɔl kənfɪ̀ɡjəréjʃən. déjtə sájəntɪsts tɪ́pɪkəlij juwz tɛkníjks lájk ɡrɪ́d sɜ́rtʃ, rǽndəm sɜ́rtʃ, ɔr béjʒən ɒptɪmɪzéjʃən tə əfɪ́ʃəntlij əksplɔ́r dɪ́fərənt hàjpərpǽrəmətər kɒ̀mbɪnéjʃənz, əvǽljuwèjtɪŋ ijtʃ ɒn væ̀lɪdéjʃən déjtə tə fájnd ðə sɛ́tɪŋz ðət prədúws ðə bɛ́st mɒ́dəl. əféktɪv hàjpərpǽrəmətər túwnɪŋ kən bij ðə dɪ́fərəns bijtwíjn ə mìjdijówkər mɒ́dəl ənd wʌ́n ðət ətʃíjvz stéjt-əv-ðə-ɑ́rt rəzʌ́lts."
    },
    {
        "Question": "When a data scientist is building a machine learning model and faces a situation where improving accuracy on training data leads to worse performance on unseen data, which fundamental concept is being encountered?",
        "RightAnswer": "Bias-Variance Tradeoff",
        "WrongAnswers": [
            "Gradient Descent Paradox",
            "Feature Selection Dilemma",
            "Classification Ambiguity Problem",
            "Regularization Contradiction",
            "Training Saturation Effect"
        ],
        "Explanation": "The Bias-Variance Tradeoff is a foundational concept in machine learning that describes the tension between two sources of error. A model with high bias oversimplifies the underlying problem and tends to underfit the data, missing important patterns. Conversely, a model with high variance is overly complex and tends to overfit, essentially memorizing training examples rather than learning generalizable patterns. As you reduce bias by making your model more complex, you typically increase variance, and vice versa. Finding the optimal balance is crucial for creating models that perform well on new, unseen data. This tradeoff is why data scientists must carefully select model complexity, use techniques like cross-validation, and apply regularization methods to build robust predictive systems that generalize well beyond their training data.",
        "trans_Question": "wɛ́n ə déjtə sájəntɪst ɪz bɪ́ldɪŋ ə məʃíjn lɜ́rnɪŋ mɒ́dəl ənd féjsɪz ə sɪ̀tʃuwéjʃən wɛ́ər ɪmprúwvɪŋ ǽkjərəsij ɒn tréjnɪŋ déjtə líjdz tə wɜ́rs pərfɔ́rməns ɒn ʌ̀nsíjn déjtə, wɪ́tʃ fʌ̀ndəmɛ́ntəl kɒ́nsɛpt ɪz bíjɪŋ ənkáwntərd?",
        "trans_RightAnswer": "bájəs-vɛ́ərijəns tréjdɔ̀f",
        "trans_WrongAnswers": [
            "ɡréjdijənt dəsɛ́nt pǽrədɒ̀ks",
            "fíjtʃər səlɛ́kʃən dajlɛ́mə",
            "klæ̀sɪfɪkéjʃən æ̀mbɪɡjúwɪtij prɒ́bləm",
            "rèɡjəlɛ̀ərɪzéjʃən kɒ̀ntrədɪ́kʃən",
            "tréjnɪŋ sæ̀tʃəréjʃən əfɛ́kt"
        ],
        "trans_Explanation": "ðə bájəs-vɛ́ərijəns tréjdɔ̀f ɪz ə fawndéjʃənəl kɒ́nsɛpt ɪn məʃíjn lɜ́rnɪŋ ðət dəskrájbz ðə tɛ́nʃən bijtwíjn túw sɔ́rsɪz əv ɛ́ərər. ə mɒ́dəl wɪð háj bájəs òwvərsɪ́mplɪfajz ðə ʌ̀ndərlájɪŋ prɒ́bləm ənd tɛ́ndz tə ʌ̀ndərfɪ́t ðə déjtə, mɪ́sɪŋ ɪmpɔ́rtənt pǽtərnz. kɒ́nvərslij, ə mɒ́dəl wɪð háj vɛ́ərijəns ɪz ówvərlij kɒ́mplɛks ənd tɛ́ndz tə ówvərfɪt, əsɛ́nʃəlij mɛ́məràjzɪŋ tréjnɪŋ əɡzǽmpəlz rǽðər ðʌn lɜ́rnɪŋ dʒɛ́nrəlàjzəbəl pǽtərnz. æz juw rədjúws bájəs baj méjkɪŋ jɔr mɒ́dəl mɔr kɒ́mplɛks, juw tɪ́pɪkəlij ɪnkríjs vɛ́ərijəns, ənd vájs vɜ́rsə. fájndɪŋ ðə ɒ́ptɪməl bǽləns ɪz krúwʃəl fɔr krijéjtɪŋ mɒ́dəlz ðət pərfɔ́rm wɛ́l ɒn núw, ʌ̀nsíjn déjtə. ðɪs tréjdɔ̀f ɪz wáj déjtə sájəntɪsts mʌst kɛ́ərfəlij səlɛ́kt mɒ́dəl kəmplɛ́ksɪtij, juwz tɛkníjks lájk krɔ́s-væ̀lɪdéjʃən, ənd əpláj rèɡjəlɛ̀ərɪzéjʃən mɛ́θədz tə bɪ́ld rowbʌ́st prədɪ́ktɪv sɪ́stəmz ðət dʒɛ́nərəlàjz wɛ́l bìjɔ́nd ðɛər tréjnɪŋ déjtə."
    },
    {
        "Question": "In computer science, what term refers to the mathematical analysis of the resources (like time or space) required by an algorithm to solve a problem as the input size grows?",
        "RightAnswer": "Algorithm Complexity",
        "WrongAnswers": [
            "Computational Density",
            "Processing Efficiency",
            "Code Optimization",
            "Runtime Analysis",
            "Execution Performance"
        ],
        "Explanation": "Algorithm Complexity is a fundamental concept in computer science that measures how the resources required by an algorithm scale as the input size increases. Rather than focusing on the exact running time in seconds, which can vary between machines, it examines the relationship between input size and the number of operations performed. The most common complexities are described using Big O notation, which expresses the worst-case scenario. For example, an algorithm with constant complexity always takes the same amount of time regardless of input size, while one with linear complexity requires time directly proportional to the input size. Understanding algorithm complexity allows programmers to make informed decisions about which algorithms to use for specific problems, especially when dealing with large datasets where inefficient algorithms can lead to significant performance issues. This analysis helps balance trade-offs between speed, memory usage, and other constraints when designing software systems.",
        "trans_Question": "ɪn kəmpjúwtər sájəns, wɒt tɜ́rm rəfɜ́rz tə ðə mæ̀θəmǽtɪkəl ənǽlɪsɪs əv ðə ríjsɔrsɪz (lájk tájm ɔr spéjs) rəkwájərd baj ən ǽlɡərɪ̀ðəm tə sɒ́lv ə prɒ́bləm æz ðə ɪ́npʊ̀t sájz ɡrówz?",
        "trans_RightAnswer": "ǽlɡərɪ̀ðəm kəmplɛ́ksɪtij",
        "trans_WrongAnswers": [
            "kɒ̀mpjuwtéjʃənəl dɛ́nsɪtij",
            "prɒ́sɛsɪŋ əfɪ́ʃənsij",
            "kówd ɒptɪmɪzéjʃən",
            "rʌ́ntàjm ənǽlɪsɪs",
            "ɛ̀ksəkjúwʃən pərfɔ́rməns"
        ],
        "trans_Explanation": "ǽlɡərɪ̀ðəm kəmplɛ́ksɪtij ɪz ə fʌ̀ndəmɛ́ntəl kɒ́nsɛpt ɪn kəmpjúwtər sájəns ðət mɛ́ʒərz háw ðə ríjsɔrsɪz rəkwájərd baj ən ǽlɡərɪ̀ðəm skéjl æz ðə ɪ́npʊ̀t sájz ɪnkríjsɪz. rǽðər ðʌn fówkəsɪŋ ɒn ðə əɡzǽkt rʌ́nɪŋ tájm ɪn sɛ́kəndz, wɪ́tʃ kən vɛ́ərij bijtwíjn məʃíjnz, ɪt əɡzǽmɪnz ðə rəléjʃənʃɪ̀p bijtwíjn ɪ́npʊ̀t sájz ənd ðə nʌ́mbər əv ɒ̀pəréjʃənz pərfɔ́rmd. ðə mówst kɒ́mən kəmplɛ́ksɪtijz ɑr dəskrájbd júwzɪŋ bɪ́ɡ O nowtéjʃən, wɪ́tʃ əksprɛ́sɪz ðə wɜ́rst-kéjs sənɛ́ərijow. fɔr əɡzǽmpəl, ən ǽlɡərɪ̀ðəm wɪð kɒ́nstənt kəmplɛ́ksɪtij ɔ́lwejz téjks ðə séjm əmáwnt əv tájm rəɡɑ́rdləs əv ɪ́npʊ̀t sájz, wájl wʌ́n wɪð lɪ́nijər kəmplɛ́ksɪtij rəkwájərz tájm dɪərɛ́klij prəpɔ́rʃənəl tə ðə ɪ́npʊ̀t sájz. ʌ̀ndərstǽndɪŋ ǽlɡərɪ̀ðəm kəmplɛ́ksɪtij əláwz prówɡræ̀mərz tə méjk ɪnfɔ́rmd dəsɪ́ʒənz əbawt wɪ́tʃ ǽlɡərɪ̀ðəmz tə juwz fɔr spəsɪ́fɪk prɒ́bləmz, əspɛ́ʃəlij wɛ́n díjlɪŋ wɪð lɑ́rdʒ déjtəsɛ̀ts wɛ́ər ɪ̀nəfɪ́ʃənt ǽlɡərɪ̀ðəmz kən líjd tə sɪɡnɪ́fɪkənt pərfɔ́rməns ɪ́ʃuwz. ðɪs ənǽlɪsɪs hɛ́lps bǽləns tréjd-ɔ́fs bijtwíjn spíjd, mɛ́mərij júwsɪdʒ, ənd ʌ́ðər kənstréjnts wɛ́n dəzájnɪŋ sɔ́ftwɛ̀ər sɪ́stəmz."
    },
    {
        "Question": "When analyzing an algorithm's efficiency, which notation is most commonly used to describe the upper bound of its time complexity as the input size grows?",
        "RightAnswer": "Big O Notation",
        "WrongAnswers": [
            "Execution Time Scale",
            "Performance Matrix System",
            "Algorithm Complexity Index",
            "Resource Consumption Coefficient",
            "Runtime Boundary Analysis"
        ],
        "Explanation": "Big O Notation is a mathematical representation used in computer science to describe the efficiency of algorithms as their input size increases. It specifically focuses on the worst-case scenario and provides an upper bound on time or space complexity. For example, when we say an algorithm runs in 'O(n)' time, it means the algorithm's runtime grows linearly with the input size. This notation allows computer scientists and developers to compare algorithms abstractly without worrying about implementation details or hardware specifications. It helps answer critical questions like 'How will this algorithm perform with very large datasets?' by classifying algorithms into efficiency categories such as constant, logarithmic, linear, quadratic, or exponential time. Understanding Big O Notation is fundamental for designing efficient systems and is often a key topic in technical interviews for software engineering positions.",
        "trans_Question": "wɛ́n ǽnəlàjzɪŋ ən ǽlɡərɪ̀ðəm'z əfɪ́ʃənsij, wɪ́tʃ nowtéjʃən ɪz mówst kɒ́mənlij júwzd tə dəskrájb ðə ʌ́pər báwnd əv ɪts tájm kəmplɛ́ksɪtij æz ðə ɪ́npʊ̀t sájz ɡrówz?",
        "trans_RightAnswer": "bɪ́ɡ O nowtéjʃən",
        "trans_WrongAnswers": [
            "ɛ̀ksəkjúwʃən tájm skéjl",
            "pərfɔ́rməns méjtrɪks sɪ́stəm",
            "ǽlɡərɪ̀ðəm kəmplɛ́ksɪtij ɪ́ndɛks",
            "ríjsɔrs kənsʌ́mpʃən kòwəfɪ́ʃənt",
            "rʌ́ntàjm báwndərij ənǽlɪsɪs"
        ],
        "trans_Explanation": "bɪ́ɡ O nowtéjʃən ɪz ə mæ̀θəmǽtɪkəl rɛ̀prəzɛntéjʃən júwzd ɪn kəmpjúwtər sájəns tə dəskrájb ðə əfɪ́ʃənsij əv ǽlɡərɪ̀ðəmz æz ðɛər ɪ́npʊ̀t sájz ɪnkríjsɪz. ɪt spəsɪ́fɪklij fówkəsɪz ɒn ðə wɜ́rst-kéjs sənɛ́ərijow ənd prəvájdz ən ʌ́pər báwnd ɒn tájm ɔr spéjs kəmplɛ́ksɪtij. fɔr əɡzǽmpəl, wɛ́n wij séj ən ǽlɡərɪ̀ðəm rʌ́nz ɪn 'o(n)' tájm, ɪt míjnz ðə ǽlɡərɪ̀ðəm'z rʌ́ntàjm ɡrówz lɪ́nijərlij wɪð ðə ɪ́npʊ̀t sájz. ðɪs nowtéjʃən əláwz kəmpjúwtər sájəntɪsts ənd dəvɛ́ləpərz tə kəmpɛ́ər ǽlɡərɪ̀ðəmz ǽbstræktlij wɪðáwt wɜ́rijɪŋ əbawt ɪ̀mpləmɛntéjʃən díjtejlz ɔr hɑ́rdwɛ̀ər spɛ̀sɪfɪkéjʃənz. ɪt hɛ́lps ǽnsər krɪ́tɪkəl kwɛ́stʃənz lájk 'háw wɪl ðɪs ǽlɡərɪ̀ðəm pərfɔ́rm wɪð vɛ́ərij lɑ́rdʒ déjtəsɛ̀ts?' baj klǽsɪfàjɪŋ ǽlɡərɪ̀ðəmz ɪntə əfɪ́ʃənsij kǽtəɡɔ̀rijz sʌtʃ æz kɒ́nstənt, lɒ̀ɡərɪ́ðmɪk, lɪ́nijər, kwɒdrɒ́tɪk, ɔr ɛ̀kspownɛ́nʃəl tájm. ʌ̀ndərstǽndɪŋ bɪ́ɡ O nowtéjʃən ɪz fʌ̀ndəmɛ́ntəl fɔr dəzájnɪŋ əfɪ́ʃənt sɪ́stəmz ənd ɪz ɔ́fən ə kíj tɒ́pɪk ɪn tɛ́knɪkəl ɪ́ntərvjùwz fɔr sɔ́ftwɛ̀ər ɛ̀ndʒɪnɪ́ərɪŋ pəzɪ́ʃənz."
    },
    {
        "Question": "In algorithm analysis, which term refers to the measurement of memory resources required by an algorithm as a function of input size?",
        "RightAnswer": "Space Complexity",
        "WrongAnswers": [
            "Time Efficiency",
            "Memory Footprint",
            "Storage Allocation",
            "Resource Utilization",
            "Memory Asymptotic"
        ],
        "Explanation": "Space Complexity is a fundamental concept in computer science that measures how much memory an algorithm needs to run as a function of its input size. Unlike time complexity which focuses on running time, space complexity analyzes memory usage patterns. For example, when an algorithm creates additional data structures whose size grows with larger inputs, this affects its space complexity. Algorithms can be categorized as constant space (memory usage doesn't change with input size), linear space (memory grows proportionally with input), or exponential space (memory requirements grow dramatically as input increases). When designing algorithms, particularly for resource-constrained environments, understanding space complexity helps developers make informed tradeoffs between memory usage and processing speed. In practical terms, an algorithm with lower space complexity might be preferred even if it runs slightly slower, especially in environments with limited memory resources.",
        "trans_Question": "ɪn ǽlɡərɪ̀ðəm ənǽlɪsɪs, wɪ́tʃ tɜ́rm rəfɜ́rz tə ðə mɛ́ʒərmənt əv mɛ́mərij ríjsɔrsɪz rəkwájərd baj ən ǽlɡərɪ̀ðəm æz ə fʌ́ŋkʃən əv ɪ́npʊ̀t sájz?",
        "trans_RightAnswer": "spéjs kəmplɛ́ksɪtij",
        "trans_WrongAnswers": [
            "tájm əfɪ́ʃənsij",
            "mɛ́mərij fʊ́tprɪ̀nt",
            "stɔ́rɪdʒ æ̀ləkéjʃən",
            "ríjsɔrs jùwtɪlɪzéjʃən",
            "mɛ́mərij ǽsɪmptɔ̀tɪk"
        ],
        "trans_Explanation": "spéjs kəmplɛ́ksɪtij ɪz ə fʌ̀ndəmɛ́ntəl kɒ́nsɛpt ɪn kəmpjúwtər sájəns ðət mɛ́ʒərz háw mʌtʃ mɛ́mərij ən ǽlɡərɪ̀ðəm níjdz tə rʌ́n æz ə fʌ́ŋkʃən əv ɪts ɪ́npʊ̀t sájz. ʌ̀nlájk tájm kəmplɛ́ksɪtij wɪ́tʃ fówkəsɪz ɒn rʌ́nɪŋ tájm, spéjs kəmplɛ́ksɪtij ǽnəlàjzɪz mɛ́mərij júwsɪdʒ pǽtərnz. fɔr əɡzǽmpəl, wɛ́n ən ǽlɡərɪ̀ðəm krijéjts ədɪ́ʃənəl déjtə strʌ́ktʃərz húwz sájz ɡrówz wɪð lɑ́rdʒər ɪ́npʊ̀ts, ðɪs əfɛ́kts ɪts spéjs kəmplɛ́ksɪtij. ǽlɡərɪ̀ðəmz kən bij kǽtəɡəràjzd æz kɒ́nstənt spéjs (mɛ́mərij júwsɪdʒ dʌ́zənt tʃéjndʒ wɪð ɪ́npʊ̀t sájz), lɪ́nijər spéjs (mɛ́mərij ɡrówz prəpɔ́rʃənəlij wɪð ɪ́npʊ̀t), ɔr ɛ̀kspownɛ́nʃəl spéjs (mɛ́mərij rəkwájərmənts ɡrów drəmǽtɪkəlij æz ɪ́npʊ̀t ɪnkríjsɪz). wɛ́n dəzájnɪŋ ǽlɡərɪ̀ðəmz, pərtɪ́kjələrlij fɔr ríjsɔrs-kənstréjnd ənvájərənmənts, ʌ̀ndərstǽndɪŋ spéjs kəmplɛ́ksɪtij hɛ́lps dəvɛ́ləpərz méjk ɪnfɔ́rmd tréjdɔ̀fs bijtwíjn mɛ́mərij júwsɪdʒ ənd prɒ́sɛsɪŋ spíjd. ɪn prǽktɪkəl tɜ́rmz, ən ǽlɡərɪ̀ðəm wɪð lówər spéjs kəmplɛ́ksɪtij majt bij prəfɜ́rd íjvən ɪf ɪt rʌ́nz slájtlij slówər, əspɛ́ʃəlij ɪn ənvájərənmənts wɪð lɪ́mɪtɪd mɛ́mərij ríjsɔrsɪz."
    },
    {
        "Question": "In algorithm analysis, what term describes the measure of computational resources required as input size grows, often expressed using Big O notation?",
        "RightAnswer": "Time Complexity",
        "WrongAnswers": [
            "Runtime Expansion",
            "Execution Coefficient",
            "Processing Magnitude",
            "Algorithmic Density",
            "Computational Gradient"
        ],
        "Explanation": "Time Complexity is a fundamental concept in computer science that quantifies how the running time of an algorithm increases as the size of the input data grows. Rather than measuring actual seconds or milliseconds, time complexity provides a mathematical way to describe the efficiency of algorithms in terms of the number of basic operations performed. Algorithms with lower time complexity scale better with large inputs. For example, an algorithm with constant time complexity always takes the same amount of time regardless of input size, while one with quadratic time complexity will take significantly longer as input grows. Computer scientists use Big O notation to express time complexity, allowing them to compare algorithms theoretically without implementation details. Understanding time complexity helps developers choose appropriate algorithms for specific problems, especially when working with large datasets where inefficient algorithms might lead to unacceptable performance.",
        "trans_Question": "ɪn ǽlɡərɪ̀ðəm ənǽlɪsɪs, wɒt tɜ́rm dəskrájbz ðə mɛ́ʒər əv kɒ̀mpjuwtéjʃənəl ríjsɔrsɪz rəkwájərd æz ɪ́npʊ̀t sájz ɡrówz, ɔ́fən əksprɛ́st júwzɪŋ bɪ́ɡ O nowtéjʃən?",
        "trans_RightAnswer": "tájm kəmplɛ́ksɪtij",
        "trans_WrongAnswers": [
            "rʌ́ntàjm əkspǽnʃən",
            "ɛ̀ksəkjúwʃən kòwəfɪ́ʃənt",
            "prɒ́sɛsɪŋ mǽɡnɪtùwd",
            "ǽlɡərɪ̀ðəmɪk dɛ́nsɪtij",
            "kɒ̀mpjuwtéjʃənəl ɡréjdijənt"
        ],
        "trans_Explanation": "tájm kəmplɛ́ksɪtij ɪz ə fʌ̀ndəmɛ́ntəl kɒ́nsɛpt ɪn kəmpjúwtər sájəns ðət kwɑ́ntɪfajz háw ðə rʌ́nɪŋ tájm əv ən ǽlɡərɪ̀ðəm ɪnkríjsɪz æz ðə sájz əv ðə ɪ́npʊ̀t déjtə ɡrówz. rǽðər ðʌn mɛ́ʒərɪŋ ǽktʃəl sɛ́kəndz ɔr mɪ́lɪsɛ̀kəndz, tájm kəmplɛ́ksɪtij prəvájdz ə mæ̀θəmǽtɪkəl wej tə dəskrájb ðə əfɪ́ʃənsij əv ǽlɡərɪ̀ðəmz ɪn tɜ́rmz əv ðə nʌ́mbər əv béjsɪk ɒ̀pəréjʃənz pərfɔ́rmd. ǽlɡərɪ̀ðəmz wɪð lówər tájm kəmplɛ́ksɪtij skéjl bɛ́tər wɪð lɑ́rdʒ ɪ́npʊ̀ts. fɔr əɡzǽmpəl, ən ǽlɡərɪ̀ðəm wɪð kɒ́nstənt tájm kəmplɛ́ksɪtij ɔ́lwejz téjks ðə séjm əmáwnt əv tájm rəɡɑ́rdləs əv ɪ́npʊ̀t sájz, wájl wʌ́n wɪð kwɒdrɒ́tɪk tájm kəmplɛ́ksɪtij wɪl téjk sɪɡnɪ́fɪkəntlij lɔ́ŋɡər æz ɪ́npʊ̀t ɡrówz. kəmpjúwtər sájəntɪsts juwz bɪ́ɡ O nowtéjʃən tə əksprɛ́s tájm kəmplɛ́ksɪtij, əláwɪŋ ðɛm tə kəmpɛ́ər ǽlɡərɪ̀ðəmz θìjərɛ́tɪkəlij wɪðáwt ɪ̀mpləmɛntéjʃən díjtejlz. ʌ̀ndərstǽndɪŋ tájm kəmplɛ́ksɪtij hɛ́lps dəvɛ́ləpərz tʃúwz əprówprijèjt ǽlɡərɪ̀ðəmz fɔr spəsɪ́fɪk prɒ́bləmz, əspɛ́ʃəlij wɛ́n wɜ́rkɪŋ wɪð lɑ́rdʒ déjtəsɛ̀ts wɛ́ər ɪ̀nəfɪ́ʃənt ǽlɡərɪ̀ðəmz majt líjd tə ʌ̀næksɛ́ptəbəl pərfɔ́rməns."
    },
    {
        "Question": "When computer scientists analyze algorithms to understand their performance regardless of specific hardware or implementation details, focusing on how their resource requirements grow as input sizes increase, what technique are they using?",
        "RightAnswer": "Asymptotic Analysis",
        "WrongAnswers": [
            "Algorithmic Debugging",
            "Computational Profiling",
            "Performance Benchmarking",
            "Resource Estimation Theory",
            "Complexity Enumeration"
        ],
        "Explanation": "Asymptotic Analysis is a fundamental approach in computer science that examines how the running time or space requirements of an algorithm grow as the input size increases toward infinity. Rather than focusing on exact execution times, which can vary across hardware, asymptotic analysis captures the essential growth pattern using simplified notations like Big O, Big Omega, and Big Theta. This approach allows computer scientists to compare algorithms at a conceptual level, identify scalability issues, and make informed decisions about which algorithm might be best suited for large-scale problems. For example, instead of saying an algorithm takes precisely 3n² + 2n + 1 operations, asymptotic analysis simplifies this to its dominant term, describing it as having quadratic growth. This theoretical framework helps predict how algorithms will perform when faced with very large inputs, which is crucial when designing systems that must handle substantial amounts of data efficiently.",
        "trans_Question": "wɛ́n kəmpjúwtər sájəntɪsts ǽnəlàjz ǽlɡərɪ̀ðəmz tə ʌ̀ndərstǽnd ðɛər pərfɔ́rməns rəɡɑ́rdləs əv spəsɪ́fɪk hɑ́rdwɛ̀ər ɔr ɪ̀mpləmɛntéjʃən díjtejlz, fówkəsɪŋ ɒn háw ðɛər ríjsɔrs rəkwájərmənts ɡrów æz ɪ́npʊ̀t sájzɪz ɪnkríjs, wɒt tɛkníjk ɑr ðej júwzɪŋ?",
        "trans_RightAnswer": "ǽsɪmptɔ̀tɪk ənǽlɪsɪs",
        "trans_WrongAnswers": [
            "ǽlɡərɪ̀ðəmɪk dijbʌ́ɡɪŋ",
            "kɒ̀mpjuwtéjʃənəl prówfàjlɪŋ",
            "pərfɔ́rməns bɛ́ntʃmɑ̀rkɪŋ",
            "ríjsɔrs ɛ̀stɪméjʃən θíjərij",
            "kəmplɛ́ksɪtij ənjùwməréjʃən"
        ],
        "trans_Explanation": "ǽsɪmptɔ̀tɪk ənǽlɪsɪs ɪz ə fʌ̀ndəmɛ́ntəl əprówtʃ ɪn kəmpjúwtər sájəns ðət əɡzǽmɪnz háw ðə rʌ́nɪŋ tájm ɔr spéjs rəkwájərmənts əv ən ǽlɡərɪ̀ðəm ɡrów æz ðə ɪ́npʊ̀t sájz ɪnkríjsɪz təwɔ́rd ɪnfɪ́nɪtij. rǽðər ðʌn fówkəsɪŋ ɒn əɡzǽkt ɛ̀ksəkjúwʃən tájmz, wɪ́tʃ kən vɛ́ərij əkrɔ́s hɑ́rdwɛ̀ər, ǽsɪmptɔ̀tɪk ənǽlɪsɪs kǽptʃərz ðə əsɛ́nʃəl ɡrówθ pǽtərn júwzɪŋ sɪ́mpləfajd nowtéjʃənz lájk bɪ́ɡ O, bɪ́ɡ owméjɡə, ənd bɪ́ɡ θéjtə. ðɪs əprówtʃ əláwz kəmpjúwtər sájəntɪsts tə kəmpɛ́ər ǽlɡərɪ̀ðəmz æt ə kənsɛ́ptʃuwəl lɛ́vəl, ajdɛ́ntɪfàj skéjləbɪ́lɪtij ɪ́ʃuwz, ənd méjk ɪnfɔ́rmd dəsɪ́ʒənz əbawt wɪ́tʃ ǽlɡərɪ̀ðəm majt bij bɛ́st súwtɪd fɔr lɑ́rdʒ-skéjl prɒ́bləmz. fɔr əɡzǽmpəl, ɪnstɛ́d əv séjɪŋ ən ǽlɡərɪ̀ðəm téjks prəsájslij 3n² + 2n + 1 ɒ̀pəréjʃənz, ǽsɪmptɔ̀tɪk ənǽlɪsɪs sɪ́mpləfajz ðɪs tə ɪts dɒ́mɪnənt tɜ́rm, dəskrájbɪŋ ɪt æz hǽvɪŋ kwɒdrɒ́tɪk ɡrówθ. ðɪs θìjərɛ́tɪkəl fréjmwɜ̀rk hɛ́lps prədɪ́kt háw ǽlɡərɪ̀ðəmz wɪl pərfɔ́rm wɛ́n féjst wɪð vɛ́ərij lɑ́rdʒ ɪ́npʊ̀ts, wɪ́tʃ ɪz krúwʃəl wɛ́n dəzájnɪŋ sɪ́stəmz ðət mʌst hǽndəl sʌbstǽnʃəl əmáwnts əv déjtə əfɪ́ʃəntlij."
    },
    {
        "Question": "When analyzing an algorithm's efficiency, which approach specifically focuses on the algorithm's performance in the most computationally challenging scenarios?",
        "RightAnswer": "Worst-case Analysis",
        "WrongAnswers": [
            "Average-case Analysis",
            "Best-case Analysis",
            "Amortized Analysis",
            "Probabilistic Analysis",
            "Expected-case Analysis"
        ],
        "Explanation": "Worst-case Analysis is a fundamental approach in computer science that examines how an algorithm performs under the most challenging or resource-intensive conditions it might encounter. Rather than considering typical or favorable inputs, worst-case analysis identifies the maximum time, memory, or other resources an algorithm would require for any valid input of a given size. This approach is particularly valuable because it provides guaranteed upper bounds on resource usage, allowing developers to make reliable predictions about an algorithm's performance even in challenging scenarios. For example, when analyzing a sorting algorithm, worst-case analysis would focus on input arrangements that cause the algorithm to perform the maximum possible number of operations. Computer scientists often express worst-case complexity using big O notation, which describes how resource requirements grow as input sizes increase. This conservative analytical approach helps ensure that systems remain responsive and reliable even under the most demanding circumstances.",
        "trans_Question": "wɛ́n ǽnəlàjzɪŋ ən ǽlɡərɪ̀ðəm'z əfɪ́ʃənsij, wɪ́tʃ əprówtʃ spəsɪ́fɪklij fówkəsɪz ɒn ðə ǽlɡərɪ̀ðəm'z pərfɔ́rməns ɪn ðə mówst kɒ̀mpjətéjʃənəlij tʃǽləndʒɪŋ sənɛ́ərijowz?",
        "trans_RightAnswer": "wɜ́rst-kéjs ənǽlɪsɪs",
        "trans_WrongAnswers": [
            "ǽvərɪdʒ-kéjs ənǽlɪsɪs",
            "bɛ́st-kéjs ənǽlɪsɪs",
            "ǽmərtàjzd ənǽlɪsɪs",
            "prɒ̀bəbɪlɪ́stɪk ənǽlɪsɪs",
            "əkspɛ́ktɪd-kéjs ənǽlɪsɪs"
        ],
        "trans_Explanation": "wɜ́rst-kéjs ənǽlɪsɪs ɪz ə fʌ̀ndəmɛ́ntəl əprówtʃ ɪn kəmpjúwtər sájəns ðət əɡzǽmɪnz háw ən ǽlɡərɪ̀ðəm pərfɔ́rmz ʌ́ndər ðə mówst tʃǽləndʒɪŋ ɔr ríjsɔrs-ɪntɛ́nsɪv kəndɪ́ʃənz ɪt majt ənkáwntər. rǽðər ðʌn kənsɪ́dərɪŋ tɪ́pɪkəl ɔr féjvərəbəl ɪ́npʊ̀ts, wɜ́rst-kéjs ənǽlɪsɪs ajdɛ́ntɪfàjz ðə mǽksɪməm tájm, mɛ́mərij, ɔr ʌ́ðər ríjsɔrsɪz ən ǽlɡərɪ̀ðəm wʊd rəkwájər fɔr ɛ́nij vǽlɪd ɪ́npʊ̀t əv ə ɡɪ́vən sájz. ðɪs əprówtʃ ɪz pərtɪ́kjələrlij vǽljəbəl bəkɒ́z ɪt prəvájdz ɡɛ̀ərəntíjd ʌ́pər báwndz ɒn ríjsɔrs júwsɪdʒ, əláwɪŋ dəvɛ́ləpərz tə méjk rəlájəbəl prədɪ́kʃənz əbawt ən ǽlɡərɪ̀ðəm'z pərfɔ́rməns íjvən ɪn tʃǽləndʒɪŋ sənɛ́ərijowz. fɔr əɡzǽmpəl, wɛ́n ǽnəlàjzɪŋ ə sɔ́rtɪŋ ǽlɡərɪ̀ðəm, wɜ́rst-kéjs ənǽlɪsɪs wʊd fówkəs ɒn ɪ́npʊ̀t əréjndʒmənts ðət kɒ́z ðə ǽlɡərɪ̀ðəm tə pərfɔ́rm ðə mǽksɪməm pɒ́sɪbəl nʌ́mbər əv ɒ̀pəréjʃənz. kəmpjúwtər sájəntɪsts ɔ́fən əksprɛ́s wɜ́rst-kéjs kəmplɛ́ksɪtij júwzɪŋ bɪ́ɡ O nowtéjʃən, wɪ́tʃ dəskrájbz háw ríjsɔrs rəkwájərmənts ɡrów æz ɪ́npʊ̀t sájzɪz ɪnkríjs. ðɪs kənsɜ́rvətɪv æ̀nəlɪ́tɪkəl əprówtʃ hɛ́lps ənʃʊ́r ðət sɪ́stəmz rəméjn rəspɒ́nsɪv ənd rəlájəbəl íjvən ʌ́ndər ðə mówst dəmǽndɪŋ sɜ́rkəmstæ̀nsɪz."
    },
    {
        "Question": "When a computer scientist evaluates an algorithm by determining its expected performance over all possible inputs, assuming a specific probability distribution of those inputs, what type of evaluation method are they using?",
        "RightAnswer": "Average-case Analysis",
        "WrongAnswers": [
            "Worst-case Analysis",
            "Amortized Analysis",
            "Best-case Analysis",
            "Probabilistic Analysis",
            "Expected Runtime Analysis"
        ],
        "Explanation": "Average-case Analysis is a method in algorithm analysis that examines how an algorithm performs on average across all possible inputs, assuming a certain probability distribution for those inputs. Unlike worst-case analysis, which focuses on the maximum time or space an algorithm might require, average-case analysis gives us insight into the typical performance we can expect in practice. For example, when analyzing quicksort, the average-case analysis shows it runs in n log n time for randomly ordered data, making it quite efficient despite having a worse quadratic worst-case scenario. This approach provides a more realistic picture of an algorithm's behavior in typical usage scenarios, helping developers make informed decisions about which algorithms to use for specific applications. Average-case analysis requires understanding probability theory and often involves more complex mathematics than simple best-case or worst-case analyses.",
        "trans_Question": "wɛ́n ə kəmpjúwtər sájəntɪst əvǽljuwèjts ən ǽlɡərɪ̀ðəm baj dətɜ́rmɪnɪŋ ɪts əkspɛ́ktɪd pərfɔ́rməns ówvər ɔl pɒ́sɪbəl ɪ́npʊ̀ts, əsúwmɪŋ ə spəsɪ́fɪk prɒ̀bəbɪ́lɪtij dɪ̀strəbjúwʃən əv ðowz ɪ́npʊ̀ts, wɒt tájp əv əvæ̀ljuwéjʃən mɛ́θəd ɑr ðej júwzɪŋ?",
        "trans_RightAnswer": "ǽvərɪdʒ-kéjs ənǽlɪsɪs",
        "trans_WrongAnswers": [
            "wɜ́rst-kéjs ənǽlɪsɪs",
            "ǽmərtàjzd ənǽlɪsɪs",
            "bɛ́st-kéjs ənǽlɪsɪs",
            "prɒ̀bəbɪlɪ́stɪk ənǽlɪsɪs",
            "əkspɛ́ktɪd rʌ́ntàjm ənǽlɪsɪs"
        ],
        "trans_Explanation": "ǽvərɪdʒ-kéjs ənǽlɪsɪs ɪz ə mɛ́θəd ɪn ǽlɡərɪ̀ðəm ənǽlɪsɪs ðət əɡzǽmɪnz háw ən ǽlɡərɪ̀ðəm pərfɔ́rmz ɒn ǽvərɪdʒ əkrɔ́s ɔl pɒ́sɪbəl ɪ́npʊ̀ts, əsúwmɪŋ ə sɜ́rtən prɒ̀bəbɪ́lɪtij dɪ̀strəbjúwʃən fɔr ðowz ɪ́npʊ̀ts. ʌ̀nlájk wɜ́rst-kéjs ənǽlɪsɪs, wɪ́tʃ fówkəsɪz ɒn ðə mǽksɪməm tájm ɔr spéjs ən ǽlɡərɪ̀ðəm majt rəkwájər, ǽvərɪdʒ-kéjs ənǽlɪsɪs ɡɪ́vz US ɪ́nsàjt ɪntə ðə tɪ́pɪkəl pərfɔ́rməns wij kən əkspɛ́kt ɪn prǽktɪs. fɔr əɡzǽmpəl, wɛ́n ǽnəlàjzɪŋ kwɪ́ksɔ̀rt, ðə ǽvərɪdʒ-kéjs ənǽlɪsɪs ʃówz ɪt rʌ́nz ɪn n lɔ́ɡ n tájm fɔr rǽndəmlij ɔ́rdərd déjtə, méjkɪŋ ɪt kwájt əfɪ́ʃənt dəspájt hǽvɪŋ ə wɜ́rs kwɒdrɒ́tɪk wɜ́rst-kéjs sənɛ́ərijow. ðɪs əprówtʃ prəvájdz ə mɔr rìjəlɪ́stɪk pɪ́ktʃər əv ən ǽlɡərɪ̀ðəm'z bəhéjvjər ɪn tɪ́pɪkəl júwsɪdʒ sənɛ́ərijowz, hɛ́lpɪŋ dəvɛ́ləpərz méjk ɪnfɔ́rmd dəsɪ́ʒənz əbawt wɪ́tʃ ǽlɡərɪ̀ðəmz tə juwz fɔr spəsɪ́fɪk æ̀plɪkéjʃənz. ǽvərɪdʒ-kéjs ənǽlɪsɪs rəkwájərz ʌ̀ndərstǽndɪŋ prɒ̀bəbɪ́lɪtij θíjərij ənd ɔ́fən ɪnvɒ́lvz mɔr kɒ́mplɛks mæ̀θəmǽtɪks ðʌn sɪ́mpəl bɛ́st-kéjs ɔr wɜ́rst-kéjs ənǽlɪsìjz."
    },
    {
        "Question": "When evaluating the efficiency of a sorting algorithm under optimal input conditions, which analytical approach is specifically used to determine the minimum possible time complexity?",
        "RightAnswer": "Best-case Analysis",
        "WrongAnswers": [
            "Average-case Analysis",
            "Worst-case Analysis",
            "Amortized Analysis",
            "Probabilistic Analysis",
            "Asymptotic Analysis"
        ],
        "Explanation": "Best-case Analysis examines the performance of an algorithm under the most favorable input conditions possible. It identifies the minimum time or resources an algorithm will require in the ideal scenario. For example, when analyzing a sorting algorithm like Insertion Sort, the best case occurs when the input array is already sorted, resulting in a time complexity of linear time. While this analysis helps establish the lower bound of an algorithm's performance, it is generally considered less useful than worst-case or average-case analysis for practical applications, since real-world data rarely presents in optimal arrangements. However, understanding the best case can provide insights into how well an algorithm might perform in certain specialized situations and allows for a more complete understanding of an algorithm's behavior across different scenarios.",
        "trans_Question": "wɛ́n əvǽljuwèjtɪŋ ðə əfɪ́ʃənsij əv ə sɔ́rtɪŋ ǽlɡərɪ̀ðəm ʌ́ndər ɒ́ptɪməl ɪ́npʊ̀t kəndɪ́ʃənz, wɪ́tʃ æ̀nəlɪ́tɪkəl əprówtʃ ɪz spəsɪ́fɪklij júwzd tə dətɜ́rmɪn ðə mɪ́nɪməm pɒ́sɪbəl tájm kəmplɛ́ksɪtij?",
        "trans_RightAnswer": "bɛ́st-kéjs ənǽlɪsɪs",
        "trans_WrongAnswers": [
            "ǽvərɪdʒ-kéjs ənǽlɪsɪs",
            "wɜ́rst-kéjs ənǽlɪsɪs",
            "ǽmərtàjzd ənǽlɪsɪs",
            "prɒ̀bəbɪlɪ́stɪk ənǽlɪsɪs",
            "ǽsɪmptɔ̀tɪk ənǽlɪsɪs"
        ],
        "trans_Explanation": "bɛ́st-kéjs ənǽlɪsɪs əɡzǽmɪnz ðə pərfɔ́rməns əv ən ǽlɡərɪ̀ðəm ʌ́ndər ðə mówst féjvərəbəl ɪ́npʊ̀t kəndɪ́ʃənz pɒ́sɪbəl. ɪt ajdɛ́ntɪfàjz ðə mɪ́nɪməm tájm ɔr ríjsɔrsɪz ən ǽlɡərɪ̀ðəm wɪl rəkwájər ɪn ðə ajdíjəl sənɛ́ərijow. fɔr əɡzǽmpəl, wɛ́n ǽnəlàjzɪŋ ə sɔ́rtɪŋ ǽlɡərɪ̀ðəm lájk ɪnsɜ́rʃən sɔ́rt, ðə bɛ́st kéjs əkɜ́rz wɛ́n ðə ɪ́npʊ̀t əréj ɪz ɔ̀lrɛ́dij sɔ́rtɪd, rəzʌ́ltɪŋ ɪn ə tájm kəmplɛ́ksɪtij əv lɪ́nijər tájm. wájl ðɪs ənǽlɪsɪs hɛ́lps əstǽblɪʃ ðə lówər báwnd əv ən ǽlɡərɪ̀ðəm'z pərfɔ́rməns, ɪt ɪz dʒɛ́nərəlij kənsɪ́dərd lɛ́s júwsfəl ðʌn wɜ́rst-kéjs ɔr ǽvərɪdʒ-kéjs ənǽlɪsɪs fɔr prǽktɪkəl æ̀plɪkéjʃənz, sɪns ríjəl-wɜ́rld déjtə rɛ́ərlij prɛ́zənts ɪn ɒ́ptɪməl əréjndʒmənts. hàwɛ́vər, ʌ̀ndərstǽndɪŋ ðə bɛ́st kéjs kən prəvájd ɪ́nsàjts ɪntə háw wɛ́l ən ǽlɡərɪ̀ðəm majt pərfɔ́rm ɪn sɜ́rtən spɛ́ʃəlàjzd sɪ̀tʃuwéjʃənz ənd əláwz fɔr ə mɔr kəmplíjt ʌ̀ndərstǽndɪŋ əv ən ǽlɡərɪ̀ðəm'z bəhéjvjər əkrɔ́s dɪ́fərənt sənɛ́ərijowz."
    },
    {
        "Question": "When analyzing the time complexity of a dynamic array that occasionally needs resizing, which analytical technique accounts for the 'spreading out' of the costly operations over many operations to determine a more accurate average cost per operation?",
        "RightAnswer": "Amortized Analysis",
        "WrongAnswers": [
            "Best-case Analysis",
            "Probabilistic Analysis",
            "Asymptotic Approximation",
            "Operation Spreading",
            "Time Distribution Model"
        ],
        "Explanation": "Amortized Analysis is a method used in computer science to analyze algorithms that occasionally perform expensive operations, but do so infrequently enough that the cost can be 'amortized' over many operations. Unlike worst-case analysis which focuses on the most expensive individual operation, amortized analysis considers the average performance over a sequence of operations. A classic example is a dynamic array that doubles in size when it reaches capacity. While the resizing operation is costly (requiring copying all elements), it happens so rarely that when we spread this cost across all the insertion operations, each insertion effectively costs just a constant amount of time. Amortized analysis helps us understand the true efficiency of data structures like dynamic arrays, self-balancing trees, and sophisticated algorithms that might otherwise appear inefficient if evaluated only by their worst-case operations.",
        "trans_Question": "wɛ́n ǽnəlàjzɪŋ ðə tájm kəmplɛ́ksɪtij əv ə dajnǽmɪk əréj ðət əkéjʒənəlij níjdz rijsájzɪŋ, wɪ́tʃ æ̀nəlɪ́tɪkəl tɛkníjk əkáwnts fɔr ðə 'sprɛ́dɪŋ awt' əv ðə kɒ́stlij ɒ̀pəréjʃənz ówvər mɛ́nij ɒ̀pəréjʃənz tə dətɜ́rmɪn ə mɔr ǽkjərət ǽvərɪdʒ kɒ́st pɜ́r ɒ̀pəréjʃən?",
        "trans_RightAnswer": "ǽmərtàjzd ənǽlɪsɪs",
        "trans_WrongAnswers": [
            "bɛ́st-kéjs ənǽlɪsɪs",
            "prɒ̀bəbɪlɪ́stɪk ənǽlɪsɪs",
            "ǽsɪmptɔ̀tɪk əprɒ̀ksəméjʃən",
            "ɒ̀pəréjʃən sprɛ́dɪŋ",
            "tájm dɪ̀strəbjúwʃən mɒ́dəl"
        ],
        "trans_Explanation": "ǽmərtàjzd ənǽlɪsɪs ɪz ə mɛ́θəd júwzd ɪn kəmpjúwtər sájəns tə ǽnəlàjz ǽlɡərɪ̀ðəmz ðət əkéjʒənəlij pərfɔ́rm əkspɛ́nsɪv ɒ̀pəréjʃənz, bʌt dúw sow ɪ̀nfríjkwəntlij ənʌ́f ðət ðə kɒ́st kən bij 'ǽmərtàjzd' ówvər mɛ́nij ɒ̀pəréjʃənz. ʌ̀nlájk wɜ́rst-kéjs ənǽlɪsɪs wɪ́tʃ fówkəsɪz ɒn ðə mówst əkspɛ́nsɪv ɪndɪvɪ́dʒəwəl ɒ̀pəréjʃən, ǽmərtàjzd ənǽlɪsɪs kənsɪ́dərz ðə ǽvərɪdʒ pərfɔ́rməns ówvər ə síjkwəns əv ɒ̀pəréjʃənz. ə klǽsɪk əɡzǽmpəl ɪz ə dajnǽmɪk əréj ðət dʌ́bəlz ɪn sájz wɛ́n ɪt ríjtʃɪz kəpǽsɪtij. wájl ðə rijsájzɪŋ ɒ̀pəréjʃən ɪz kɒ́stlij (rijkwájərɪŋ kɒ́pijɪŋ ɔl ɛ́ləmənts), ɪt hǽpənz sow rɛ́ərlij ðət wɛ́n wij sprɛ́d ðɪs kɒ́st əkrɔ́s ɔl ðə ɪnsɜ́rʃən ɒ̀pəréjʃənz, ijtʃ ɪnsɜ́rʃən əfɛ́ktɪvlij kɒ́sts dʒəst ə kɒ́nstənt əmáwnt əv tájm. ǽmərtàjzd ənǽlɪsɪs hɛ́lps US ʌ̀ndərstǽnd ðə trúw əfɪ́ʃənsij əv déjtə strʌ́ktʃərz lájk dajnǽmɪk əréjz, sɛ́lf-bǽlənsɪŋ tríjz, ənd səfɪ́stɪkèjtɪd ǽlɡərɪ̀ðəmz ðət majt ʌ́ðərwàjz əpɪ́ər ɪ̀nəfɪ́ʃənt ɪf əvǽljuwèjtɪd ównlij baj ðɛər wɜ́rst-kéjs ɒ̀pəréjʃənz."
    },
    {
        "Question": "In algorithm analysis, what term describes a relation that expresses the running time of an algorithm by referring to the running time on smaller inputs?",
        "RightAnswer": "Recurrence",
        "WrongAnswers": [
            "Iteration",
            "Recursion",
            "Dependency",
            "Time Complexity",
            "Loop Invariant"
        ],
        "Explanation": "A recurrence in computer science is a mathematical relation that defines the running time or space requirements of an algorithm in terms of the solution to smaller instances of the same problem. Recurrences are particularly important when analyzing divide-and-conquer algorithms, where a problem is broken down into subproblems of the same type. For example, when analyzing the runtime of Merge Sort, we might express it as T(n) relating to T(n/2) for the sorted halves. Solving a recurrence means finding a closed-form expression that directly gives the answer without referring back to smaller instances. Common methods for solving recurrences include the substitution method, recursion tree method, and the master theorem. Understanding recurrences is fundamental to algorithm design and analysis, as they help computer scientists predict performance and make informed decisions about algorithm selection.",
        "trans_Question": "ɪn ǽlɡərɪ̀ðəm ənǽlɪsɪs, wɒt tɜ́rm dəskrájbz ə rəléjʃən ðət əksprɛ́sɪz ðə rʌ́nɪŋ tájm əv ən ǽlɡərɪ̀ðəm baj rəfɜ́rɪŋ tə ðə rʌ́nɪŋ tájm ɒn smɔ́lər ɪ́npʊ̀ts?",
        "trans_RightAnswer": "rəkɜ́rəns",
        "trans_WrongAnswers": [
            "ɪ̀təréjʃən",
            "rəkɜ́rʒən",
            "dəpɛ́ndənsij",
            "tájm kəmplɛ́ksɪtij",
            "lúwp ɪ̀nvɛ́ərijənt"
        ],
        "trans_Explanation": "ə rəkɜ́rəns ɪn kəmpjúwtər sájəns ɪz ə mæ̀θəmǽtɪkəl rəléjʃən ðət dəfájnz ðə rʌ́nɪŋ tájm ɔr spéjs rəkwájərmənts əv ən ǽlɡərɪ̀ðəm ɪn tɜ́rmz əv ðə səlúwʃən tə smɔ́lər ɪ́nstənsɪz əv ðə séjm prɒ́bləm. rɪkɜ́rənsɪz ɑr pərtɪ́kjələrlij ɪmpɔ́rtənt wɛ́n ǽnəlàjzɪŋ dɪvájd-ənd-kɒ́ŋkər ǽlɡərɪ̀ðəmz, wɛ́ər ə prɒ́bləm ɪz brówkən dawn ɪntə sʌ́bprɒ́bləmz əv ðə séjm tájp. fɔr əɡzǽmpəl, wɛ́n ǽnəlàjzɪŋ ðə rʌ́ntàjm əv mɜ́rdʒ sɔ́rt, wij majt əksprɛ́s ɪt æz t(n) rəléjtɪŋ tə t(n/2) fɔr ðə sɔ́rtɪd hǽvz. sɒ́lvɪŋ ə rəkɜ́rəns míjnz fájndɪŋ ə klówzd-fɔ́rm əksprɛ́ʃən ðət dɪərɛ́klij ɡɪ́vz ðə ǽnsər wɪðáwt rəfɜ́rɪŋ bǽk tə smɔ́lər ɪ́nstənsɪz. kɒ́mən mɛ́θədz fɔr sɒ́lvɪŋ rɪkɜ́rənsɪz ɪnklúwd ðə sʌ̀bstɪtjúwʃən mɛ́θəd, rəkɜ́rʒən tríj mɛ́θəd, ənd ðə mǽstər θɪ́ərəm. ʌ̀ndərstǽndɪŋ rɪkɜ́rənsɪz ɪz fʌ̀ndəmɛ́ntəl tə ǽlɡərɪ̀ðəm dəzájn ənd ənǽlɪsɪs, æz ðej hɛ́lp kəmpjúwtər sájəntɪsts prədɪ́kt pərfɔ́rməns ənd méjk ɪnfɔ́rmd dəsɪ́ʒənz əbawt ǽlɡərɪ̀ðəm səlɛ́kʃən."
    },
    {
        "Question": "In algorithm analysis, what term describes a property that remains true before and after each iteration of a loop, serving as a critical tool for proving algorithm correctness?",
        "RightAnswer": "Loop Invariant",
        "WrongAnswers": [
            "Loop Constant",
            "Cycle Assertion",
            "Iteration Guarantee",
            "Algorithm Precondition",
            "Runtime Constraint"
        ],
        "Explanation": "A Loop Invariant is a condition or property that holds true before a loop begins, remains true during each iteration, and is still true when the loop terminates. Think of it as a logical anchor that helps verify that your algorithm works correctly. For example, in a sorting algorithm, a loop invariant might be that a particular section of the array is always sorted after each iteration. Loop invariants are powerful tools in formal verification of algorithms because they help break down complex loop behavior into provable statements. When designing algorithms, identifying good loop invariants often leads to clearer, more correct code, as they force programmers to think precisely about what their loops accomplish at each step.",
        "trans_Question": "ɪn ǽlɡərɪ̀ðəm ənǽlɪsɪs, wɒt tɜ́rm dəskrájbz ə prɒ́pərtij ðət rəméjnz trúw bəfɔ́r ənd ǽftər ijtʃ ɪ̀təréjʃən əv ə lúwp, sɜ́rvɪŋ æz ə krɪ́tɪkəl túwl fɔr prúwvɪŋ ǽlɡərɪ̀ðəm kərɛ́ktnəs?",
        "trans_RightAnswer": "lúwp ɪ̀nvɛ́ərijənt",
        "trans_WrongAnswers": [
            "lúwp kɒ́nstənt",
            "sájkəl əsɜ́rʃən",
            "ɪ̀təréjʃən ɡɛ̀ərəntíj",
            "ǽlɡərɪ̀ðəm prìjkəndɪ́ʃən",
            "rʌ́ntàjm kənstréjnt"
        ],
        "trans_Explanation": "ə lúwp ɪ̀nvɛ́ərijənt ɪz ə kəndɪ́ʃən ɔr prɒ́pərtij ðət hówldz trúw bəfɔ́r ə lúwp bəɡɪ́nz, rəméjnz trúw dʊ́rɪŋ ijtʃ ɪ̀təréjʃən, ənd ɪz stɪ́l trúw wɛ́n ðə lúwp tɜ́rmɪnèjts. θɪ́ŋk əv ɪt æz ə lɒ́dʒɪkəl ǽŋkər ðət hɛ́lps vɛ́ərɪfaj ðət jɔr ǽlɡərɪ̀ðəm wɜ́rks kərɛ́ktlij. fɔr əɡzǽmpəl, ɪn ə sɔ́rtɪŋ ǽlɡərɪ̀ðəm, ə lúwp ɪ̀nvɛ́ərijənt majt bij ðət ə pərtɪ́kjələr sɛ́kʃən əv ðə əréj ɪz ɔ́lwejz sɔ́rtɪd ǽftər ijtʃ ɪ̀təréjʃən. lúwp ɪnvɛ́ərijənts ɑr páwərfəl túwlz ɪn fɔ́rməl vɛ̀ərɪfɪkéjʃən əv ǽlɡərɪ̀ðəmz bəkɒ́z ðej hɛ́lp bréjk dawn kɒ́mplɛks lúwp bəhéjvjər ɪntə prúwvəbəl stéjtmənts. wɛ́n dəzájnɪŋ ǽlɡərɪ̀ðəmz, ajdɛ́ntɪfàjɪŋ ɡʊ́d lúwp ɪnvɛ́ərijənts ɔ́fən líjdz tə klɪ́ərər, mɔr kərɛ́kt kówd, æz ðej fɔ́rs prówɡræ̀mərz tə θɪ́ŋk prəsájslij əbawt wɒt ðɛər lúwps əkɒ́mplɪʃ æt ijtʃ stɛ́p."
    },
    {
        "Question": "In object-oriented programming, which concept allows a class to acquire the properties and behaviors of another class, promoting code reusability and establishing a parent-child relationship between classes?",
        "RightAnswer": "Inheritance",
        "WrongAnswers": [
            "Encapsulation",
            "Polymorphism",
            "Abstraction",
            "Composition",
            "Delegation"
        ],
        "Explanation": "Inheritance is a fundamental concept in object-oriented programming that enables a class (called a subclass or derived class) to adopt the attributes and methods of another class (called a superclass or parent class). This powerful mechanism allows programmers to create new classes that reuse, extend, or modify the behavior defined in existing classes. For instance, if you have a 'Vehicle' class with properties like 'speed' and methods like 'accelerate()', you could create more specialized classes such as 'Car' or 'Motorcycle' that inherit these features while adding their own unique characteristics. Inheritance helps establish hierarchical relationships between classes, reduces code duplication, and supports the principle of 'is-a' relationships (a Car is a Vehicle). This promotes more organized code structures and facilitates maintenance by centralizing shared functionality in parent classes while allowing specialized implementations in child classes.",
        "trans_Question": "ɪn ɒ́bdʒəkt-ɔ́rijɛ̀ntɪd prówɡræ̀mɪŋ, wɪ́tʃ kɒ́nsɛpt əláwz ə klǽs tə əkwájər ðə prɒ́pərtijz ənd bəhéjvjərz əv ənʌ́ðər klǽs, prəmówtɪŋ kówd rìjùwzəbɪ́lɪtij ənd əstǽblɪʃɪŋ ə pɛ́ərənt-tʃájld rəléjʃənʃɪ̀p bijtwíjn klǽsɪz?",
        "trans_RightAnswer": "ɪnhɛ́ərɪtəns",
        "trans_WrongAnswers": [
            "ɛnkǽpsəlèjʃən",
            "pɒ̀lijmɔ́rfɪzm",
            "æbstrǽkʃən",
            "kɒ̀mpəzɪ́ʃən",
            "dɛ̀ləɡéjʃən"
        ],
        "trans_Explanation": "ɪnhɛ́ərɪtəns ɪz ə fʌ̀ndəmɛ́ntəl kɒ́nsɛpt ɪn ɒ́bdʒəkt-ɔ́rijɛ̀ntɪd prówɡræ̀mɪŋ ðət ɛnéjbəlz ə klǽs (kɔ́ld ə sʌ́bklæ̀s ɔr dərájvd klǽs) tə ədɒ́pt ðə ǽtrəbjùwts ənd mɛ́θədz əv ənʌ́ðər klǽs (kɔ́ld ə súwpərklæ̀s ɔr pɛ́ərənt klǽs). ðɪs páwərfəl mɛ́kənɪzəm əláwz prówɡræ̀mərz tə krijéjt núw klǽsɪz ðət rijúws, əkstɛ́nd, ɔr mɒ́dɪfàj ðə bəhéjvjər dəfájnd ɪn əɡzɪ́stɪŋ klǽsɪz. fɔr ɪ́nstəns, ɪf juw həv ə 'víjhəkəl' klǽs wɪð prɒ́pərtijz lájk 'spíjd' ənd mɛ́θədz lájk 'acceleərate()', juw kʊ́d krijéjt mɔr spɛ́ʃəlàjzd klǽsɪz sʌtʃ æz 'kɑ́r' ɔr 'mówtərsàjkəl' ðət ɪnhɛ́ərɪt ðijz fíjtʃərz wájl ǽdɪŋ ðɛər ówn juwnɪ́k kæ̀rəktərɪ́stɪks. ɪnhɛ́ərɪtəns hɛ́lps əstǽblɪʃ hàjərɑ́rkɪkəl rəléjʃənʃɪ̀ps bijtwíjn klǽsɪz, rədjúwsɪz kówd djùwpləkéjʃən, ənd səpɔ́rts ðə prɪ́nsɪpəl əv 'ɪz-ə' rəléjʃənʃɪ̀ps (ə kɑ́r ɪz ə víjhəkəl). ðɪs prəmówts mɔr ɔ́rɡənàjzd kówd strʌ́ktʃərz ənd fəsɪ́lətèjts méjntənəns baj sɛ́ntrəlàjzɪŋ ʃɛ́ərd fʌ̀ŋkʃənǽlɪtij ɪn pɛ́ərənt klǽsɪz wájl əláwɪŋ spɛ́ʃəlàjzd ɪ̀mpləmɛntéjʃənz ɪn tʃájld klǽsɪz."
    },
    {
        "Question": "In object-oriented programming, what term describes the ability of different classes to respond to the same method call in ways specific to their own implementation?",
        "RightAnswer": "Polymorphism",
        "WrongAnswers": [
            "Encapsulation",
            "Inheritance",
            "Abstraction",
            "Method Overloading",
            "Instantiation"
        ],
        "Explanation": "Polymorphism is a fundamental concept in computer science that allows objects of different types to be treated as objects of a common type. The term comes from Greek words meaning 'many forms.' In programming, polymorphism enables a single interface to represent different underlying forms or data types. For example, consider a shape class with a method called 'calculate area.' Through polymorphism, different shape subclasses like circles, rectangles, and triangles can each implement this method in ways appropriate to their specific geometry. When you call the calculate area method, the correct implementation executes based on the actual object type, not just its declared type. This powerful feature enhances code flexibility, reusability, and maintainability by allowing programmers to write more generic code that can work with objects of multiple types, without needing to know the specific type at compile time.",
        "trans_Question": "ɪn ɒ́bdʒəkt-ɔ́rijɛ̀ntɪd prówɡræ̀mɪŋ, wɒt tɜ́rm dəskrájbz ðə əbɪ́lɪtij əv dɪ́fərənt klǽsɪz tə rəspɒ́nd tə ðə séjm mɛ́θəd kɔ́l ɪn wéjz spəsɪ́fɪk tə ðɛər ówn ɪ̀mpləmɛntéjʃən?",
        "trans_RightAnswer": "pɒ̀lijmɔ́rfɪzm",
        "trans_WrongAnswers": [
            "ɛnkǽpsəlèjʃən",
            "ɪnhɛ́ərɪtəns",
            "æbstrǽkʃən",
            "mɛ́θəd ówvərlòwdɪŋ",
            "ɪnstæ̀nʃijéjʃən"
        ],
        "trans_Explanation": "pɒ̀lijmɔ́rfɪzm ɪz ə fʌ̀ndəmɛ́ntəl kɒ́nsɛpt ɪn kəmpjúwtər sájəns ðət əláwz ɒ́bdʒɛkts əv dɪ́fərənt tájps tə bij tríjtɪd æz ɒ́bdʒɛkts əv ə kɒ́mən tájp. ðə tɜ́rm kʌ́mz frəm ɡríjk wɜ́rdz míjnɪŋ 'mɛ́nij fɔ́rmz.' ɪn prówɡræ̀mɪŋ, pɒ̀lijmɔ́rfɪzm ɛnéjbəlz ə sɪ́ŋɡəl ɪ́ntərfèjs tə rɛ̀prəzɛ́nt dɪ́fərənt ʌ̀ndərlájɪŋ fɔ́rmz ɔr déjtə tájps. fɔr əɡzǽmpəl, kənsɪ́dər ə ʃéjp klǽs wɪð ə mɛ́θəd kɔ́ld 'kǽlkjəlèjt ɛ́ərijə.' θrúw pɒ̀lijmɔ́rfɪzm, dɪ́fərənt ʃéjp sʌ́bklæ̀sɪz lájk sɜ́rkəlz, rɛ́ktæ̀ŋɡəlz, ənd trájæ̀ŋɡəlz kən ijtʃ ɪ́mpləmənt ðɪs mɛ́θəd ɪn wéjz əprówprijèjt tə ðɛər spəsɪ́fɪk dʒijɒ́mətrij. wɛ́n juw kɔ́l ðə kǽlkjəlèjt ɛ́ərijə mɛ́θəd, ðə kərɛ́kt ɪ̀mpləmɛntéjʃən ɛ́ksəkjùwts béjst ɒn ðə ǽktʃəl ɒ́bdʒəkt tájp, nɒt dʒəst ɪts dəklɛ́ərd tájp. ðɪs páwərfəl fíjtʃər ənhǽnsɪz kówd flɛ̀ksɪbɪ́lɪtij, rìjùwzəbɪ́lɪtij, ənd mejntéjnəbɪ́lɪtij baj əláwɪŋ prówɡræ̀mərz tə rájt mɔr dʒənɛ́ərɪk kówd ðət kən wɜ́rk wɪð ɒ́bdʒɛkts əv mʌ́ltɪpəl tájps, wɪðáwt níjdɪŋ tə nów ðə spəsɪ́fɪk tájp æt kəmpájl tájm."
    },
    {
        "Question": "Which object-oriented programming principle involves bundling data and methods that operate on that data into a single unit while restricting direct access to some of the object's components?",
        "RightAnswer": "Encapsulation",
        "WrongAnswers": [
            "Polymorphism",
            "Inheritance",
            "Abstraction",
            "Modularization",
            "Serialization"
        ],
        "Explanation": "Encapsulation is a fundamental principle in object-oriented programming that involves packaging related data and functions together into a single unit called a class, while controlling access to its internal details. Think of it like a medicine capsule that wraps its contents, protecting them from the outside environment. In programming, encapsulation creates a protective barrier around an object's attributes by making them private and only accessible through carefully designed public methods (often called getters and setters). This approach provides several benefits: it hides implementation details from users, prevents unintended interference with an object's state, reduces complexity by presenting a simplified interface, and allows developers to change internal workings without affecting code that uses the class. Encapsulation essentially creates a contract between the class and its users, specifying what interactions are permitted while maintaining data integrity and security.",
        "trans_Question": "wɪ́tʃ ɒ́bdʒəkt-ɔ́rijɛ̀ntɪd prówɡræ̀mɪŋ prɪ́nsɪpəl ɪnvɒ́lvz bʌ́ndəlɪŋ déjtə ənd mɛ́θədz ðət ɒ́pərèjt ɒn ðət déjtə ɪntə ə sɪ́ŋɡəl júwnɪt wájl rəstrɪ́ktɪŋ dɪərɛ́kt ǽksɛ̀s tə sʌm əv ðə ɒ́bdʒəkt's kəmpównənts?",
        "trans_RightAnswer": "ɛnkǽpsəlèjʃən",
        "trans_WrongAnswers": [
            "pɒ̀lijmɔ́rfɪzm",
            "ɪnhɛ́ərɪtəns",
            "æbstrǽkʃən",
            "mɒ̀djələrajzéjʃən",
            "sɪ̀ərìjəlɪzéjʃən"
        ],
        "trans_Explanation": "ɛnkǽpsəlèjʃən ɪz ə fʌ̀ndəmɛ́ntəl prɪ́nsɪpəl ɪn ɒ́bdʒəkt-ɔ́rijɛ̀ntɪd prówɡræ̀mɪŋ ðət ɪnvɒ́lvz pǽkɪdʒɪŋ rəléjtɪd déjtə ənd fʌ́ŋkʃənz təɡɛ́ðər ɪntə ə sɪ́ŋɡəl júwnɪt kɔ́ld ə klǽs, wájl kəntrówlɪŋ ǽksɛ̀s tə ɪts ɪ̀ntɜ́rnəl díjtejlz. θɪ́ŋk əv ɪt lájk ə mɛ́dɪsɪn kǽpsəl ðət rǽps ɪts kɒ́ntɛnts, prətɛ́ktɪŋ ðɛm frəm ðə áwtsájd ənvájərənmənt. ɪn prówɡræ̀mɪŋ, ɛnkǽpsəlèjʃən krijéjts ə prətɛ́ktɪv bǽrijər əráwnd ən ɒ́bdʒəkt's ǽtrəbjùwts baj méjkɪŋ ðɛm prájvət ənd ównlij æksɛ́sɪbəl θrúw kɛ́ərfəlij dəzájnd pʌ́blɪk mɛ́θədz (ɔ́fən kɔ́ld ɡɛ́tərz ənd sɛ́tərz). ðɪs əprówtʃ prəvájdz sɛ́vərəl bɛ́nəfɪts: ɪt hájdz ɪ̀mpləmɛntéjʃən díjtejlz frəm júwzərz, prəvɛ́nts ʌ̀nɪntɛ́ndɪd ɪ̀ntərfɪ́ərəns wɪð ən ɒ́bdʒəkt's stéjt, rədjúwsɪz kəmplɛ́ksɪtij baj prəzɛ́ntɪŋ ə sɪ́mpləfajd ɪ́ntərfèjs, ənd əláwz dəvɛ́ləpərz tə tʃéjndʒ ɪ̀ntɜ́rnəl wɜ́rkɪŋz wɪðáwt əfɛ́ktɪŋ kówd ðət júwsɪz ðə klǽs. ɛnkǽpsəlèjʃən əsɛ́nʃəlij krijéjts ə kɒ́ntrækt bijtwíjn ðə klǽs ənd ɪts júwzərz, spɛ́sɪfàjɪŋ wɒt ɪ̀ntərǽkʃənz ɑr pərmɪ́tɪd wájl mejntéjnɪŋ déjtə ɪntɛ́ɡrɪtij ənd səkjʊ́rɪtij."
    },
    {
        "Question": "When a programmer designs a user interface that hides complex implementation details so users only interact with simplified controls, which fundamental computer science concept are they applying?",
        "RightAnswer": "Abstraction",
        "WrongAnswers": [
            "Encapsulation",
            "Polymorphism",
            "Decomposition",
            "Inheritance",
            "Modularity"
        ],
        "Explanation": "Abstraction is the process of simplifying complex reality by modeling classes appropriate to the problem, while ignoring irrelevant details. In computer science, abstraction serves as a powerful tool that allows programmers to manage complexity by hiding unnecessary implementation details and exposing only the essential features needed for interaction. For example, when you use a smartphone app, you interact with simple buttons and interfaces without needing to understand the complex code running behind them. Abstraction exists at multiple levels in computing: high-level programming languages abstract machine code, functions abstract sequences of instructions, and user interfaces abstract underlying processes. By creating these layers of abstraction, computer scientists can build increasingly sophisticated systems while keeping them manageable and user-friendly. The beauty of abstraction is that it allows both developers and users to focus only on the level of detail relevant to their current task.",
        "trans_Question": "wɛ́n ə prówɡræ̀mər dəzájnz ə júwzər ɪ́ntərfèjs ðət hájdz kɒ́mplɛks ɪ̀mpləmɛntéjʃən díjtejlz sow júwzərz ównlij ɪ̀ntərǽkt wɪð sɪ́mpləfajd kəntrówlz, wɪ́tʃ fʌ̀ndəmɛ́ntəl kəmpjúwtər sájəns kɒ́nsɛpt ɑr ðej əplájɪŋ?",
        "trans_RightAnswer": "æbstrǽkʃən",
        "trans_WrongAnswers": [
            "ɛnkǽpsəlèjʃən",
            "pɒ̀lijmɔ́rfɪzm",
            "dìjkəmpəzɪ́ʃən",
            "ɪnhɛ́ərɪtəns",
            "mɒ́djəlǽrɪtij"
        ],
        "trans_Explanation": "æbstrǽkʃən ɪz ðə prɒ́sɛs əv sɪ́mpləfajɪŋ kɒ́mplɛks rìjǽlɪtij baj mɒ́dəlɪ̀ŋ klǽsɪz əprówprijèjt tə ðə prɒ́bləm, wájl ɪ̀ɡnɔ́rɪŋ ɪ̀ərɛ́ləvənt díjtejlz. ɪn kəmpjúwtər sájəns, æbstrǽkʃən sɜ́rvz æz ə páwərfəl túwl ðət əláwz prówɡræ̀mərz tə mǽnɪdʒ kəmplɛ́ksɪtij baj hájdɪŋ ʌ̀nnɛ́səsɛ̀ərij ɪ̀mpləmɛntéjʃən díjtejlz ənd əkspówzɪŋ ównlij ðə əsɛ́nʃəl fíjtʃərz níjdɪd fɔr ɪ̀ntərǽkʃən. fɔr əɡzǽmpəl, wɛ́n juw juwz ə smɑ́rtfòwn ǽp, juw ɪ̀ntərǽkt wɪð sɪ́mpəl bʌ́tənz ənd ɪ́ntərfèjsɪz wɪðáwt níjdɪŋ tə ʌ̀ndərstǽnd ðə kɒ́mplɛks kówd rʌ́nɪŋ bəhájnd ðɛm. æbstrǽkʃən əɡzɪ́sts æt mʌ́ltɪpəl lɛ́vəlz ɪn kəmpjúwtɪŋ: háj-lɛ́vəl prówɡræ̀mɪŋ lǽŋɡwədʒɪz ǽbstræ̀kt məʃíjn kówd, fʌ́ŋkʃənz ǽbstræ̀kt síjkwənsɪz əv ɪnstrʌ́kʃənz, ənd júwzər ɪ́ntərfèjsɪz ǽbstræ̀kt ʌ̀ndərlájɪŋ prɒ́sɛsɪz. baj krijéjtɪŋ ðijz léjərz əv æbstrǽkʃən, kəmpjúwtər sájəntɪsts kən bɪ́ld ɪnkríjsɪŋɡlij səfɪ́stɪkèjtɪd sɪ́stəmz wájl kíjpɪŋ ðɛm mǽnədʒəbəl ənd júwzər-frɛ́ndlij. ðə bjúwtij əv æbstrǽkʃən ɪz ðət ɪt əláwz bówθ dəvɛ́ləpərz ənd júwzərz tə fówkəs ównlij ɒn ðə lɛ́vəl əv díjtejl rɛ́ləvənt tə ðɛər kɑ́rənt tǽsk."
    },
    {
        "Question": "In object-oriented programming, what is the term for the blueprint that defines the properties and behaviors shared by a group of related objects?",
        "RightAnswer": "Class",
        "WrongAnswers": [
            "Method",
            "Instance",
            "Attribute",
            "Function",
            "Module"
        ],
        "Explanation": "A Class in computer science is a fundamental concept in object-oriented programming that serves as a template or blueprint for creating objects. It defines a set of attributes (data) and methods (functions) that the objects created from the class will possess. Think of a class like an architectural plan for a house: the plan itself isn't a house, but it defines what the house will look like, how many rooms it will have, and other characteristics. Similarly, a class defines the structure and behavior that all objects of that type will share. For example, a 'Car' class might include attributes like color and model, and methods like accelerate and brake. Classes enable programmers to implement important principles like encapsulation, inheritance, and polymorphism, making code more organized, reusable, and maintainable.",
        "trans_Question": "ɪn ɒ́bdʒəkt-ɔ́rijɛ̀ntɪd prówɡræ̀mɪŋ, wɒt ɪz ðə tɜ́rm fɔr ðə blúwprɪ̀nt ðət dəfájnz ðə prɒ́pərtijz ənd bəhéjvjərz ʃɛ́ərd baj ə ɡrúwp əv rəléjtɪd ɒ́bdʒɛkts?",
        "trans_RightAnswer": "klǽs",
        "trans_WrongAnswers": [
            "mɛ́θəd",
            "ɪ́nstəns",
            "ǽtrɪbjuwt",
            "fʌ́ŋkʃən",
            "mɒ́dʒuwl"
        ],
        "trans_Explanation": "ə klǽs ɪn kəmpjúwtər sájəns ɪz ə fʌ̀ndəmɛ́ntəl kɒ́nsɛpt ɪn ɒ́bdʒəkt-ɔ́rijɛ̀ntɪd prówɡræ̀mɪŋ ðət sɜ́rvz æz ə tɛ́mplejt ɔr blúwprɪ̀nt fɔr krijéjtɪŋ ɒ́bdʒɛkts. ɪt dəfájnz ə sɛ́t əv ǽtrəbjùwts (déjtə) ənd mɛ́θədz (fʌ́ŋkʃənz) ðət ðə ɒ́bdʒɛkts krijéjtɪd frəm ðə klǽs wɪl pəzɛ́s. θɪ́ŋk əv ə klǽs lájk ən ɑ̀rkɪtɛ́ktʃərəl plǽn fɔr ə haws: ðə plǽn ɪtsɛ́lf ɪzənt ə haws, bʌt ɪt dəfájnz wɒt ðə haws wɪl lʊ́k lájk, háw mɛ́nij rúwmz ɪt wɪl həv, ənd ʌ́ðər kæ̀rəktərɪ́stɪks. sɪ́mɪlərlij, ə klǽs dəfájnz ðə strʌ́ktʃər ənd bəhéjvjər ðət ɔl ɒ́bdʒɛkts əv ðət tájp wɪl ʃɛ́ər. fɔr əɡzǽmpəl, ə 'kɑ́r' klǽs majt ɪnklúwd ǽtrəbjùwts lájk kʌ́lər ənd mɒ́dəl, ənd mɛ́θədz lájk æksɛ́lərèjt ənd bréjk. klǽsɪz ɛnéjbəl prówɡræ̀mərz tə ɪ́mpləmənt ɪmpɔ́rtənt prɪ́nsɪpəlz lájk ɛnkǽpsəlèjʃən, ɪnhɛ́ərɪtəns, ənd pɒ̀lijmɔ́rfɪzm, méjkɪŋ kówd mɔr ɔ́rɡənàjzd, rijúwzəbəl, ənd mejntéjnəbəl."
    },
    {
        "Question": "In object-oriented programming, what term represents a self-contained entity that combines data and the procedures that operate on that data?",
        "RightAnswer": "Object",
        "WrongAnswers": [
            "Method",
            "Variable",
            "Function",
            "Pointer",
            "Iterator"
        ],
        "Explanation": "An object is a fundamental concept in computer science, particularly in object-oriented programming. It is a self-contained unit that encapsulates both data (known as attributes or properties) and the code that manipulates that data (known as methods). Think of an object as a digital representation of a real-world entity. For example, a 'Student' object might contain data like name, ID, and grades, along with methods that perform actions such as calculating the average grade or updating personal information. Objects interact with one another through well-defined interfaces, which promotes modular design and code reusability. This encapsulation helps manage complexity by hiding implementation details and exposing only what other parts of the program need to know, making software easier to develop, maintain, and extend. Objects are typically created from templates called classes, which define the structure and behavior that all objects of that type will share.",
        "trans_Question": "ɪn ɒ́bdʒəkt-ɔ́rijɛ̀ntɪd prówɡræ̀mɪŋ, wɒt tɜ́rm rɛ̀prəzɛ́nts ə sɛ́lf-kəntéjnd ɛ́ntɪtij ðət kəmbájnz déjtə ənd ðə prəsíjdʒərz ðət ɒ́pərèjt ɒn ðət déjtə?",
        "trans_RightAnswer": "ɒ́bdʒəkt",
        "trans_WrongAnswers": [
            "mɛ́θəd",
            "vɛ́ərijəbəl",
            "fʌ́ŋkʃən",
            "pɔ́jntər",
            "ɪ́tərèjtər"
        ],
        "trans_Explanation": "ən ɒ́bdʒəkt ɪz ə fʌ̀ndəmɛ́ntəl kɒ́nsɛpt ɪn kəmpjúwtər sájəns, pərtɪ́kjələrlij ɪn ɒ́bdʒəkt-ɔ́rijɛ̀ntɪd prówɡræ̀mɪŋ. ɪt ɪz ə sɛ́lf-kəntéjnd júwnɪt ðət ɛnkǽpsjʊlejts bówθ déjtə (nówn æz ǽtrəbjùwts ɔr prɒ́pərtijz) ənd ðə kówd ðət mənɪ́pjəlèjts ðət déjtə (nówn æz mɛ́θədz). θɪ́ŋk əv ən ɒ́bdʒəkt æz ə dɪ́dʒɪtəl rɛ̀prəzɛntéjʃən əv ə ríjəl-wɜ́rld ɛ́ntɪtij. fɔr əɡzǽmpəl, ə 'stúwdənt' ɒ́bdʒəkt majt kəntéjn déjtə lájk néjm, ID, ənd ɡréjdz, əlɔ́ŋ wɪð mɛ́θədz ðət pərfɔ́rm ǽkʃənz sʌtʃ æz kǽlkjəlèjtɪŋ ðə ǽvərɪdʒ ɡréjd ɔr ʌ́pdèjtɪŋ pɜ́rsənəl ɪnfərméjʃən. ɒ́bdʒɛkts ɪ̀ntərǽkt wɪð wʌ́n ənʌ́ðər θrúw wɛ́l-dəfájnd ɪ́ntərfèjsɪz, wɪ́tʃ prəmówts mɒ́dʒələr dəzájn ənd kówd rìjùwzəbɪ́lɪtij. ðɪs ɛnkǽpsəlèjʃən hɛ́lps mǽnɪdʒ kəmplɛ́ksɪtij baj hájdɪŋ ɪ̀mpləmɛntéjʃən díjtejlz ənd əkspówzɪŋ ównlij wɒt ʌ́ðər pɑ́rts əv ðə prówɡræ̀m níjd tə nów, méjkɪŋ sɔ́ftwɛ̀ər íjzijər tə dəvɛ́ləp, mejntéjn, ənd əkstɛ́nd. ɒ́bdʒɛkts ɑr tɪ́pɪkəlij krijéjtɪd frəm tɛ́mpləts kɔ́ld klǽsɪz, wɪ́tʃ dəfájn ðə strʌ́ktʃər ənd bəhéjvjər ðət ɔl ɒ́bdʒɛkts əv ðət tájp wɪl ʃɛ́ər."
    },
    {
        "Question": "In object-oriented programming, what is the term for a named sequence of statements that performs a specific task and belongs to a class?",
        "RightAnswer": "Method",
        "WrongAnswers": [
            "Variable",
            "Instance",
            "Property",
            "Attribute",
            "Constructor"
        ],
        "Explanation": "A method in computer science is a named sequence of statements that defines a specific behavior or functionality within a class. Methods encapsulate logic that manipulates data and performs operations, essentially representing the actions that an object can take. They are central to object-oriented programming as they implement the behaviors of objects and enable interaction between different parts of a program. Methods can accept parameters, process them according to their defined logic, and return results. Unlike attributes or properties which store data, methods perform actions. For example, a 'Customer' class might have methods like 'calculateDiscount()' or 'updateShippingAddress()' that define what the Customer object can do. Methods promote code reusability, maintainability, and the principle of encapsulation by hiding implementation details while exposing only necessary functionality through well-defined interfaces.",
        "trans_Question": "ɪn ɒ́bdʒəkt-ɔ́rijɛ̀ntɪd prówɡræ̀mɪŋ, wɒt ɪz ðə tɜ́rm fɔr ə néjmd síjkwəns əv stéjtmənts ðət pərfɔ́rmz ə spəsɪ́fɪk tǽsk ənd bəlɔ́ŋz tə ə klǽs?",
        "trans_RightAnswer": "mɛ́θəd",
        "trans_WrongAnswers": [
            "vɛ́ərijəbəl",
            "ɪ́nstəns",
            "prɒ́pərtij",
            "ǽtrɪbjuwt",
            "kənstrʌ́ktər"
        ],
        "trans_Explanation": "ə mɛ́θəd ɪn kəmpjúwtər sájəns ɪz ə néjmd síjkwəns əv stéjtmənts ðət dəfájnz ə spəsɪ́fɪk bəhéjvjər ɔr fʌ̀ŋkʃənǽlɪtij wɪðɪ́n ə klǽs. mɛ́θədz ɛnkǽpsəlèjt lɒ́dʒɪk ðət mənɪ́pjəlèjts déjtə ənd pərfɔ́rmz ɒ̀pəréjʃənz, əsɛ́nʃəlij rɛ̀prəzɛ́ntɪŋ ðə ǽkʃənz ðət ən ɒ́bdʒəkt kən téjk. ðej ɑr sɛ́ntrəl tə ɒ́bdʒəkt-ɔ́rijɛ̀ntɪd prówɡræ̀mɪŋ æz ðej ɪ́mpləmənt ðə bəhéjvjərz əv ɒ́bdʒɛkts ənd ɛnéjbəl ɪ̀ntərǽkʃən bijtwíjn dɪ́fərənt pɑ́rts əv ə prówɡræ̀m. mɛ́θədz kən æksɛ́pt pərǽmətərz, prɒ́sɛs ðɛm əkɔ́rdɪŋ tə ðɛər dəfájnd lɒ́dʒɪk, ənd rətɜ́rn rəzʌ́lts. ʌ̀nlájk ǽtrəbjùwts ɔr prɒ́pərtijz wɪ́tʃ stɔ́r déjtə, mɛ́θədz pərfɔ́rm ǽkʃənz. fɔr əɡzǽmpəl, ə 'kʌ́stəmər' klǽs majt həv mɛ́θədz lájk 'calcuwlatedijscouwnt()' ɔr 'uwpdateshijppijngaddress()' ðət dəfájn wɒt ðə kʌ́stəmər ɒ́bdʒəkt kən dúw. mɛ́θədz prəmówt kówd rìjùwzəbɪ́lɪtij, mejntéjnəbɪ́lɪtij, ənd ðə prɪ́nsɪpəl əv ɛnkǽpsəlèjʃən baj hájdɪŋ ɪ̀mpləmɛntéjʃən díjtejlz wájl əkspówzɪŋ ównlij nɛ́səsɛ̀ərij fʌ̀ŋkʃənǽlɪtij θrúw wɛ́l-dəfájnd ɪ́ntərfèjsɪz."
    },
    {
        "Question": "In object-oriented programming, what term describes a named property or characteristic of a class that represents data about an object's state?",
        "RightAnswer": "Attribute",
        "WrongAnswers": [
            "Method",
            "Constructor",
            "Inheritance",
            "Polymorphism",
            "Instance"
        ],
        "Explanation": "In computer science, an attribute is a named property or characteristic that defines and stores data about an object or entity. Attributes are fundamental components in data modeling, object-oriented programming, and database design. They represent the specific pieces of information that describe an object's current state. For example, a User class might have attributes like username, email, and dateOfBirth. Unlike methods, which define behaviors or actions, attributes focus on storing data values. Attributes can have various data types and access modifiers that control how they can be accessed and modified. In different programming contexts, attributes might also be called properties, fields, or instance variables, but they all serve the same core purpose of representing the characteristics that define an entity within a system.",
        "trans_Question": "ɪn ɒ́bdʒəkt-ɔ́rijɛ̀ntɪd prówɡræ̀mɪŋ, wɒt tɜ́rm dəskrájbz ə néjmd prɒ́pərtij ɔr kæ̀rəktərɪ́stɪk əv ə klǽs ðət rɛ̀prəzɛ́nts déjtə əbawt ən ɒ́bdʒəkt's stéjt?",
        "trans_RightAnswer": "ǽtrɪbjuwt",
        "trans_WrongAnswers": [
            "mɛ́θəd",
            "kənstrʌ́ktər",
            "ɪnhɛ́ərɪtəns",
            "pɒ̀lijmɔ́rfɪzm",
            "ɪ́nstəns"
        ],
        "trans_Explanation": "ɪn kəmpjúwtər sájəns, ən ǽtrɪbjuwt ɪz ə néjmd prɒ́pərtij ɔr kæ̀rəktərɪ́stɪk ðət dəfájnz ənd stɔ́rz déjtə əbawt ən ɒ́bdʒəkt ɔr ɛ́ntɪtij. ǽtrəbjùwts ɑr fʌ̀ndəmɛ́ntəl kəmpównənts ɪn déjtə mɒ́dəlɪ̀ŋ, ɒ́bdʒəkt-ɔ́rijɛ̀ntɪd prówɡræ̀mɪŋ, ənd déjtəbèjs dəzájn. ðej rɛ̀prəzɛ́nt ðə spəsɪ́fɪk píjsɪz əv ɪnfərméjʃən ðət dəskrájb ən ɒ́bdʒəkt's kɑ́rənt stéjt. fɔr əɡzǽmpəl, ə júwzər klǽs majt həv ǽtrəbjùwts lájk júwzərnèjm, íjmejl, ənd déjt. ʌ̀nlájk mɛ́θədz, wɪ́tʃ dəfájn bəhéjvjərz ɔr ǽkʃənz, ǽtrəbjùwts fówkəs ɒn stɔ́rɪŋ déjtə vǽljuwz. ǽtrəbjùwts kən həv vɛ́ərijəs déjtə tájps ənd ǽksɛ̀s mɒ́dɪfàjərz ðət kəntrówl háw ðej kən bij ǽksɛ̀st ənd mɒ́dɪfàjd. ɪn dɪ́fərənt prówɡræ̀mɪŋ kɒ́ntɛ̀ksts, ǽtrəbjùwts majt ɔ́lsow bij kɔ́ld prɒ́pərtijz, fíjldz, ɔr ɪ́nstəns vɛ́ərijəbəlz, bʌt ðej ɔl sɜ́rv ðə séjm kɔ́r pɜ́rpəs əv rɛ̀prəzɛ́ntɪŋ ðə kæ̀rəktərɪ́stɪks ðət dəfájn ən ɛ́ntɪtij wɪðɪ́n ə sɪ́stəm."
    },
    {
        "Question": "What is the term for the boundary point where two systems or components meet and interact with each other, often defining how software components can communicate while hiding their internal implementation details?",
        "RightAnswer": "Interface",
        "WrongAnswers": [
            "Algorithm",
            "Protocol",
            "Framework",
            "Abstraction",
            "Encapsulation"
        ],
        "Explanation": "An interface in computer science is a shared boundary where different systems or components meet and interact. Interfaces define how software elements can communicate with each other while keeping their internal workings hidden. Think of an interface like a contract that specifies what actions are possible without detailing how those actions are performed. For example, a user interface allows humans to interact with a computer system, while a programming interface provides a set of functions that developers can use to interact with a software library or service. Interfaces are fundamental to modular design, allowing components to be developed independently and replaced without affecting the rest of the system. The concept is essential in object-oriented programming, where interface definitions separate what a class does from how it does it, enabling more flexible and maintainable code.",
        "trans_Question": "wɒt ɪz ðə tɜ́rm fɔr ðə báwndərij pɔ́jnt wɛ́ər túw sɪ́stəmz ɔr kəmpównənts míjt ənd ɪ̀ntərǽkt wɪð ijtʃ ʌ́ðər, ɔ́fən dəfájnɪŋ háw sɔ́ftwɛ̀ər kəmpównənts kən kəmjúwnɪkèjt wájl hájdɪŋ ðɛər ɪ̀ntɜ́rnəl ɪ̀mpləmɛntéjʃən díjtejlz?",
        "trans_RightAnswer": "ɪ́ntərfèjs",
        "trans_WrongAnswers": [
            "ǽlɡərɪ̀ðəm",
            "prówtəkɒ̀l",
            "fréjmwɜ̀rk",
            "æbstrǽkʃən",
            "ɛnkǽpsəlèjʃən"
        ],
        "trans_Explanation": "ən ɪ́ntərfèjs ɪn kəmpjúwtər sájəns ɪz ə ʃɛ́ərd báwndərij wɛ́ər dɪ́fərənt sɪ́stəmz ɔr kəmpównənts míjt ənd ɪ̀ntərǽkt. ɪ́ntərfèjsɪz dəfájn háw sɔ́ftwɛ̀ər ɛ́ləmənts kən kəmjúwnɪkèjt wɪð ijtʃ ʌ́ðər wájl kíjpɪŋ ðɛər ɪ̀ntɜ́rnəl wɜ́rkɪŋz hɪ́dən. θɪ́ŋk əv ən ɪ́ntərfèjs lájk ə kɒ́ntrækt ðət spɛ́sɪfàjz wɒt ǽkʃənz ɑr pɒ́sɪbəl wɪðáwt dətéjlɪŋ háw ðowz ǽkʃənz ɑr pərfɔ́rmd. fɔr əɡzǽmpəl, ə júwzər ɪ́ntərfèjs əláwz hjúwmənz tə ɪ̀ntərǽkt wɪð ə kəmpjúwtər sɪ́stəm, wájl ə prówɡræ̀mɪŋ ɪ́ntərfèjs prəvájdz ə sɛ́t əv fʌ́ŋkʃənz ðət dəvɛ́ləpərz kən juwz tə ɪ̀ntərǽkt wɪð ə sɔ́ftwɛ̀ər lájbrɛərìj ɔr sɜ́rvɪs. ɪ́ntərfèjsɪz ɑr fʌ̀ndəmɛ́ntəl tə mɒ́dʒələr dəzájn, əláwɪŋ kəmpównənts tə bij dəvɛ́ləpt ɪndəpɛ́ndəntlij ənd rìjpléjst wɪðáwt əfɛ́ktɪŋ ðə rɛ́st əv ðə sɪ́stəm. ðə kɒ́nsɛpt ɪz əsɛ́nʃəl ɪn ɒ́bdʒəkt-ɔ́rijɛ̀ntɪd prówɡræ̀mɪŋ, wɛ́ər ɪ́ntərfèjs dɛ̀fɪnɪ́ʃənz sɛ́pərət wɒt ə klǽs dʌz frəm háw ɪt dʌz ɪt, ɛnéjbəlɪŋ mɔr flɛ́ksɪbəl ənd mejntéjnəbəl kówd."
    },
    {
        "Question": "What is the standardized set of protocols and tools that allows different software applications to communicate with each other without requiring developers to understand the internal workings of each system?",
        "RightAnswer": "API",
        "WrongAnswers": [
            "DNS",
            "SQL",
            "SDK",
            "FTP",
            "SMTP"
        ],
        "Explanation": "An API, or Application Programming Interface, serves as a communication bridge between different software systems. Think of it as a digital waiter in a restaurant: you, the customer, make a request without needing to know how the kitchen operates; the waiter takes your order to the kitchen and brings back what you asked for. Similarly, APIs allow developers to access specific features or data from another application without understanding its complex internal code. For example, when a weather app on your phone displays current conditions, it likely retrieves this information through a weather service API. APIs define the methods and data formats applications should use to request and exchange information, making it possible for different software systems to work together seamlessly while remaining independent. They have become fundamental building blocks of modern software development, enabling the integration of diverse systems and services across the internet.",
        "trans_Question": "wɒt ɪz ðə stǽndərdàjzd sɛ́t əv prówtəkɔ̀lz ənd túwlz ðət əláwz dɪ́fərənt sɔ́ftwɛ̀ər æ̀plɪkéjʃənz tə kəmjúwnɪkèjt wɪð ijtʃ ʌ́ðər wɪðáwt rijkwájərɪŋ dəvɛ́ləpərz tə ʌ̀ndərstǽnd ðə ɪ̀ntɜ́rnəl wɜ́rkɪŋz əv ijtʃ sɪ́stəm?",
        "trans_RightAnswer": "API",
        "trans_WrongAnswers": [
            "DNS",
            "SQL",
            "SDK",
            "FTP",
            "SMTP"
        ],
        "trans_Explanation": "ən API, ɔr æ̀plɪkéjʃən prówɡræ̀mɪŋ ɪ́ntərfèjs, sɜ́rvz æz ə kəmjùwnɪkéjʃən brɪ́dʒ bijtwíjn dɪ́fərənt sɔ́ftwɛ̀ər sɪ́stəmz. θɪ́ŋk əv ɪt æz ə dɪ́dʒɪtəl wéjtər ɪn ə rɛ́strɑ́nt: juw, ðə kʌ́stəmər, méjk ə rəkwɛ́st wɪðáwt níjdɪŋ tə nów háw ðə kɪ́tʃən ɒ́pərèjts; ðə wéjtər téjks jɔr ɔ́rdər tə ðə kɪ́tʃən ənd brɪ́ŋz bǽk wɒt juw ǽskt fɔr. sɪ́mɪlərlij, APIz əláw dəvɛ́ləpərz tə ǽksɛ̀s spəsɪ́fɪk fíjtʃərz ɔr déjtə frəm ənʌ́ðər æ̀plɪkéjʃən wɪðáwt ʌ̀ndərstǽndɪŋ ɪts kɒ́mplɛks ɪ̀ntɜ́rnəl kówd. fɔr əɡzǽmpəl, wɛ́n ə wɛ́ðər ǽp ɒn jɔr fówn dɪspléjz kɑ́rənt kəndɪ́ʃənz, ɪt lájklij rətríjvz ðɪs ɪnfərméjʃən θrúw ə wɛ́ðər sɜ́rvɪs API. APIz dəfájn ðə mɛ́θədz ənd déjtə fɔ́rmæ̀ts æ̀plɪkéjʃənz ʃʊd juwz tə rəkwɛ́st ənd əkstʃéjndʒ ɪnfərméjʃən, méjkɪŋ ɪt pɒ́sɪbəl fɔr dɪ́fərənt sɔ́ftwɛ̀ər sɪ́stəmz tə wɜ́rk təɡɛ́ðər síjmləslij wájl rəméjnɪŋ ɪndəpɛ́ndənt. ðej həv bəkʌ́m fʌ̀ndəmɛ́ntəl bɪ́ldɪŋ blɒ́ks əv mɒ́dərn sɔ́ftwɛ̀ər dəvɛ́ləpmənt, ɛnéjbəlɪŋ ðə ɪntəɡrejʃən əv dajvɜ́rs sɪ́stəmz ənd sɜ́rvɪsɪz əkrɔ́s ðə ɪ́ntərnɛ̀t."
    },
    {
        "Question": "Which discipline focuses on applying systematic, disciplined, and quantifiable approaches to the development, operation, and maintenance of software systems that are reliable, efficient, and meet customer requirements?",
        "RightAnswer": "Software Engineering",
        "WrongAnswers": [
            "Algorithm Design",
            "Network Architecture",
            "Database Management",
            "Artificial Intelligence",
            "Computer Graphics"
        ],
        "Explanation": "Software Engineering is the systematic application of engineering principles to the design, development, testing, deployment, and maintenance of software. Unlike ad-hoc programming, Software Engineering emphasizes structured methodologies, well-defined processes, and quality assurance techniques to create reliable, maintainable, and cost-effective software solutions. It encompasses the entire software development lifecycle, from initial requirements gathering to long-term maintenance. Software engineers must balance technical considerations with project management concerns such as scheduling, cost estimation, and team coordination. The discipline also focuses on best practices like code reusability, documentation standards, and design patterns to enhance productivity and software quality. As software systems have grown increasingly complex and critical to society's infrastructure, Software Engineering has evolved to address challenges of scale, security, and sustainability through approaches like agile development, continuous integration, and automated testing frameworks.",
        "trans_Question": "wɪ́tʃ dɪ́sɪplɪn fówkəsɪz ɒn əplájɪŋ sɪ̀stəmǽtɪk, dɪ́sɪplɪnd, ənd kwɑ̀ntɪfájəbɛl əprówtʃɪz tə ðə dəvɛ́ləpmənt, ɒ̀pəréjʃən, ənd méjntənəns əv sɔ́ftwɛ̀ər sɪ́stəmz ðət ɑr rəlájəbəl, əfɪ́ʃənt, ənd míjt kʌ́stəmər rəkwájərmənts?",
        "trans_RightAnswer": "sɔ́ftwɛ̀ər ɛ̀ndʒɪnɪ́ərɪŋ",
        "trans_WrongAnswers": [
            "ǽlɡərɪ̀ðəm dəzájn",
            "nɛ́twɜ̀rk ɑ́rkɪtɛ̀ktʃər",
            "déjtəbèjs mǽnədʒmənt",
            "ɑ̀rtɪfɪ́ʃəl ɪntɛ́lɪdʒəns",
            "kəmpjúwtər ɡrǽfɪks"
        ],
        "trans_Explanation": "sɔ́ftwɛ̀ər ɛ̀ndʒɪnɪ́ərɪŋ ɪz ðə sɪ̀stəmǽtɪk æ̀plɪkéjʃən əv ɛ̀ndʒɪnɪ́ərɪŋ prɪ́nsɪpəlz tə ðə dəzájn, dəvɛ́ləpmənt, tɛ́stɪŋ, dəplɔ́jmənt, ənd méjntənəns əv sɔ́ftwɛ̀ər. ʌ̀nlájk ǽd-hɒ́k prówɡræ̀mɪŋ, sɔ́ftwɛ̀ər ɛ̀ndʒɪnɪ́ərɪŋ ɛ́mfəsajzɪz strʌ́ktʃərd mɛ̀θowdɒ́lədʒijz, wɛ́l-dəfájnd prɒ́sɛsɪz, ənd kwɑ́lɪtij əʃʊ́rəns tɛkníjks tə krijéjt rəlájəbəl, mejntéjnəbəl, ənd kɒ́st-əféktɪv sɔ́ftwɛ̀ər səlúwʃənz. ɪt ɛnkʌ́mpəsɪz ðə əntájər sɔ́ftwɛ̀ər dəvɛ́ləpmənt lájfsàjkəl, frəm ɪnɪ́ʃəl rəkwájərmənts ɡǽðərɪŋ tə lɔ́ŋ-tɜ́rm méjntənəns. sɔ́ftwɛ̀ər ɛ̀ndʒɪnɪ́ərz mʌst bǽləns tɛ́knɪkəl kənsɪ̀dəréjʃənz wɪð prɒ́dʒɛkt mǽnədʒmənt kənsɜ́rnz sʌtʃ æz skɛ́dʒuwlɪŋ, kɒ́st ɛ̀stɪméjʃən, ənd tíjm kowɔ̀rdɪnéjʃən. ðə dɪ́sɪplɪn ɔ́lsow fówkəsɪz ɒn bɛ́st prǽktɪsɪz lájk kówd rìjùwzəbɪ́lɪtij, dɒ̀kjəmɛntéjʃən stǽndərdz, ənd dəzájn pǽtərnz tə ənhǽns prɒ̀dəktɪ́vɪtij ənd sɔ́ftwɛ̀ər kwɑ́lɪtij. æz sɔ́ftwɛ̀ər sɪ́stəmz həv ɡrówn ɪnkríjsɪŋɡlij kɒ́mplɛks ənd krɪ́tɪkəl tə səsájətij'z ɪnfrəstrʌ́ktʃər, sɔ́ftwɛ̀ər ɛ̀ndʒɪnɪ́ərɪŋ həz əvɒ́lvd tə æ̀drɛ́s tʃǽləndʒɪz əv skéjl, səkjʊ́rɪtij, ənd səstèjnəbɪ́lɪtij θrúw əprówtʃɪz lájk ǽdʒəl dəvɛ́ləpmənt, kəntɪ́njuwəs ɪntəɡrejʃən, ənd ɔ́təmèjtɪd tɛ́stɪŋ fréjmwɜ̀rks."
    },
    {
        "Question": "Which software development approach emphasizes iterative development, collaboration, and customer feedback throughout the project lifecycle?",
        "RightAnswer": "Agile Methodology",
        "WrongAnswers": [
            "Waterfall Model",
            "Big Bang Development",
            "Structural Programming",
            "Critical Path Method",
            "Linear Sequential Model"
        ],
        "Explanation": "Agile Methodology is a flexible, iterative approach to software development that emphasizes delivering working software in small, incremental releases rather than attempting to deliver the entire product at once. Unlike traditional methodologies such as Waterfall, Agile welcomes changing requirements even late in the development process and focuses on customer collaboration, team interactions, and responding to change. Agile teams typically work in short cycles called 'sprints' or 'iterations' that usually last 1-4 weeks, during which they plan, design, code, test, and potentially release a specific set of features. Popular Agile frameworks include Scrum, Kanban, and Extreme Programming (XP). The core values of Agile, as outlined in the Agile Manifesto, prioritize individuals and interactions, working software, customer collaboration, and responding to change. This approach has become widely adopted in the software industry because it allows teams to deliver value faster, adapt to changing requirements, and maintain closer alignment with customer needs.",
        "trans_Question": "wɪ́tʃ sɔ́ftwɛ̀ər dəvɛ́ləpmənt əprówtʃ ɛ́mfəsajzɪz ɪ́tərətɪv dəvɛ́ləpmənt, kəlæ̀bəréjʃən, ənd kʌ́stəmər fíjdbæ̀k θruwáwt ðə prɒ́dʒɛkt lájfsàjkəl?",
        "trans_RightAnswer": "ǽdʒəl mɛ̀θədɒ́lədʒij",
        "trans_WrongAnswers": [
            "wɔ́tərfɔ̀l mɒ́dəl",
            "bɪ́ɡ bǽŋ dəvɛ́ləpmənt",
            "strʌ́ktʃərəl prówɡræ̀mɪŋ",
            "krɪ́tɪkəl pǽθ mɛ́θəd",
            "lɪ́nijər səkwɛ́nʃəl mɒ́dəl"
        ],
        "trans_Explanation": "ǽdʒəl mɛ̀θədɒ́lədʒij ɪz ə flɛ́ksɪbəl, ɪ́tərətɪv əprówtʃ tə sɔ́ftwɛ̀ər dəvɛ́ləpmənt ðət ɛ́mfəsajzɪz dəlɪ́vərɪŋ wɜ́rkɪŋ sɔ́ftwɛ̀ər ɪn smɔ́l, ɪnkrəmɛ́ntəl rəlíjsɪz rǽðər ðʌn ətɛ́mptɪŋ tə dəlɪ́vər ðə əntájər prɒ́dəkt æt wʌ́ns. ʌ̀nlájk trədɪ́ʃənəl mɛ̀θowdɒ́lədʒijz sʌtʃ æz wɔ́tərfɔ̀l, ǽdʒəl wɛ́lkəmz tʃéjndʒɪŋ rəkwájərmənts íjvən léjt ɪn ðə dəvɛ́ləpmənt prɒ́sɛs ənd fówkəsɪz ɒn kʌ́stəmər kəlæ̀bəréjʃən, tíjm ɪ̀ntərǽkʃənz, ənd rəspɒ́ndɪŋ tə tʃéjndʒ. ǽdʒəl tíjmz tɪ́pɪkəlij wɜ́rk ɪn ʃɔ́rt sájkəlz kɔ́ld 'sprɪ́nts' ɔr 'ɪ̀təréjʃənz' ðət júwʒəlij lǽst 1-4 wíjks, dʊ́rɪŋ wɪ́tʃ ðej plǽn, dəzájn, kówd, tɛ́st, ənd pətɛ́nʃəlij rəlíjs ə spəsɪ́fɪk sɛ́t əv fíjtʃərz. pɒ́pjələr ǽdʒəl fréjmwɜ̀rks ɪnklúwd skrʌ́m, kænbǽn, ənd əkstríjm prówɡræ̀mɪŋ (XP). ðə kɔ́r vǽljuwz əv ǽdʒəl, æz áwtlàjnd ɪn ðə ǽdʒəl mæ̀nɪfɛ́stòw, prajɔ́rɪtajz ɪndɪvɪ́dʒəwəlz ənd ɪ̀ntərǽkʃənz, wɜ́rkɪŋ sɔ́ftwɛ̀ər, kʌ́stəmər kəlæ̀bəréjʃən, ənd rəspɒ́ndɪŋ tə tʃéjndʒ. ðɪs əprówtʃ həz bəkʌ́m wájdlij ədɒ́ptɪd ɪn ðə sɔ́ftwɛ̀ər ɪ́ndəstrij bəkɒ́z ɪt əláwz tíjmz tə dəlɪ́vər vǽljuw fǽstər, ədǽpt tə tʃéjndʒɪŋ rəkwájərmənts, ənd mejntéjn klówsər əlájnmənt wɪð kʌ́stəmər níjdz."
    },
    {
        "Question": "Which Agile framework organizes development into time-boxed iterations called 'sprints' and uses daily standup meetings to track progress?",
        "RightAnswer": "Scrum",
        "WrongAnswers": [
            "Waterfall",
            "Kanban",
            "Extreme Programming",
            "Six Sigma",
            "Lean Development"
        ],
        "Explanation": "Scrum is a lightweight Agile project management framework used primarily in software development. It divides projects into fixed-length iterations called sprints, typically lasting two to four weeks, where specific work items must be completed and ready for review. Scrum is characterized by specific roles including the Product Owner, Scrum Master, and Development Team, as well as ceremonies like sprint planning, daily standup meetings, sprint reviews, and retrospectives. The framework emphasizes transparency, inspection, and adaptation, allowing teams to respond quickly to changing requirements and market conditions. Unlike sequential methodologies, Scrum enables incremental product delivery, continuous feedback, and team self-organization, making it particularly effective for complex projects where requirements evolve throughout the development process.",
        "trans_Question": "wɪ́tʃ ǽdʒəl fréjmwɜ̀rk ɔ́rɡənàjzɪz dəvɛ́ləpmənt ɪntə tájm-bɒ́kst ɪ̀təréjʃənz kɔ́ld 'sprɪ́nts' ənd júwsɪz déjlij stǽndʌ̀p míjtɪŋz tə trǽk prɒ́ɡrɛ̀s?",
        "trans_RightAnswer": "skrʌ́m",
        "trans_WrongAnswers": [
            "wɔ́tərfɔ̀l",
            "kænbǽn",
            "əkstríjm prówɡræ̀mɪŋ",
            "sɪ́ks sɪ́ɡmə",
            "líjn dəvɛ́ləpmənt"
        ],
        "trans_Explanation": "skrʌ́m ɪz ə lájtwéjt ǽdʒəl prɒ́dʒɛkt mǽnədʒmənt fréjmwɜ̀rk júwzd prajmɛ́ərɪlij ɪn sɔ́ftwɛ̀ər dəvɛ́ləpmənt. ɪt dɪvájdz prɒ́dʒɛkts ɪntə fɪ́kst-lɛ́ŋθ ɪ̀təréjʃənz kɔ́ld sprɪ́nts, tɪ́pɪkəlij lǽstɪŋ túw tə fɔ́r wíjks, wɛ́ər spəsɪ́fɪk wɜ́rk ájtəmz mʌst bij kəmplíjtɪd ənd rɛ́dij fɔr rìjvjúw. skrʌ́m ɪz kǽrəktərajzd baj spəsɪ́fɪk rówlz ɪnklúwdɪŋ ðə prɒ́dəkt ównər, skrʌ́m mǽstər, ənd dəvɛ́ləpmənt tíjm, æz wɛ́l æz sɛ́ərəmòwnijz lájk sprɪ́nt plǽnɪŋ, déjlij stǽndʌ̀p míjtɪŋz, sprɪ́nt rəvjúwz, ənd rɛtrowspɛ́ktɪvz. ðə fréjmwɜ̀rk ɛ́mfəsajzɪz trænspɛ́ərənsij, ɪnspɛ́kʃən, ənd æ̀dəptéjʃən, əláwɪŋ tíjmz tə rəspɒ́nd kwɪ́klij tə tʃéjndʒɪŋ rəkwájərmənts ənd mɑ́rkət kəndɪ́ʃənz. ʌ̀nlájk səkwɛ́nʃəl mɛ̀θowdɒ́lədʒijz, skrʌ́m ɛnéjbəlz ɪnkrəmɛ́ntəl prɒ́dəkt dəlɪ́vərij, kəntɪ́njuwəs fíjdbæ̀k, ənd tíjm sɛ́lf-ɔ̀rɡənɪzéjʃən, méjkɪŋ ɪt pərtɪ́kjələrlij əféktɪv fɔr kɒ́mplɛks prɒ́dʒɛkts wɛ́ər rəkwájərmənts əvɒ́lv θruwáwt ðə dəvɛ́ləpmənt prɒ́sɛs."
    },
    {
        "Question": "Which project management methodology, originally developed at Toyota, uses a visual board with columns representing workflow stages where tasks move from left to right as they progress toward completion?",
        "RightAnswer": "Kanban",
        "WrongAnswers": [
            "Scrum",
            "Waterfall",
            "DevOps",
            "Extreme Programming",
            "Six Sigma"
        ],
        "Explanation": "Kanban is a visual workflow management method that originated in Toyota's manufacturing processes and was later adapted for software development and other knowledge work. At its core, Kanban uses a board divided into columns that represent different stages in a workflow (such as 'To Do', 'In Progress', and 'Done'). Tasks, represented as cards, move across the board from left to right as they progress toward completion. The key principles of Kanban include visualizing work, limiting work in progress to prevent bottlenecks, managing flow, making process policies explicit, and implementing feedback loops for continuous improvement. Unlike more structured methodologies like Scrum, Kanban is flexible and focuses on evolutionary change rather than revolutionary transformation. It allows teams to start with their current processes and gradually improve them while maintaining a steady flow of work. In software development, Kanban helps teams maintain a sustainable pace, respond to changing priorities, and deliver value continuously rather than in predetermined iterations.",
        "trans_Question": "wɪ́tʃ prɒ́dʒɛkt mǽnədʒmənt mɛ̀θədɒ́lədʒij, ərɪ́dʒɪnəlij dəvɛ́ləpt æt towjówtə, júwsɪz ə vɪ́ʒəwəl bɔ́rd wɪð kɒ́ləmz rɛ̀prəzɛ́ntɪŋ wɜ́rkflòw stéjdʒɪz wɛ́ər tǽsks múwv frəm lɛ́ft tə rájt æz ðej prɒ́ɡrɛ̀s təwɔ́rd kəmplíjʃən?",
        "trans_RightAnswer": "kænbǽn",
        "trans_WrongAnswers": [
            "skrʌ́m",
            "wɔ́tərfɔ̀l",
            "dɛ́vɒps",
            "əkstríjm prówɡræ̀mɪŋ",
            "sɪ́ks sɪ́ɡmə"
        ],
        "trans_Explanation": "kænbǽn ɪz ə vɪ́ʒəwəl wɜ́rkflòw mǽnədʒmənt mɛ́θəd ðət ərɪ́dʒɪnèjtɪd ɪn towjówtə'z mæ̀njəfǽktʃərɪŋ prɒ́sɛsɪz ənd wɒz léjtər ədǽptɪd fɔr sɔ́ftwɛ̀ər dəvɛ́ləpmənt ənd ʌ́ðər nɒ́lɪdʒ wɜ́rk. æt ɪts kɔ́r, kænbǽn júwsɪz ə bɔ́rd dɪvájdɪd ɪntə kɒ́ləmz ðət rɛ̀prəzɛ́nt dɪ́fərənt stéjdʒɪz ɪn ə wɜ́rkflòw (sʌtʃ æz 'tə dúw', 'ɪn prɒ́ɡrɛ̀s', ənd 'dʌ́n'). tǽsks, rɛ̀prəzɛ́ntɪd æz kɑ́rdz, múwv əkrɔ́s ðə bɔ́rd frəm lɛ́ft tə rájt æz ðej prɒ́ɡrɛ̀s təwɔ́rd kəmplíjʃən. ðə kíj prɪ́nsɪpəlz əv kænbǽn ɪnklúwd vɪ́ʒwəlàjzɪŋ wɜ́rk, lɪ́mɪtɪŋ wɜ́rk ɪn prɒ́ɡrɛ̀s tə prəvɛ́nt bɒ́təlnɛ̀ks, mǽnɪdʒɪŋ flów, méjkɪŋ prɒ́sɛs pɒ́lɪsijz əksplɪ́sɪt, ənd ɪ́mpləmɛ̀ntɪŋ fíjdbæ̀k lúwps fɔr kəntɪ́njuwəs ɪmprúwvmənt. ʌ̀nlájk mɔr strʌ́ktʃərd mɛ̀θowdɒ́lədʒijz lájk skrʌ́m, kænbǽn ɪz flɛ́ksɪbəl ənd fówkəsɪz ɒn ɛ̀vəlúwʃənɛ̀ərij tʃéjndʒ rǽðər ðʌn rɛ̀vəlúwʃənɛ̀ərij træ̀nsfərméjʃən. ɪt əláwz tíjmz tə stɑ́rt wɪð ðɛər kɑ́rənt prɒ́sɛsɪz ənd ɡrǽdʒuwəlij ɪmprúwv ðɛm wájl mejntéjnɪŋ ə stɛ́dij flów əv wɜ́rk. ɪn sɔ́ftwɛ̀ər dəvɛ́ləpmənt, kænbǽn hɛ́lps tíjmz mejntéjn ə səstéjnəbəl péjs, rəspɒ́nd tə tʃéjndʒɪŋ prajɔ́rɪtijz, ənd dəlɪ́vər vǽljuw kəntɪ́njuwəslij rǽðər ðʌn ɪn prìjdətɜ́rmɪnd ɪ̀təréjʃənz."
    },
    {
        "Question": "In software development, which methodology follows a strictly sequential approach where each phase must be completed before the next phase begins?",
        "RightAnswer": "Waterfall Model",
        "WrongAnswers": [
            "Agile Framework",
            "Spiral Methodology",
            "Scrum Process",
            "Kanban System",
            "Extreme Programming"
        ],
        "Explanation": "The Waterfall Model is a linear and sequential software development approach where progress flows steadily downwards through distinct phases, like a waterfall. Each phase (requirements, design, implementation, verification, and maintenance) must be completed before moving to the next one, with minimal overlap between phases. Documentation is created at each stage, and there is minimal room for changes once a phase is completed. While structured and straightforward to understand, the Waterfall Model has been criticized for its inflexibility in adapting to changing requirements and the delay in producing working software until late in the development lifecycle. It is most suitable for projects with well-understood, stable requirements and where changes are unlikely during development.",
        "trans_Question": "ɪn sɔ́ftwɛ̀ər dəvɛ́ləpmənt, wɪ́tʃ mɛ̀θədɒ́lədʒij fɒ́lowz ə strɪ́ktlij səkwɛ́nʃəl əprówtʃ wɛ́ər ijtʃ féjz mʌst bij kəmplíjtɪd bəfɔ́r ðə nɛ́kst féjz bəɡɪ́nz?",
        "trans_RightAnswer": "wɔ́tərfɔ̀l mɒ́dəl",
        "trans_WrongAnswers": [
            "ǽdʒəl fréjmwɜ̀rk",
            "spájərəl mɛ̀θədɒ́lədʒij",
            "skrʌ́m prɒ́sɛs",
            "kænbǽn sɪ́stəm",
            "əkstríjm prówɡræ̀mɪŋ"
        ],
        "trans_Explanation": "ðə wɔ́tərfɔ̀l mɒ́dəl ɪz ə lɪ́nijər ənd səkwɛ́nʃəl sɔ́ftwɛ̀ər dəvɛ́ləpmənt əprówtʃ wɛ́ər prɒ́ɡrɛ̀s flówz stɛ́dɪlij dáwnwərdz θrúw dɪstɪ́ŋkt féjzɪz, lájk ə wɔ́tərfɔ̀l. ijtʃ féjz (rəkwájərmənts, dəzájn, ɪ̀mpləmɛntéjʃən, vɛ̀ərɪfɪkéjʃən, ənd méjntənəns) mʌst bij kəmplíjtɪd bəfɔ́r múwvɪŋ tə ðə nɛ́kst wʌ́n, wɪð mɪ́nɪməl ówvərlæ̀p bijtwíjn féjzɪz. dɒ̀kjəmɛntéjʃən ɪz krijéjtɪd æt ijtʃ stéjdʒ, ənd ðɛər ɪz mɪ́nɪməl rúwm fɔr tʃéjndʒɪz wʌ́ns ə féjz ɪz kəmplíjtɪd. wájl strʌ́ktʃərd ənd stréjtfɔ́rwərd tə ʌ̀ndərstǽnd, ðə wɔ́tərfɔ̀l mɒ́dəl həz bɪn krɪ́tɪsàjzd fɔr ɪts ɪ̀nflɛ̀ksɪbɪ́lɪtij ɪn ədǽptɪŋ tə tʃéjndʒɪŋ rəkwájərmənts ənd ðə dəléj ɪn prədúwsɪŋ wɜ́rkɪŋ sɔ́ftwɛ̀ər əntɪ́l léjt ɪn ðə dəvɛ́ləpmənt lájfsàjkəl. ɪt ɪz mówst súwtəbəl fɔr prɒ́dʒɛkts wɪð wɛ́l-ʌ̀ndərstʊ́d, stéjbəl rəkwájərmənts ənd wɛ́ər tʃéjndʒɪz ɑr ʌ̀nlájklij dʊ́rɪŋ dəvɛ́ləpmənt."
    },
    {
        "Question": "Which software development methodology requires developers to write tests before implementing the actual code, focusing on short iterations of test writing, implementation, and refactoring?",
        "RightAnswer": "Test-Driven Development",
        "WrongAnswers": [
            "Waterfall Development",
            "Continuous Integration",
            "Feature-Driven Development",
            "Behavior-Driven Development",
            "Agile Prototyping"
        ],
        "Explanation": "Test-Driven Development (TDD) is a software development approach where developers write tests for a feature before implementing the actual code. The TDD cycle consists of three steps: first, writing a failing test that defines the desired functionality; second, writing the minimum amount of code necessary to make the test pass; and third, refactoring the code while ensuring tests continue to pass. This methodology helps ensure code meets requirements, remains maintainable, and has built-in verification. TDD encourages developers to think about design before implementation, leading to more modular, flexible code with fewer bugs. It also creates an automated test suite that serves as living documentation and safeguards against regression issues when making future changes. While initially appearing to slow development, TDD often reduces debugging time and increases overall code quality and developer confidence.",
        "trans_Question": "wɪ́tʃ sɔ́ftwɛ̀ər dəvɛ́ləpmənt mɛ̀θədɒ́lədʒij rəkwájərz dəvɛ́ləpərz tə rájt tɛ́sts bəfɔ́r ɪ́mpləmɛ̀ntɪŋ ðə ǽktʃəl kówd, fówkəsɪŋ ɒn ʃɔ́rt ɪ̀təréjʃənz əv tɛ́st rájtɪŋ, ɪ̀mpləmɛntéjʃən, ənd rijfǽktərɪŋ?",
        "trans_RightAnswer": "tɛ́st-drɪ́vən dəvɛ́ləpmənt",
        "trans_WrongAnswers": [
            "wɔ́tərfɔ̀l dəvɛ́ləpmənt",
            "kəntɪ́njuwəs ɪntəɡrejʃən",
            "fíjtʃər-drɪ́vən dəvɛ́ləpmənt",
            "bəhéjvjər-drɪ́vən dəvɛ́ləpmənt",
            "ǽdʒəl prówtowtàjpɪŋ"
        ],
        "trans_Explanation": "tɛ́st-drɪ́vən dəvɛ́ləpmənt (TDD) ɪz ə sɔ́ftwɛ̀ər dəvɛ́ləpmənt əprówtʃ wɛ́ər dəvɛ́ləpərz rájt tɛ́sts fɔr ə fíjtʃər bəfɔ́r ɪ́mpləmɛ̀ntɪŋ ðə ǽktʃəl kówd. ðə TDD sájkəl kənsɪ́sts əv θríj stɛ́ps: fɜ́rst, rájtɪŋ ə féjlɪŋ tɛ́st ðət dəfájnz ðə dəzájərd fʌ̀ŋkʃənǽlɪtij; sɛ́kənd, rájtɪŋ ðə mɪ́nɪməm əmáwnt əv kówd nɛ́səsɛ̀ərij tə méjk ðə tɛ́st pǽs; ənd θɜ́rd, rijfǽktərɪŋ ðə kówd wájl ɛnʃʊ́rɪŋ tɛ́sts kəntɪ́njuw tə pǽs. ðɪs mɛ̀θədɒ́lədʒij hɛ́lps ənʃʊ́r kówd míjts rəkwájərmənts, rəméjnz mejntéjnəbəl, ənd həz bɪ́lt-ɪn vɛ̀ərɪfɪkéjʃən. TDD ənkɜ́rɪdʒɪz dəvɛ́ləpərz tə θɪ́ŋk əbawt dəzájn bəfɔ́r ɪ̀mpləmɛntéjʃən, líjdɪŋ tə mɔr mɒ́dʒələr, flɛ́ksɪbəl kówd wɪð fjúwər bʌ́ɡz. ɪt ɔ́lsow krijéjts ən ɔ́təmèjtɪd tɛ́st swíjt ðət sɜ́rvz æz lɪ́vɪŋ dɒ̀kjəmɛntéjʃən ənd séjfɡɑ̀rdz əɡéjnst rəɡrɛ́ʃən ɪ́ʃuwz wɛ́n méjkɪŋ fjúwtʃər tʃéjndʒɪz. wájl ɪnɪ́ʃəlij əpɪ́ərɪŋ tə slów dəvɛ́ləpmənt, TDD ɔ́fən rədjúwsɪz dijbʌ́ɡɪŋ tájm ənd ɪnkríjsɪz ówvərɔ̀l kówd kwɑ́lɪtij ənd dəvɛ́ləpər kɒ́nfɪdəns."
    },
    {
        "Question": "What software development practice involves automatically integrating code changes from multiple developers into a shared repository multiple times a day, allowing teams to detect integration problems early?",
        "RightAnswer": "Continuous Integration",
        "WrongAnswers": [
            "Agile Modeling",
            "Test-Driven Development",
            "Feature Toggling",
            "Version Control Management",
            "Microservice Architecture"
        ],
        "Explanation": "Continuous Integration is a software development practice where team members integrate their work frequently, usually multiple times per day. Each integration is verified by an automated build and automated tests to detect integration errors as quickly as possible. Rather than building features in isolation and integrating them at the end of a development cycle, CI encourages developers to share their code and integrate it into a shared repository throughout the day. This approach reduces integration problems, improves software quality, and speeds up delivery times. When developers submit code to the repository, automated systems build the application and run various tests to ensure the new code doesn't break existing functionality. If an issue is found, the team is notified immediately so they can fix it while the changes are still fresh in their minds. CI is often paired with Continuous Delivery and Continuous Deployment as part of a comprehensive DevOps approach to software development.",
        "trans_Question": "wɒt sɔ́ftwɛ̀ər dəvɛ́ləpmənt prǽktɪs ɪnvɒ́lvz ɔ̀təmǽtɪklij ɪ́ntəɡrejtɪŋ kówd tʃéjndʒɪz frəm mʌ́ltɪpəl dəvɛ́ləpərz ɪntə ə ʃɛ́ərd rijpɒ́zɪtɔ̀rij mʌ́ltɪpəl tájmz ə déj, əláwɪŋ tíjmz tə dətɛ́kt ɪntəɡrejʃən prɒ́bləmz ɜ́rlij?",
        "trans_RightAnswer": "kəntɪ́njuwəs ɪntəɡrejʃən",
        "trans_WrongAnswers": [
            "ǽdʒəl mɒ́dəlɪ̀ŋ",
            "tɛ́st-drɪ́vən dəvɛ́ləpmənt",
            "fíjtʃər tɒ́ɡlɪŋ",
            "vɜ́rʒən kəntrówl mǽnədʒmənt",
            "májkrowsɜ̀rvɪs ɑ́rkɪtɛ̀ktʃər"
        ],
        "trans_Explanation": "kəntɪ́njuwəs ɪntəɡrejʃən ɪz ə sɔ́ftwɛ̀ər dəvɛ́ləpmənt prǽktɪs wɛ́ər tíjm mɛ́mbərz ɪ́ntəɡrejt ðɛər wɜ́rk fríjkwəntlij, júwʒəlij mʌ́ltɪpəl tájmz pɜ́r déj. ijtʃ ɪntəɡrejʃən ɪz vɛ́ərɪfajd baj ən ɔ́təmèjtɪd bɪ́ld ənd ɔ́təmèjtɪd tɛ́sts tə dətɛ́kt ɪntəɡrejʃən ɛ́ərərz æz kwɪ́klij æz pɒ́sɪbəl. rǽðər ðʌn bɪ́ldɪŋ fíjtʃərz ɪn àjsəléjʃən ənd ɪ́ntəɡrejtɪŋ ðɛm æt ðə ɛ́nd əv ə dəvɛ́ləpmənt sájkəl, CI ənkɜ́rɪdʒɪz dəvɛ́ləpərz tə ʃɛ́ər ðɛər kówd ənd ɪ́ntəɡrejt ɪt ɪntə ə ʃɛ́ərd rijpɒ́zɪtɔ̀rij θruwáwt ðə déj. ðɪs əprówtʃ rədjúwsɪz ɪntəɡrejʃən prɒ́bləmz, ɪmprúwvz sɔ́ftwɛ̀ər kwɑ́lɪtij, ənd spíjdz ʌp dəlɪ́vərij tájmz. wɛ́n dəvɛ́ləpərz səbmɪ́t kówd tə ðə rijpɒ́zɪtɔ̀rij, ɔ́təmèjtɪd sɪ́stəmz bɪ́ld ðə æ̀plɪkéjʃən ənd rʌ́n vɛ́ərijəs tɛ́sts tə ənʃʊ́r ðə núw kówd dʌ́zənt bréjk əɡzɪ́stɪŋ fʌ̀ŋkʃənǽlɪtij. ɪf ən ɪ́ʃuw ɪz fáwnd, ðə tíjm ɪz nówtɪfàjd ɪmíjdijətlij sow ðej kən fɪ́ks ɪt wájl ðə tʃéjndʒɪz ɑr stɪ́l frɛ́ʃ ɪn ðɛər májndz. CI ɪz ɔ́fən pɛ́ərd wɪð kəntɪ́njuwəs dəlɪ́vərij ənd kəntɪ́njuwəs dəplɔ́jmənt æz pɑ́rt əv ə kɒ̀mprəhɛ́nsɪv dɛ́vɒps əprówtʃ tə sɔ́ftwɛ̀ər dəvɛ́ləpmənt."
    },
    {
        "Question": "Which DevOps practice involves automatically releasing code changes to production environments as soon as they pass automated tests, without human intervention?",
        "RightAnswer": "Continuous Deployment",
        "WrongAnswers": [
            "Agile Integration",
            "Automated Versioning",
            "Iterative Delivery",
            "Progressive Release Management",
            "Systematic Code Propagation"
        ],
        "Explanation": "Continuous Deployment is a software development practice where code changes are automatically built, tested, and deployed to production without manual approval steps. Unlike Continuous Delivery, which prepares code for release but requires a human to approve the final push to production, Continuous Deployment eliminates this manual gate. Every change that passes automated tests is automatically deployed to users. This approach requires robust testing frameworks and monitoring systems to ensure reliability, but it enables organizations to release features and fixes multiple times per day, dramatically reducing the time between writing code and getting user feedback. Companies like Netflix, Amazon, and Google use Continuous Deployment to maintain competitive advantage through rapid, reliable software delivery.",
        "trans_Question": "wɪ́tʃ dɛ́vɒps prǽktɪs ɪnvɒ́lvz ɔ̀təmǽtɪklij rəlíjsɪŋ kówd tʃéjndʒɪz tə prədʌ́kʃən ənvájərənmənts æz súwn æz ðej pǽs ɔ́təmèjtɪd tɛ́sts, wɪðáwt hjúwmən ɪ̀ntərvɛ́nʃən?",
        "trans_RightAnswer": "kəntɪ́njuwəs dəplɔ́jmənt",
        "trans_WrongAnswers": [
            "ǽdʒəl ɪntəɡrejʃən",
            "ɔ́təmèjtɪd vɜ́rʒənɪŋ",
            "ɪ́tərətɪv dəlɪ́vərij",
            "prəɡrɛ́sɪv rəlíjs mǽnədʒmənt",
            "sɪ̀stəmǽtɪk kówd prɒ̀pəɡéjʃən"
        ],
        "trans_Explanation": "kəntɪ́njuwəs dəplɔ́jmənt ɪz ə sɔ́ftwɛ̀ər dəvɛ́ləpmənt prǽktɪs wɛ́ər kówd tʃéjndʒɪz ɑr ɔ̀təmǽtɪklij bɪ́lt, tɛ́stɪd, ənd dəplɔ́jd tə prədʌ́kʃən wɪðáwt mǽnjuwəl əprúwvəl stɛ́ps. ʌ̀nlájk kəntɪ́njuwəs dəlɪ́vərij, wɪ́tʃ prəpɛ́ərz kówd fɔr rəlíjs bʌt rəkwájərz ə hjúwmən tə əprúwv ðə fájnəl pʊ́ʃ tə prədʌ́kʃən, kəntɪ́njuwəs dəplɔ́jmənt əlɪ́mɪnèjts ðɪs mǽnjuwəl ɡéjt. ɛvərij tʃéjndʒ ðət pǽsɪz ɔ́təmèjtɪd tɛ́sts ɪz ɔ̀təmǽtɪklij dəplɔ́jd tə júwzərz. ðɪs əprówtʃ rəkwájərz rowbʌ́st tɛ́stɪŋ fréjmwɜ̀rks ənd mɒ́nɪtərɪŋ sɪ́stəmz tə ənʃʊ́r rəlàjəbɪ́lɪtij, bʌt ɪt ɛnéjbəlz ɔ̀rɡənɪzéjʃənz tə rəlíjs fíjtʃərz ənd fɪ́ksɪz mʌ́ltɪpəl tájmz pɜ́r déj, drəmǽtɪkəlij rədjúwsɪŋ ðə tájm bijtwíjn rájtɪŋ kówd ənd ɡɛ́tɪŋ júwzər fíjdbæ̀k. kʌ́mpənìjz lájk nɛ́tflɪks, əmǽzɒn, ənd ɡúwɡəl juwz kəntɪ́njuwəs dəplɔ́jmənt tə mejntéjn kəmpɛ́tɪtɪv ədvǽntɪdʒ θrúw rǽpɪd, rəlájəbəl sɔ́ftwɛ̀ər dəlɪ́vərij."
    },
    {
        "Question": "What is the system that tracks changes to code over time, allowing developers to collaborate without overwriting each other's work and revert to previous versions when needed?",
        "RightAnswer": "Version Control",
        "WrongAnswers": [
            "Code Compilation",
            "Memory Management",
            "Database Indexing",
            "Protocol Buffering",
            "Runtime Environment"
        ],
        "Explanation": "Version Control is a system that records changes to files over time so that you can recall specific versions later. In software development, it serves as a critical collaboration tool that allows multiple developers to work on the same codebase simultaneously without conflicting changes. Systems like Git, SVN, and Mercurial maintain a complete history of modifications, enabling teams to track who made what changes and when, revert to previous states of the project, compare changes over time, and identify who introduced specific features or bugs. Beyond just tracking changes, modern version control systems support branching, which allows developers to create separate workspaces for new features or experiments without affecting the main codebase, and merging, which helps integrate changes from different branches. Version control has become an essential part of software development workflow, enhancing collaboration, maintaining code quality, and providing a safety net for code experimentation.",
        "trans_Question": "wɒt ɪz ðə sɪ́stəm ðət trǽks tʃéjndʒɪz tə kówd ówvər tájm, əláwɪŋ dəvɛ́ləpərz tə kəlǽbərèjt wɪðáwt òwvərrájtɪŋ ijtʃ ʌ́ðər'z wɜ́rk ənd rijvɜ́rt tə príjvijəs vɜ́rʒənz wɛ́n níjdɪd?",
        "trans_RightAnswer": "vɜ́rʒən kəntrówl",
        "trans_WrongAnswers": [
            "kówd kɒ̀mpɪléjʃən",
            "mɛ́mərij mǽnədʒmənt",
            "déjtəbèjs ɪ́ndɛksɪŋ",
            "prówtəkɒ̀l bʌ́fərɪŋ",
            "rʌ́ntàjm ənvájərənmənt"
        ],
        "trans_Explanation": "vɜ́rʒən kəntrówl ɪz ə sɪ́stəm ðət rɛ́kərdz tʃéjndʒɪz tə fájlz ówvər tájm sow ðət juw kən rijkɔ́l spəsɪ́fɪk vɜ́rʒənz léjtər. ɪn sɔ́ftwɛ̀ər dəvɛ́ləpmənt, ɪt sɜ́rvz æz ə krɪ́tɪkəl kəlæ̀bəréjʃən túwl ðət əláwz mʌ́ltɪpəl dəvɛ́ləpərz tə wɜ́rk ɒn ðə séjm kówdbèjs sàjməltéjnijəslij wɪðáwt kənflɪ́ktɪŋ tʃéjndʒɪz. sɪ́stəmz lájk ɡɪ́t, SVN, ənd mərkjʊ́rijəl mejntéjn ə kəmplíjt hɪ́stərij əv mɒ̀dɪfɪkéjʃənz, ɛnéjbəlɪŋ tíjmz tə trǽk huw méjd wɒt tʃéjndʒɪz ənd wɛ́n, rijvɜ́rt tə príjvijəs stéjts əv ðə prɒ́dʒɛkt, kəmpɛ́ər tʃéjndʒɪz ówvər tájm, ənd ajdɛ́ntɪfàj huw ɪntrədúwst spəsɪ́fɪk fíjtʃərz ɔr bʌ́ɡz. bìjɔ́nd dʒəst trǽkɪŋ tʃéjndʒɪz, mɒ́dərn vɜ́rʒən kəntrówl sɪ́stəmz səpɔ́rt brǽntʃɪŋ, wɪ́tʃ əláwz dəvɛ́ləpərz tə krijéjt sɛ́pərət wɜ́rkspèjsɪz fɔr núw fíjtʃərz ɔr əkspɛ́ərɪmənts wɪðáwt əfɛ́ktɪŋ ðə méjn kówdbèjs, ənd mɜ́rdʒɪŋ, wɪ́tʃ hɛ́lps ɪ́ntəɡrejt tʃéjndʒɪz frəm dɪ́fərənt brǽntʃɪz. vɜ́rʒən kəntrówl həz bəkʌ́m ən əsɛ́nʃəl pɑ́rt əv sɔ́ftwɛ̀ər dəvɛ́ləpmənt wɜ́rkflòw, ɛnhǽnsɪŋ kəlæ̀bəréjʃən, mejntéjnɪŋ kówd kwɑ́lɪtij, ənd prəvájdɪŋ ə séjftij nɛ́t fɔr kówd əkspɛ̀ərɪməntéjʃən."
    },
    {
        "Question": "Which distributed version control system, created by Linus Torvalds in 2005, allows developers to track changes to source code during software development and facilitates collaboration among multiple contributors?",
        "RightAnswer": "Git",
        "WrongAnswers": [
            "Docker",
            "Jenkins",
            "Kubernetes",
            "Maven",
            "Hadoop"
        ],
        "Explanation": "Git is a distributed version control system that revolutionized software development by offering a robust framework for tracking changes in source code. Unlike centralized systems, Git provides each developer with a complete local copy of the repository, enabling work without constant network access. Created by Linus Torvalds to manage Linux kernel development, Git excels at branching, allowing multiple development paths to proceed in parallel without interference. Its distributed nature facilitates collaboration among globally dispersed teams, while its integrity checks ensure code remains uncorrupted. Git's staging area offers a unique intermediate step between working files and committed history, giving developers fine-grained control over what changes become part of the project record. This combination of speed, reliability, and flexibility has made Git the dominant version control system in modern software development, forming the foundation for platforms like GitHub and GitLab.",
        "trans_Question": "wɪ́tʃ dɪstrɪ́bjətɪd vɜ́rʒən kəntrówl sɪ́stəm, krijéjtɪd baj lájnəs tɔ́rvɒldz ɪn 2005, əláwz dəvɛ́ləpərz tə trǽk tʃéjndʒɪz tə sɔ́rs kówd dʊ́rɪŋ sɔ́ftwɛ̀ər dəvɛ́ləpmənt ənd fəsɪ́lətèjts kəlæ̀bəréjʃən əmʌ́ŋ mʌ́ltɪpəl kəntrɪ́bjətərz?",
        "trans_RightAnswer": "ɡɪ́t",
        "trans_WrongAnswers": [
            "dɒ́kər",
            "dʒɛ́ŋkɪnz",
            "kuwbərnɛ́tɪs",
            "méjvən",
            "hǽdúwp"
        ],
        "trans_Explanation": "ɡɪ́t ɪz ə dɪstrɪ́bjətɪd vɜ́rʒən kəntrówl sɪ́stəm ðət rɛ̀vəlúwʃənàjzd sɔ́ftwɛ̀ər dəvɛ́ləpmənt baj ɔ́fərɪŋ ə rowbʌ́st fréjmwɜ̀rk fɔr trǽkɪŋ tʃéjndʒɪz ɪn sɔ́rs kówd. ʌ̀nlájk sɛ́ntrəlàjzd sɪ́stəmz, ɡɪ́t prəvájdz ijtʃ dəvɛ́ləpər wɪð ə kəmplíjt lówkəl kɒ́pij əv ðə rijpɒ́zɪtɔ̀rij, ɛnéjbəlɪŋ wɜ́rk wɪðáwt kɒ́nstənt nɛ́twɜ̀rk ǽksɛ̀s. krijéjtɪd baj lájnəs tɔ́rvɒldz tə mǽnɪdʒ lɪ́nəks kɜ́rnəl dəvɛ́ləpmənt, ɡɪ́t əksɛ́lz æt brǽntʃɪŋ, əláwɪŋ mʌ́ltɪpəl dəvɛ́ləpmənt pǽðz tə prəsíjd ɪn pǽrəlɛ̀l wɪðáwt ɪ̀ntərfɪ́ərəns. ɪts dɪstrɪ́bjətɪd néjtʃər fəsɪ́lətèjts kəlæ̀bəréjʃən əmʌ́ŋ ɡlówbəlij dɪspɜ́rst tíjmz, wájl ɪts ɪntɛ́ɡrɪtij tʃɛ́ks ənʃʊ́r kówd rəméjnz ʌ̀nkərʌ́ptɪd. ɡɪ́t's stéjdʒɪŋ ɛ́ərijə ɔ́fərz ə juwnɪ́k ɪ̀ntərmíjdijət stɛ́p bijtwíjn wɜ́rkɪŋ fájlz ənd kəmɪ́tɪd hɪ́stərij, ɡɪ́vɪŋ dəvɛ́ləpərz fájn-ɡréjnd kəntrówl ówvər wɒt tʃéjndʒɪz bəkʌ́m pɑ́rt əv ðə prɒ́dʒɛkt rɛ́kɔrd. ðɪs kɒ̀mbɪnéjʃən əv spíjd, rəlàjəbɪ́lɪtij, ənd flɛ̀ksɪbɪ́lɪtij həz méjd ɡɪ́t ðə dɒ́mɪnənt vɜ́rʒən kəntrówl sɪ́stəm ɪn mɒ́dərn sɔ́ftwɛ̀ər dəvɛ́ləpmənt, fɔ́rmɪŋ ðə fawndéjʃən fɔr plǽtfɔ̀rmz lájk ɡɪ́thəb ənd ɡɪ́tlæb."
    },
    {
        "Question": "In software development, what term describes the practice of creating a separate, isolated copy of source code to enable parallel work on different features or bug fixes without affecting the original codebase?",
        "RightAnswer": "Branching",
        "WrongAnswers": [
            "Forking",
            "Threading",
            "Instantiation",
            "Partitioning",
            "Segmentation"
        ],
        "Explanation": "Branching is a fundamental concept in version control systems and software development that allows developers to diverge from the main development line to work on specific features, fixes, or experiments without disrupting the primary codebase. Think of it like creating an alternate timeline where changes can be made safely and independently. When a branch is created, it contains a complete copy of the source code at that point in time. Developers can then modify this branch without affecting others' work. Once the changes in a branch are complete and tested, they can be merged back into the main codebase, integrating the new features or fixes. Branching facilitates collaboration among teams, enables parallel development, and provides a structured approach to managing code changes. It's a cornerstone practice in modern development workflows like Git, allowing for more organized, efficient, and less risky software development processes.",
        "trans_Question": "ɪn sɔ́ftwɛ̀ər dəvɛ́ləpmənt, wɒt tɜ́rm dəskrájbz ðə prǽktɪs əv krijéjtɪŋ ə sɛ́pərət, ájsəlèjtɪd kɒ́pij əv sɔ́rs kówd tə ɛnéjbəl pǽrəlɛ̀l wɜ́rk ɒn dɪ́fərənt fíjtʃərz ɔr bʌ́ɡ fɪ́ksɪz wɪðáwt əfɛ́ktɪŋ ðə ərɪ́dʒɪnəl kówdbèjs?",
        "trans_RightAnswer": "brǽntʃɪŋ",
        "trans_WrongAnswers": [
            "fɔ́rkɪŋ",
            "θrɛ́dɪŋ",
            "ɪnstæ̀nʃijéjʃən",
            "pɑrtɪ́ʃənɪŋ",
            "sɛ̀ɡməntéjʃən"
        ],
        "trans_Explanation": "brǽntʃɪŋ ɪz ə fʌ̀ndəmɛ́ntəl kɒ́nsɛpt ɪn vɜ́rʒən kəntrówl sɪ́stəmz ənd sɔ́ftwɛ̀ər dəvɛ́ləpmənt ðət əláwz dəvɛ́ləpərz tə dajvɜ́rdʒ frəm ðə méjn dəvɛ́ləpmənt lájn tə wɜ́rk ɒn spəsɪ́fɪk fíjtʃərz, fɪ́ksɪz, ɔr əkspɛ́ərɪmənts wɪðáwt dɪsrʌ́ptɪŋ ðə prájmɛ̀ərij kówdbèjs. θɪ́ŋk əv ɪt lájk krijéjtɪŋ ən ɔ́ltərnət tájmlajn wɛ́ər tʃéjndʒɪz kən bij méjd séjflij ənd ɪndəpɛ́ndəntlij. wɛ́n ə brǽntʃ ɪz krijéjtɪd, ɪt kəntéjnz ə kəmplíjt kɒ́pij əv ðə sɔ́rs kówd æt ðət pɔ́jnt ɪn tájm. dəvɛ́ləpərz kən ðɛn mɒ́dɪfàj ðɪs brǽntʃ wɪðáwt əfɛ́ktɪŋ ʌ́ðərz' wɜ́rk. wʌ́ns ðə tʃéjndʒɪz ɪn ə brǽntʃ ɑr kəmplíjt ənd tɛ́stɪd, ðej kən bij mɜ́rdʒd bǽk ɪntə ðə méjn kówdbèjs, ɪ́ntəɡrejtɪŋ ðə núw fíjtʃərz ɔr fɪ́ksɪz. brǽntʃɪŋ fəsɪ́lətèjts kəlæ̀bəréjʃən əmʌ́ŋ tíjmz, ɛnéjbəlz pǽrəlɛ̀l dəvɛ́ləpmənt, ənd prəvájdz ə strʌ́ktʃərd əprówtʃ tə mǽnɪdʒɪŋ kówd tʃéjndʒɪz. ɪt's ə kɔ́rnərstòwn prǽktɪs ɪn mɒ́dərn dəvɛ́ləpmənt wɜ́rkflòwz lájk ɡɪ́t, əláwɪŋ fɔr mɔr ɔ́rɡənàjzd, əfɪ́ʃənt, ənd lɛ́s rɪ́skij sɔ́ftwɛ̀ər dəvɛ́ləpmənt prɒ́sɛsɪz."
    },
    {
        "Question": "In version control systems like Git, what is the process called when you combine changes from different branches into a single branch?",
        "RightAnswer": "Merging",
        "WrongAnswers": [
            "Compiling",
            "Refactoring",
            "Serializing",
            "Encapsulation",
            "Polymorphism"
        ],
        "Explanation": "Merging in computer science refers to the process of combining multiple sets of data, code, or files into a unified whole. In version control systems like Git, merging is a fundamental operation that allows developers to integrate changes from one branch into another. When different team members work on separate branches and develop features independently, merging brings these parallel lines of development together. The process involves analyzing the differences between the versions and intelligently combining them while resolving any conflicts that might arise when the same part of a file has been modified in different ways. Merging is also a key concept in algorithms, particularly in sorting techniques like merge sort, where divided segments of data are systematically combined in sorted order. Understanding merging is essential for collaborative software development, data integration, and efficient algorithm design.",
        "trans_Question": "ɪn vɜ́rʒən kəntrówl sɪ́stəmz lájk ɡɪ́t, wɒt ɪz ðə prɒ́sɛs kɔ́ld wɛ́n juw kɒ́mbajn tʃéjndʒɪz frəm dɪ́fərənt brǽntʃɪz ɪntə ə sɪ́ŋɡəl brǽntʃ?",
        "trans_RightAnswer": "mɜ́rdʒɪŋ",
        "trans_WrongAnswers": [
            "kəmpájlɪŋ",
            "rijfǽktərɪŋ",
            "sɪ́ərijəlajzɪŋ",
            "ɛnkǽpsəlèjʃən",
            "pɒ̀lijmɔ́rfɪzm"
        ],
        "trans_Explanation": "mɜ́rdʒɪŋ ɪn kəmpjúwtər sájəns rəfɜ́rz tə ðə prɒ́sɛs əv kəmbájnɪŋ mʌ́ltɪpəl sɛ́ts əv déjtə, kówd, ɔr fájlz ɪntə ə júwnɪfàjd hówl. ɪn vɜ́rʒən kəntrówl sɪ́stəmz lájk ɡɪ́t, mɜ́rdʒɪŋ ɪz ə fʌ̀ndəmɛ́ntəl ɒ̀pəréjʃən ðət əláwz dəvɛ́ləpərz tə ɪ́ntəɡrejt tʃéjndʒɪz frəm wʌ́n brǽntʃ ɪntə ənʌ́ðər. wɛ́n dɪ́fərənt tíjm mɛ́mbərz wɜ́rk ɒn sɛ́pərət brǽntʃɪz ənd dəvɛ́ləp fíjtʃərz ɪndəpɛ́ndəntlij, mɜ́rdʒɪŋ brɪ́ŋz ðijz pǽrəlɛ̀l lájnz əv dəvɛ́ləpmənt təɡɛ́ðər. ðə prɒ́sɛs ɪnvɒ́lvz ǽnəlàjzɪŋ ðə dɪ́fərənsɪz bijtwíjn ðə vɜ́rʒənz ənd ɪntɛ́lɪdʒəntlij kəmbájnɪŋ ðɛm wájl rijzɒ́lvɪŋ ɛ́nij kɒ́nflɪkts ðət majt ərájz wɛ́n ðə séjm pɑ́rt əv ə fájl həz bɪn mɒ́dɪfàjd ɪn dɪ́fərənt wéjz. mɜ́rdʒɪŋ ɪz ɔ́lsow ə kíj kɒ́nsɛpt ɪn ǽlɡərɪ̀ðəmz, pərtɪ́kjələrlij ɪn sɔ́rtɪŋ tɛkníjks lájk mɜ́rdʒ sɔ́rt, wɛ́ər dɪvájdɪd sɛ́ɡmənts əv déjtə ɑr sɪ̀stəmǽtɪklij kəmbájnd ɪn sɔ́rtɪd ɔ́rdər. ʌ̀ndərstǽndɪŋ mɜ́rdʒɪŋ ɪz əsɛ́nʃəl fɔr kəlǽbərətɪv sɔ́ftwɛ̀ər dəvɛ́ləpmənt, déjtə ɪntəɡrejʃən, ənd əfɪ́ʃənt ǽlɡərɪ̀ðəm dəzájn."
    },
    {
        "Question": "What is the name for a centralized storage location where software code, packages, or other digital assets are stored, managed, and can be retrieved for development or distribution purposes?",
        "RightAnswer": "Repository",
        "WrongAnswers": [
            "Cache",
            "Registry",
            "Pipeline",
            "Sandbox",
            "Archive"
        ],
        "Explanation": "A Repository in computer science is a structured storage space that allows developers to store, manage, access, and track changes to code, software packages, or other digital assets. Unlike simple file storage, repositories typically include version control capabilities, enabling teams to collaborate on projects while maintaining a history of changes. Modern repositories like GitHub, GitLab, or Bitbucket provide additional features such as issue tracking, pull requests, and project management tools. Repositories can be public, allowing anyone to view and potentially contribute to the code, or private, restricting access to authorized users. They serve as the central hub for software development projects, providing a reliable source of truth for the current state of a codebase and its evolution over time.",
        "trans_Question": "wɒt ɪz ðə néjm fɔr ə sɛ́ntrəlàjzd stɔ́rɪdʒ lowkéjʃən wɛ́ər sɔ́ftwɛ̀ər kówd, pǽkɪdʒɪz, ɔr ʌ́ðər dɪ́dʒɪtəl ǽsɛts ɑr stɔ́rd, mǽnɪdʒd, ənd kən bij rətríjvd fɔr dəvɛ́ləpmənt ɔr dɪ̀strəbjúwʃən pɜ́rpəsɪz?",
        "trans_RightAnswer": "rijpɒ́zɪtɔ̀rij",
        "trans_WrongAnswers": [
            "kǽʃ",
            "rɛ́dʒɪstrij",
            "pájplàjn",
            "sǽndbɒ̀ks",
            "ɑ́rkàjv"
        ],
        "trans_Explanation": "ə rijpɒ́zɪtɔ̀rij ɪn kəmpjúwtər sájəns ɪz ə strʌ́ktʃərd stɔ́rɪdʒ spéjs ðət əláwz dəvɛ́ləpərz tə stɔ́r, mǽnɪdʒ, ǽksɛ̀s, ənd trǽk tʃéjndʒɪz tə kówd, sɔ́ftwɛ̀ər pǽkɪdʒɪz, ɔr ʌ́ðər dɪ́dʒɪtəl ǽsɛts. ʌ̀nlájk sɪ́mpəl fájl stɔ́rɪdʒ, rijpɒ́zɪtɔ̀rijz tɪ́pɪkəlij ɪnklúwd vɜ́rʒən kəntrówl kèjpəbɪ́lɪtijz, ɛnéjbəlɪŋ tíjmz tə kəlǽbərèjt ɒn prɒ́dʒɛkts wájl mejntéjnɪŋ ə hɪ́stərij əv tʃéjndʒɪz. mɒ́dərn rijpɒ́zɪtɔ̀rijz lájk ɡɪ́thəb, ɡɪ́tlæb, ɔr bɪ́tbʌkɪt prəvájd ədɪ́ʃənəl fíjtʃərz sʌtʃ æz ɪ́ʃuw trǽkɪŋ, pʊ́l rəkwɛ́s, ənd prɒ́dʒɛkt mǽnədʒmənt túwlz. rijpɒ́zɪtɔ̀rijz kən bij pʌ́blɪk, əláwɪŋ ɛ́nijwən tə vjúw ənd pətɛ́nʃəlij kəntrɪ́bjuwt tə ðə kówd, ɔr prájvət, rəstrɪ́ktɪŋ ǽksɛ̀s tə ɔ́θəràjzd júwzərz. ðej sɜ́rv æz ðə sɛ́ntrəl hʌ́b fɔr sɔ́ftwɛ̀ər dəvɛ́ləpmənt prɒ́dʒɛkts, prəvájdɪŋ ə rəlájəbəl sɔ́rs əv trúwθ fɔr ðə kɑ́rənt stéjt əv ə kówdbèjs ənd ɪts ɛ̀vəlúwʃən ówvər tájm."
    },
    {
        "Question": "What is the term for a reusable solution to a commonly occurring problem in software architecture that software developers reference when designing applications?",
        "RightAnswer": "Software Design Pattern",
        "WrongAnswers": [
            "Code Compilation Framework",
            "Software Implementation Protocol",
            "Algorithm Runtime Model",
            "Binary Logic Structure",
            "Source Code Template"
        ],
        "Explanation": "A Software Design Pattern is a well-established, reusable solution to a common problem that occurs in software design. Think of it as a blueprint that can be customized to solve a particular design issue in your code. Rather than reinventing solutions to problems that have been solved countless times before, software developers use these patterns as starting points. Examples include the Singleton pattern (ensuring a class has only one instance), Factory pattern (creating objects without specifying the exact class), and Observer pattern (defining a subscription mechanism for objects). Design patterns improve code readability, reduce development time, and promote best practices by leveraging collective experience from the software development community. They are not finished designs that can be directly translated into code but rather templates that guide developers toward efficient, maintainable solutions.",
        "trans_Question": "wɒt ɪz ðə tɜ́rm fɔr ə rijúwzəbəl səlúwʃən tə ə kɒ́mənlij əkɜ́rɪŋ prɒ́bləm ɪn sɔ́ftwɛ̀ər ɑ́rkɪtɛ̀ktʃər ðət sɔ́ftwɛ̀ər dəvɛ́ləpərz rɛ́fərəns wɛ́n dəzájnɪŋ æ̀plɪkéjʃənz?",
        "trans_RightAnswer": "sɔ́ftwɛ̀ər dəzájn pǽtərn",
        "trans_WrongAnswers": [
            "kówd kɒ̀mpɪléjʃən fréjmwɜ̀rk",
            "sɔ́ftwɛ̀ər ɪ̀mpləmɛntéjʃən prówtəkɒ̀l",
            "ǽlɡərɪ̀ðəm rʌ́ntàjm mɒ́dəl",
            "bájnərij lɒ́dʒɪk strʌ́ktʃər",
            "sɔ́rs kówd tɛ́mplejt"
        ],
        "trans_Explanation": "ə sɔ́ftwɛ̀ər dəzájn pǽtərn ɪz ə wɛ́l-əstǽblɪʃt, rijúwzəbəl səlúwʃən tə ə kɒ́mən prɒ́bləm ðət əkɜ́rz ɪn sɔ́ftwɛ̀ər dəzájn. θɪ́ŋk əv ɪt æz ə blúwprɪ̀nt ðət kən bij kʌ́stəmàjzd tə sɒ́lv ə pərtɪ́kjələr dəzájn ɪ́ʃuw ɪn jɔr kówd. rǽðər ðʌn rìjɪnvɛ́ntɪŋ səlúwʃənz tə prɒ́bləmz ðət həv bɪn sɒ́lvd káwntləs tájmz bəfɔ́r, sɔ́ftwɛ̀ər dəvɛ́ləpərz juwz ðijz pǽtərnz æz stɑ́rtɪŋ pɔ́jnts. əɡzǽmpəlz ɪnklúwd ðə sɪ́ŋɡəltən pǽtərn (ɛnʃʊ́rɪŋ ə klǽs həz ównlij wʌ́n ɪ́nstəns), fǽktərij pǽtərn (krijéjtɪŋ ɒ́bdʒɛkts wɪðáwt spɛ́sɪfàjɪŋ ðə əɡzǽkt klǽs), ənd əbzɜ́rvər pǽtərn (dəfájnɪŋ ə sʌbskrɪ́pʃən mɛ́kənɪzəm fɔr ɒ́bdʒɛkts). dəzájn pǽtərnz ɪmprúwv kówd rìjdəbɪ́lɪtij, rədjúws dəvɛ́ləpmənt tájm, ənd prəmówt bɛ́st prǽktɪsɪz baj lɛ́vərɪdʒɪŋ kəlɛ́ktɪv əkspɪ́ərijəns frəm ðə sɔ́ftwɛ̀ər dəvɛ́ləpmənt kəmjúwnɪtij. ðej ɑr nɒt fɪ́nɪʃt dəzájnz ðət kən bij dɪərɛ́klij trænsléjtɪd ɪntə kówd bʌt rǽðər tɛ́mpləts ðət ɡájd dəvɛ́ləpərz təwɔ́rd əfɪ́ʃənt, mejntéjnəbəl səlúwʃənz."
    },
    {
        "Question": "Which design pattern ensures a class has only one instance and provides a global point of access to it, often used for managing shared resources like database connections?",
        "RightAnswer": "Singleton Pattern",
        "WrongAnswers": [
            "Observer Pattern",
            "Factory Method Pattern",
            "Decorator Pattern",
            "Bridge Pattern",
            "Composite Pattern"
        ],
        "Explanation": "The Singleton Pattern is a creational design pattern that restricts the instantiation of a class to a single instance and provides a global point of access to that instance. This pattern is particularly useful when exactly one object is needed to coordinate actions across the system. Common applications include managing shared resources like database connections, thread pools, caches, or configuration managers. The pattern typically involves making the constructor private to prevent direct instantiation, providing a static method that returns the same instance, and ensuring thread safety in concurrent environments. While powerful for ensuring consistency, singletons should be used judiciously as they can introduce global state and make testing more difficult. The Singleton Pattern represents an elegant solution to the problem of controlled resource sharing and centralized access in software design.",
        "trans_Question": "wɪ́tʃ dəzájn pǽtərn ənʃʊ́rz ə klǽs həz ównlij wʌ́n ɪ́nstəns ənd prəvájdz ə ɡlówbəl pɔ́jnt əv ǽksɛ̀s tə ɪt, ɔ́fən júwzd fɔr mǽnɪdʒɪŋ ʃɛ́ərd ríjsɔrsɪz lájk déjtəbèjs kənɛ́kʃənz?",
        "trans_RightAnswer": "sɪ́ŋɡəltən pǽtərn",
        "trans_WrongAnswers": [
            "əbzɜ́rvər pǽtərn",
            "fǽktərij mɛ́θəd pǽtərn",
            "dɛ́kərèjtər pǽtərn",
            "brɪ́dʒ pǽtərn",
            "kɒmpɒ́zɪt pǽtərn"
        ],
        "trans_Explanation": "ðə sɪ́ŋɡəltən pǽtərn ɪz ə krijéjʃənəl dəzájn pǽtərn ðət rəstrɪ́kts ðə ɪnstæ̀nʃijéjʃən əv ə klǽs tə ə sɪ́ŋɡəl ɪ́nstəns ənd prəvájdz ə ɡlówbəl pɔ́jnt əv ǽksɛ̀s tə ðət ɪ́nstəns. ðɪs pǽtərn ɪz pərtɪ́kjələrlij júwsfəl wɛ́n əɡzǽktlij wʌ́n ɒ́bdʒəkt ɪz níjdɪd tə kowɔ́rdɪnèjt ǽkʃənz əkrɔ́s ðə sɪ́stəm. kɒ́mən æ̀plɪkéjʃənz ɪnklúwd mǽnɪdʒɪŋ ʃɛ́ərd ríjsɔrsɪz lájk déjtəbèjs kənɛ́kʃənz, θrɛ́d púwlz, kǽʃɪz, ɔr kənfɪ̀ɡjəréjʃən mǽnədʒərz. ðə pǽtərn tɪ́pɪkəlij ɪnvɒ́lvz méjkɪŋ ðə kənstrʌ́ktər prájvət tə prəvɛ́nt dɪərɛ́kt ɪnstæ̀nʃijéjʃən, prəvájdɪŋ ə stǽtɪk mɛ́θəd ðət rətɜ́rnz ðə séjm ɪ́nstəns, ənd ɛnʃʊ́rɪŋ θrɛ́d séjftij ɪn kənkɜ́rənt ənvájərənmənts. wájl páwərfəl fɔr ɛnʃʊ́rɪŋ kənsɪ́stənsij, sɪ́ŋɡəltʌ̀nz ʃʊd bij júwzd dʒuwdɪ́ʃɪslij æz ðej kən ɪntrədúws ɡlówbəl stéjt ənd méjk tɛ́stɪŋ mɔr dɪ́fɪkəlt. ðə sɪ́ŋɡəltən pǽtərn rɛ̀prəzɛ́nts ən ɛ́ləɡənt səlúwʃən tə ðə prɒ́bləm əv kəntrówld ríjsɔrs ʃɛ́ərɪŋ ənd sɛ́ntrəlàjzd ǽksɛ̀s ɪn sɔ́ftwɛ̀ər dəzájn."
    },
    {
        "Question": "What design pattern enables objects to notify multiple dependent objects about changes without tight coupling, commonly seen in Model-View-Controller architecture?",
        "RightAnswer": "Observer Pattern",
        "WrongAnswers": [
            "Singleton Pattern",
            "Factory Pattern",
            "Decorator Pattern",
            "Strategy Pattern",
            "Command Pattern"
        ],
        "Explanation": "The Observer Pattern is a behavioral design pattern where an object, known as the subject, maintains a list of dependents, called observers, and notifies them automatically when its state changes. This creates a one-to-many relationship between the subject and its observers, allowing multiple objects to be notified of changes without being tightly coupled to the subject. A real-world example is a news publisher with subscribers who get notified when new content is available. In software, this pattern is fundamental to event-driven programming and graphical user interfaces where user interactions need to trigger updates across multiple components. The Observer Pattern promotes loose coupling between interacting objects, making systems more modular and easier to maintain. This pattern is a cornerstone of reactive programming and is extensively used in frameworks like Angular, React, and systems that implement the Model-View-Controller architecture.",
        "trans_Question": "wɒt dəzájn pǽtərn ɛnéjbəlz ɒ́bdʒɛkts tə nówtɪfàj mʌ́ltɪpəl dəpɛ́ndənt ɒ́bdʒɛkts əbawt tʃéjndʒɪz wɪðáwt tájt kʌ́plɪŋ, kɒ́mənlij síjn ɪn mɒ́dəl-vjúw-kəntrówlər ɑ́rkɪtɛ̀ktʃər?",
        "trans_RightAnswer": "əbzɜ́rvər pǽtərn",
        "trans_WrongAnswers": [
            "sɪ́ŋɡəltən pǽtərn",
            "fǽktərij pǽtərn",
            "dɛ́kərèjtər pǽtərn",
            "strǽtədʒij pǽtərn",
            "kəmǽnd pǽtərn"
        ],
        "trans_Explanation": "ðə əbzɜ́rvər pǽtərn ɪz ə bijhéjvjərəl dəzájn pǽtərn wɛ́ər ən ɒ́bdʒəkt, nówn æz ðə sʌ́bdʒəkt, mejntéjnz ə lɪ́st əv dəpɛ́ndənts, kɔ́ld əbzɜ́rvərz, ənd nówtɪfàjz ðɛm ɔ̀təmǽtɪklij wɛ́n ɪts stéjt tʃéjndʒɪz. ðɪs krijéjts ə wʌ́n-tə-mɛ́nij rəléjʃənʃɪ̀p bijtwíjn ðə sʌ́bdʒəkt ənd ɪts əbzɜ́rvərz, əláwɪŋ mʌ́ltɪpəl ɒ́bdʒɛkts tə bij nówtɪfàjd əv tʃéjndʒɪz wɪðáwt bíjɪŋ tájtlij kʌ́pəld tə ðə sʌ́bdʒəkt. ə ríjəl-wɜ́rld əɡzǽmpəl ɪz ə nuws pʌ́blɪʃər wɪð sʌbskrájbərz huw ɡɛt nówtɪfàjd wɛ́n núw kɒ́ntənt ɪz əvéjləbəl. ɪn sɔ́ftwɛ̀ər, ðɪs pǽtərn ɪz fʌ̀ndəmɛ́ntəl tə əvɛ́nt-drɪ́vən prówɡræ̀mɪŋ ənd ɡrǽfɪkəl júwzər ɪ́ntərfèjsɪz wɛ́ər júwzər ɪ̀ntərǽkʃənz níjd tə trɪ́ɡər ʌ́pdèjts əkrɔ́s mʌ́ltɪpəl kəmpównənts. ðə əbzɜ́rvər pǽtərn prəmówts lúws kʌ́plɪŋ bijtwíjn ɪ̀ntərǽktɪŋ ɒ́bdʒɛkts, méjkɪŋ sɪ́stəmz mɔr mɒ́dʒələr ənd íjzijər tə mejntéjn. ðɪs pǽtərn ɪz ə kɔ́rnərstòwn əv rijǽktɪv prówɡræ̀mɪŋ ənd ɪz əkstɛ́nsɪvlij júwzd ɪn fréjmwɜ̀rks lájk ǽŋɡjələr, rijǽkt, ənd sɪ́stəmz ðət ɪ́mpləmənt ðə mɒ́dəl-vjúw-kəntrówlər ɑ́rkɪtɛ̀ktʃər."
    },
    {
        "Question": "What design pattern allows you to create objects without specifying the exact class of object that will be created, providing a common interface for creating instances of classes that share a common superclass or interface?",
        "RightAnswer": "Factory Pattern",
        "WrongAnswers": [
            "Singleton Pattern",
            "Observer Pattern",
            "Decorator Pattern",
            "Strategy Pattern",
            "Proxy Pattern"
        ],
        "Explanation": "The Factory Pattern is a creational design pattern that provides an interface for creating objects without specifying their concrete classes. It works by defining a separate method or class (the factory) that handles the creation of objects based on certain parameters or conditions. This pattern promotes loose coupling by eliminating the need for client code to know the specific classes being instantiated. Instead, clients interact with the factory, which returns instances that conform to a known interface or base class. Factory Pattern is particularly useful when a system needs to be independent from how its products are created, composed, and represented, and when a class cannot anticipate the type of objects it must create. Common implementations include Simple Factory, Factory Method (where subclasses decide which class to instantiate), and Abstract Factory (which creates families of related objects). This pattern is widely used in frameworks and complex systems to manage object creation and enhance code maintainability.",
        "trans_Question": "wɒt dəzájn pǽtərn əláwz juw tə krijéjt ɒ́bdʒɛkts wɪðáwt spɛ́sɪfàjɪŋ ðə əɡzǽkt klǽs əv ɒ́bdʒəkt ðət wɪl bij krijéjtɪd, prəvájdɪŋ ə kɒ́mən ɪ́ntərfèjs fɔr krijéjtɪŋ ɪ́nstənsɪz əv klǽsɪz ðət ʃɛ́ər ə kɒ́mən súwpərklæ̀s ɔr ɪ́ntərfèjs?",
        "trans_RightAnswer": "fǽktərij pǽtərn",
        "trans_WrongAnswers": [
            "sɪ́ŋɡəltən pǽtərn",
            "əbzɜ́rvər pǽtərn",
            "dɛ́kərèjtər pǽtərn",
            "strǽtədʒij pǽtərn",
            "prɒ́ksij pǽtərn"
        ],
        "trans_Explanation": "ðə fǽktərij pǽtərn ɪz ə krijéjʃənəl dəzájn pǽtərn ðət prəvájdz ən ɪ́ntərfèjs fɔr krijéjtɪŋ ɒ́bdʒɛkts wɪðáwt spɛ́sɪfàjɪŋ ðɛər kɒ́nkrijt klǽsɪz. ɪt wɜ́rks baj dəfájnɪŋ ə sɛ́pərət mɛ́θəd ɔr klǽs (ðə fǽktərij) ðət hǽndəlz ðə krijéjʃən əv ɒ́bdʒɛkts béjst ɒn sɜ́rtən pərǽmətərz ɔr kəndɪ́ʃənz. ðɪs pǽtərn prəmówts lúws kʌ́plɪŋ baj əlɪ́mɪnèjtɪŋ ðə níjd fɔr klájənt kówd tə nów ðə spəsɪ́fɪk klǽsɪz bíjɪŋ ɪnstǽnʃijèjtɪd. ɪnstɛ́d, klájənts ɪ̀ntərǽkt wɪð ðə fǽktərij, wɪ́tʃ rətɜ́rnz ɪ́nstənsɪz ðət kənfɔ́rm tə ə nówn ɪ́ntərfèjs ɔr béjs klǽs. fǽktərij pǽtərn ɪz pərtɪ́kjələrlij júwsfəl wɛ́n ə sɪ́stəm níjdz tə bij ɪndəpɛ́ndənt frəm háw ɪts prɒ́dəkts ɑr krijéjtɪd, kəmpówzd, ənd rɛ̀prəzɛ́ntɪd, ənd wɛ́n ə klǽs kǽnɒt æntɪ́sɪpèjt ðə tájp əv ɒ́bdʒɛkts ɪt mʌst krijéjt. kɒ́mən ɪ̀mpləmɛntéjʃənz ɪnklúwd sɪ́mpəl fǽktərij, fǽktərij mɛ́θəd (wɛ́ər sʌ́bklæ̀sɪz dəsájd wɪ́tʃ klǽs tə ɪnstǽnʃijèjt), ənd ǽbstræ̀kt fǽktərij (wɪ́tʃ krijéjts fǽmɪlijz əv rəléjtɪd ɒ́bdʒɛkts). ðɪs pǽtərn ɪz wájdlij júwzd ɪn fréjmwɜ̀rks ənd kɒ́mplɛks sɪ́stəmz tə mǽnɪdʒ ɒ́bdʒəkt krijéjʃən ənd ənhǽns kówd mejntéjnəbɪ́lɪtij."
    },
    {
        "Question": "Which design pattern allows you to define a family of algorithms, encapsulate each one, and make them interchangeable at runtime?",
        "RightAnswer": "Strategy Pattern",
        "WrongAnswers": [
            "Observer Pattern",
            "Factory Pattern",
            "Singleton Pattern",
            "Decorator Pattern",
            "Adapter Pattern"
        ],
        "Explanation": "The Strategy Pattern is a behavioral design pattern that enables selecting an algorithm's implementation at runtime. It defines a family of algorithms, encapsulates each one, and makes them interchangeable. This pattern allows the algorithm to vary independently from clients that use it. For example, a navigation app might use different routing algorithms like fastest route, shortest route, or avoiding highways. With the Strategy Pattern, these algorithms can be swapped dynamically based on user preferences without changing the core navigation code. This promotes code that is more maintainable, extensible, and adheres to the open-closed principle by allowing new strategies to be added without modifying existing code.",
        "trans_Question": "wɪ́tʃ dəzájn pǽtərn əláwz juw tə dəfájn ə fǽmɪlij əv ǽlɡərɪ̀ðəmz, ɛnkǽpsəlèjt ijtʃ wʌ́n, ənd méjk ðɛm ɪ̀ntərtʃéjndʒəbəl æt rʌ́ntàjm?",
        "trans_RightAnswer": "strǽtədʒij pǽtərn",
        "trans_WrongAnswers": [
            "əbzɜ́rvər pǽtərn",
            "fǽktərij pǽtərn",
            "sɪ́ŋɡəltən pǽtərn",
            "dɛ́kərèjtər pǽtərn",
            "ədǽptər pǽtərn"
        ],
        "trans_Explanation": "ðə strǽtədʒij pǽtərn ɪz ə bijhéjvjərəl dəzájn pǽtərn ðət ɛnéjbəlz səlɛ́ktɪŋ ən ǽlɡərɪ̀ðəm'z ɪ̀mpləmɛntéjʃən æt rʌ́ntàjm. ɪt dəfájnz ə fǽmɪlij əv ǽlɡərɪ̀ðəmz, ɛnkǽpsjʊlejts ijtʃ wʌ́n, ənd méjks ðɛm ɪ̀ntərtʃéjndʒəbəl. ðɪs pǽtərn əláwz ðə ǽlɡərɪ̀ðəm tə vɛ́ərij ɪndəpɛ́ndəntlij frəm klájənts ðət juwz ɪt. fɔr əɡzǽmpəl, ə nǽvɪɡejʃən ǽp majt juwz dɪ́fərənt ráwtɪŋ ǽlɡərɪ̀ðəmz lájk fǽstəst ráwt, ʃɔ́rtəst ráwt, ɔr əvɔ́jdɪŋ hájwèjz. wɪð ðə strǽtədʒij pǽtərn, ðijz ǽlɡərɪ̀ðəmz kən bij swɒ́pt dajnǽmɪklìj béjst ɒn júwzər prɛ́fərənsɪz wɪðáwt tʃéjndʒɪŋ ðə kɔ́r nǽvɪɡejʃən kówd. ðɪs prəmówts kówd ðət ɪz mɔr mejntéjnəbəl, ɛ̀kstɛ́ndɪbəl, ənd ədhɪ́ərz tə ðə ówpən-klówzd prɪ́nsɪpəl baj əláwɪŋ núw strǽtədʒijz tə bij ǽdɪd wɪðáwt mɒ́dɪfàjɪŋ əɡzɪ́stɪŋ kówd."
    },
    {
        "Question": "Which software architectural pattern separates an application into three interconnected components to promote modularity, reusability, and easier maintenance?",
        "RightAnswer": "Model-View-Controller",
        "WrongAnswers": [
            "Client-Server-Database",
            "Input-Process-Output",
            "Frontend-Backend-Database",
            "Design-Develop-Deploy",
            "Domain-Interface-Logic"
        ],
        "Explanation": "Model-View-Controller (MVC) is a software architectural pattern that divides an application into three interconnected components, each with a specific responsibility. The Model manages the data, logic, and rules of the application, independent of the user interface. The View presents information to users through various display formats and interfaces. The Controller accepts input from users and converts it to commands for the Model or View. This separation of concerns makes applications more modular, easier to maintain, and facilitates parallel development by different team members. MVC has become fundamental in web development frameworks like Ruby on Rails, Django, and ASP.NET MVC, as it allows developers to work on different aspects of an application without interfering with other components. The pattern promotes code reusability and provides a clear structure for organizing complex applications.",
        "trans_Question": "wɪ́tʃ sɔ́ftwɛ̀ər ɑ̀rkɪtɛ́ktʃərəl pǽtərn sɛ́pərèjts ən æ̀plɪkéjʃən ɪntə θríj ɪ̀ntərkənɛ́ktɪd kəmpównənts tə prəmówt mɒ́djəlǽrɪtij, rìjùwzəbɪ́lɪtij, ənd íjzijər méjntənəns?",
        "trans_RightAnswer": "mɒ́dəl-vjúw-kəntrówlər",
        "trans_WrongAnswers": [
            "klájənt-sɜ́rvər-déjtəbèjs",
            "ɪ́npʊ̀t-prɒ́sɛs-áwtpʊ̀t",
            "frʌntɛ́nd-bæ̀kɛ́nd-déjtəbèjs",
            "dəzájn-dəvɛ́ləp-dəplɔ́j",
            "dowméjn-ɪ́ntərfèjs-lɒ́dʒɪk"
        ],
        "trans_Explanation": "mɒ́dəl-vjúw-kəntrówlər (MVC) ɪz ə sɔ́ftwɛ̀ər ɑ̀rkɪtɛ́ktʃərəl pǽtərn ðət dɪvájdz ən æ̀plɪkéjʃən ɪntə θríj ɪ̀ntərkənɛ́ktɪd kəmpównənts, ijtʃ wɪð ə spəsɪ́fɪk rəspɒ̀nsɪbɪ́lɪtij. ðə mɒ́dəl mǽnɪdʒɪz ðə déjtə, lɒ́dʒɪk, ənd rúwlz əv ðə æ̀plɪkéjʃən, ɪndəpɛ́ndənt əv ðə júwzər ɪ́ntərfèjs. ðə vjúw prɛ́zənts ɪnfərméjʃən tə júwzərz θrúw vɛ́ərijəs dɪspléj fɔ́rmæ̀ts ənd ɪ́ntərfèjsɪz. ðə kəntrówlər æksɛ́pts ɪ́npʊ̀t frəm júwzərz ənd kɒ́nvərts ɪt tə kəmǽndz fɔr ðə mɒ́dəl ɔr vjúw. ðɪs sɛ̀pərèjʃən əv kənsɜ́rnz méjks æ̀plɪkéjʃənz mɔr mɒ́dʒələr, íjzijər tə mejntéjn, ənd fəsɪ́lətèjts pǽrəlɛ̀l dəvɛ́ləpmənt baj dɪ́fərənt tíjm mɛ́mbərz. MVC həz bəkʌ́m fʌ̀ndəmɛ́ntəl ɪn wɛ́b dəvɛ́ləpmənt fréjmwɜ̀rks lájk rúwbij ɒn réjlz, dʒǽŋɡow, ənd ASP.NET MVC, æz ɪt əláwz dəvɛ́ləpərz tə wɜ́rk ɒn dɪ́fərənt ǽspɛkts əv ən æ̀plɪkéjʃən wɪðáwt ɪ̀ntəfɪ́ərɪŋ wɪð ʌ́ðər kəmpównənts. ðə pǽtərn prəmówts kówd rìjùwzəbɪ́lɪtij ənd prəvájdz ə klɪ́ər strʌ́ktʃər fɔr ɔ́rɡənàjzɪŋ kɒ́mplɛks æ̀plɪkéjʃənz."
    },
    {
        "Question": "What architectural approach involves breaking down a large application into small, independent services that communicate over a network and can be deployed separately?",
        "RightAnswer": "Microservices",
        "WrongAnswers": [
            "Monolithic Architecture",
            "Service-Oriented Middleware",
            "Containerization",
            "Virtual Machines",
            "Distributed Computing"
        ],
        "Explanation": "Microservices is an architectural style that structures an application as a collection of small, loosely coupled services, each focused on doing one thing well. Unlike traditional monolithic applications where all functionality exists in a single codebase, microservices break these functions into separate, independently deployable services that communicate with each other through well-defined APIs. Each microservice can be developed, scaled, and maintained separately, often by different teams using different technologies. This approach offers benefits such as improved scalability, faster development cycles, and greater resilience, as failures in one service don't necessarily affect others. However, it also introduces complexity in terms of service discovery, communication, and data consistency. Companies like Netflix, Amazon, and Spotify have famously adopted microservices to handle their large-scale, complex applications while maintaining agility and reliability.",
        "trans_Question": "wɒt ɑ̀rkɪtɛ́ktʃərəl əprówtʃ ɪnvɒ́lvz bréjkɪŋ dawn ə lɑ́rdʒ æ̀plɪkéjʃən ɪntə smɔ́l, ɪndəpɛ́ndənt sɜ́rvɪsɪz ðət kəmjúwnɪkèjt ówvər ə nɛ́twɜ̀rk ənd kən bij dəplɔ́jd sɛ́pərətlij?",
        "trans_RightAnswer": "májkrowsɜ́rvɪsɪz",
        "trans_WrongAnswers": [
            "mɒ̀nəlɪ́θɪk ɑ́rkɪtɛ̀ktʃər",
            "sɜ́rvɪs-ɔ́rijɛ̀ntɪd mɪ́dəlwɛər",
            "kəntéjnəràjzɪzéjʃən",
            "vɜ́rtʃuwəl məʃíjnz",
            "dɪstrɪ́bjətɪd kəmpjúwtɪŋ"
        ],
        "trans_Explanation": "májkrowsɜ́rvɪsɪz ɪz ən ɑ̀rkɪtɛ́ktʃərəl stájl ðət strʌ́ktʃərz ən æ̀plɪkéjʃən æz ə kəlɛ́kʃən əv smɔ́l, lúwslij kʌ́pəld sɜ́rvɪsɪz, ijtʃ fówkəst ɒn dúwɪŋ wʌ́n θɪ́ŋ wɛ́l. ʌ̀nlájk trədɪ́ʃənəl mɒ̀nəlɪ́θɪk æ̀plɪkéjʃənz wɛ́ər ɔl fʌ̀ŋkʃənǽlɪtij əɡzɪ́sts ɪn ə sɪ́ŋɡəl kówdbèjs, májkrowsɜ́rvɪsɪz bréjk ðijz fʌ́ŋkʃənz ɪntə sɛ́pərət, ɪndəpɛ́ndəntlij dəplɔ́jəbəl sɜ́rvɪsɪz ðət kəmjúwnɪkèjt wɪð ijtʃ ʌ́ðər θrúw wɛ́l-dəfájnd APIz. ijtʃ májkrowsɜ̀rvɪs kən bij dəvɛ́ləpt, skéjld, ənd mejntéjnd sɛ́pərətlij, ɔ́fən baj dɪ́fərənt tíjmz júwzɪŋ dɪ́fərənt tɛknɒ́lədʒijz. ðɪs əprówtʃ ɔ́fərz bɛ́nəfɪts sʌtʃ æz ɪmprúwvd skéjləbɪ́lɪtij, fǽstər dəvɛ́ləpmənt sájkəlz, ənd ɡréjtər rəzɪ́lijəns, æz féjljərz ɪn wʌ́n sɜ́rvɪs dównt nɛ̀səsɛ́ərɪlij əfɛ́kt ʌ́ðərz. hàwɛ́vər, ɪt ɔ́lsow ɪntrədúwsɪz kəmplɛ́ksɪtij ɪn tɜ́rmz əv sɜ́rvɪs dɪ̀skʌ́vrij, kəmjùwnɪkéjʃən, ənd déjtə kənsɪ́stənsij. kʌ́mpənìjz lájk nɛ́tflɪks, əmǽzɒn, ənd spɔ́tɪfàj həv féjməslij ədɒ́ptɪd májkrowsɜ́rvɪsɪz tə hǽndəl ðɛər lɑ́rdʒ-skéjl, kɒ́mplɛks æ̀plɪkéjʃənz wájl mejntéjnɪŋ ədʒɪ́lɪtij ənd rəlàjəbɪ́lɪtij."
    },
    {
        "Question": "What is the name of the architectural style that uses HTTP methods like GET, POST, PUT, and DELETE to perform operations on resources, typically returning data in formats like JSON or XML?",
        "RightAnswer": "RESTful API",
        "WrongAnswers": [
            "SOAP Protocol",
            "GraphQL Interface",
            "Socket Connection",
            "RPC Framework",
            "WebSocket Service"
        ],
        "Explanation": "A RESTful API (Representational State Transfer Application Programming Interface) is an architectural style for designing networked applications. It relies on stateless, client-server communication, using standard HTTP methods to perform operations on resources. In RESTful design, resources are identified by URLs, and operations are performed using standard HTTP methods: GET to retrieve data, POST to create new resources, PUT to update existing ones, and DELETE to remove resources. RESTful APIs typically transfer data in lightweight formats like JSON or XML, making them ideal for web services and mobile applications. They are widely adopted because they are scalable, simple to understand, and leverage existing web infrastructure. Unlike more complex protocols, RESTful APIs don't require special client libraries, making them accessible across different platforms and programming languages.",
        "trans_Question": "wɒt ɪz ðə néjm əv ðə ɑ̀rkɪtɛ́ktʃərəl stájl ðət júwsɪz HTTP mɛ́θədz lájk GET, POST, PUT, ənd DELETE tə pərfɔ́rm ɒ̀pəréjʃənz ɒn ríjsɔrsɪz, tɪ́pɪkəlij rətɜ́rnɪŋ déjtə ɪn fɔ́rmæ̀ts lájk JSON ɔr XML?",
        "trans_RightAnswer": "rɛ́stfəl API",
        "trans_WrongAnswers": [
            "SOAP prówtəkɒ̀l",
            "ɡrǽfkwɛ̀l ɪ́ntərfèjs",
            "sɒ́kət kənɛ́kʃən",
            "RPC fréjmwɜ̀rk",
            "wɛ́bsɒ̀kɪt sɜ́rvɪs"
        ],
        "trans_Explanation": "ə rɛ́stfəl API (rɛ̀prəzəntéjʃənəl stéjt trǽnsfər æ̀plɪkéjʃən prówɡræ̀mɪŋ ɪ́ntərfèjs) ɪz ən ɑ̀rkɪtɛ́ktʃərəl stájl fɔr dəzájnɪŋ nɛ́twɜ̀rkt æ̀plɪkéjʃənz. ɪt rəlájz ɒn stéjtləs, klájənt-sɜ́rvər kəmjùwnɪkéjʃən, júwzɪŋ stǽndərd HTTP mɛ́θədz tə pərfɔ́rm ɒ̀pəréjʃənz ɒn ríjsɔrsɪz. ɪn rɛ́stfəl dəzájn, ríjsɔrsɪz ɑr ajdɛ́ntɪfàjd baj júwɑ́rɛ́lz, ənd ɒ̀pəréjʃənz ɑr pərfɔ́rmd júwzɪŋ stǽndərd HTTP mɛ́θədz: GET tə rətríjv déjtə, POST tə krijéjt núw ríjsɔrsɪz, PUT tə əpdéjt əɡzɪ́stɪŋ wʌ́nz, ənd DELETE tə rijmúwv ríjsɔrsɪz. rɛ́stfəl APIz tɪ́pɪkəlij trǽnsfər déjtə ɪn lájtwéjt fɔ́rmæ̀ts lájk JSON ɔr XML, méjkɪŋ ðɛm ajdíjəl fɔr wɛ́b sɜ́rvɪsɪz ənd mówbajl æ̀plɪkéjʃənz. ðej ɑr wájdlij ədɒ́ptɪd bəkɒ́z ðej ɑr skéjləbəl, sɪ́mpəl tə ʌ̀ndərstǽnd, ənd lɛ́vərɪdʒ əɡzɪ́stɪŋ wɛ́b ɪnfrəstrʌ́ktʃər. ʌ̀nlájk mɔr kɒ́mplɛks prówtəkɔ̀lz, rɛ́stfəl APIz dównt rəkwájər spɛ́ʃəl klájənt lájbrɛərìjz, méjkɪŋ ðɛm æksɛ́sɪbəl əkrɔ́s dɪ́fərənt plǽtfɔ̀rmz ənd prówɡræ̀mɪŋ lǽŋɡwədʒɪz."
    },
    {
        "Question": "Developed by Facebook in 2015, which query language allows clients to request exactly the data they need in a single request, reducing over-fetching and under-fetching problems common in traditional REST APIs?",
        "RightAnswer": "GraphQL",
        "WrongAnswers": [
            "RESTify",
            "QueryScript",
            "NodeFetch",
            "JSONPath",
            "FetchAPI"
        ],
        "Explanation": "GraphQL is a query language and runtime for APIs developed by Facebook in 2015. Unlike traditional REST APIs where clients receive fixed data structures from multiple endpoints, GraphQL allows clients to specify exactly what data they need in a single request. It works through a schema that defines available data types and relationships, enabling clients to traverse these relationships and retrieve precisely the information required. This approach solves common REST challenges including over-fetching (receiving more data than needed) and under-fetching (requiring multiple requests to get complete data). GraphQL is language-agnostic and has become increasingly popular for building efficient, flexible APIs for web and mobile applications, with implementations available across numerous programming languages and frameworks.",
        "trans_Question": "dəvɛ́ləpt baj féjsbʊ̀k ɪn 2015, wɪ́tʃ kwɛ́ərij lǽŋɡwədʒ əláwz klájənts tə rəkwɛ́st əɡzǽktlij ðə déjtə ðej níjd ɪn ə sɪ́ŋɡəl rəkwɛ́st, rədjúwsɪŋ ówvər-fɛ́tʃɪŋ ənd ʌ́ndər-fɛ́tʃɪŋ prɒ́bləmz kɒ́mən ɪn trədɪ́ʃənəl REST APIz?",
        "trans_RightAnswer": "ɡrǽfkwɛ̀l",
        "trans_WrongAnswers": [
            "rɛ́stɪfaj",
            "kwɛ́ərɪskrɪpt",
            "nówd",
            "dʒéjsənpæθ",
            "fɛtʃéjpij"
        ],
        "trans_Explanation": "ɡrǽfkwɛ̀l ɪz ə kwɛ́ərij lǽŋɡwədʒ ənd rʌ́ntàjm fɔr APIz dəvɛ́ləpt baj féjsbʊ̀k ɪn 2015. ʌ̀nlájk trədɪ́ʃənəl REST APIz wɛ́ər klájənts rəsíjv fɪ́kst déjtə strʌ́ktʃərz frəm mʌ́ltɪpəl ɛ́ndpɔ̀jnts, ɡrǽfkwɛ̀l əláwz klájənts tə spɛ́sɪfàj əɡzǽktlij wɒt déjtə ðej níjd ɪn ə sɪ́ŋɡəl rəkwɛ́st. ɪt wɜ́rks θrúw ə skíjmə ðət dəfájnz əvéjləbəl déjtə tájps ənd rəléjʃənʃɪ̀ps, ɛnéjbəlɪŋ klájənts tə trǽvərs ðijz rəléjʃənʃɪ̀ps ənd rətríjv prəsájslij ðə ɪnfərméjʃən rəkwájərd. ðɪs əprówtʃ sɒ́lvz kɒ́mən REST tʃǽləndʒɪz ɪnklúwdɪŋ ówvər-fɛ́tʃɪŋ (rəsíjvɪŋ mɔr déjtə ðʌn níjdɪd) ənd ʌ́ndər-fɛ́tʃɪŋ (rijkwájərɪŋ mʌ́ltɪpəl rəkwɛ́s tə ɡɛt kəmplíjt déjtə). ɡrǽfkwɛ̀l ɪz lǽŋɡwədʒ-æɡnɒ́stɪk ənd həz bəkʌ́m ɪnkríjsɪŋɡlij pɒ́pjələr fɔr bɪ́ldɪŋ əfɪ́ʃənt, flɛ́ksɪbəl APIz fɔr wɛ́b ənd mówbajl æ̀plɪkéjʃənz, wɪð ɪ̀mpləmɛntéjʃənz əvéjləbəl əkrɔ́s njúwmərəs prówɡræ̀mɪŋ lǽŋɡwədʒɪz ənd fréjmwɜ̀rks."
    },
    {
        "Question": "Which architectural pattern focuses on organizing software as a collection of loosely coupled, interoperable services that communicate over a network using standardized protocols?",
        "RightAnswer": "Service-Oriented Architecture",
        "WrongAnswers": [
            "Monolithic Architecture",
            "Event-Driven Architecture",
            "Microkernel Architecture",
            "Pipe and Filter Architecture",
            "Layered Architecture"
        ],
        "Explanation": "Service-Oriented Architecture is an architectural approach where software is designed as a collection of distinct services that perform specific business functions and can be accessed across different systems and platforms. These services communicate with each other through standardized protocols like SOAP or REST over a network, allowing them to be loosely coupled and independently deployable. This approach enhances reusability, scalability, and interoperability in complex systems. Unlike monolithic designs where all components are tightly integrated, SOA promotes modularity by breaking functionality into separate, self-contained services that can be developed, maintained, and upgraded independently. Organizations adopt SOA to create more flexible systems that can adapt to changing business requirements while enabling services to be shared across multiple applications and potentially even with external partners.",
        "trans_Question": "wɪ́tʃ ɑ̀rkɪtɛ́ktʃərəl pǽtərn fówkəsɪz ɒn ɔ́rɡənàjzɪŋ sɔ́ftwɛ̀ər æz ə kəlɛ́kʃən əv lúwslij kʌ́pəld, ɪ̀ntərɒ́pərəbl sɜ́rvɪsɪz ðət kəmjúwnɪkèjt ówvər ə nɛ́twɜ̀rk júwzɪŋ stǽndərdàjzd prówtəkɔ̀lz?",
        "trans_RightAnswer": "sɜ́rvɪs-ɔ́rijɛ̀ntɪd ɑ́rkɪtɛ̀ktʃər",
        "trans_WrongAnswers": [
            "mɒ̀nəlɪ́θɪk ɑ́rkɪtɛ̀ktʃər",
            "əvɛ́nt-drɪ́vən ɑ́rkɪtɛ̀ktʃər",
            "májkrowkɜ̀rnəl ɑ́rkɪtɛ̀ktʃər",
            "pájp ənd fɪ́ltər ɑ́rkɪtɛ̀ktʃər",
            "léjərd ɑ́rkɪtɛ̀ktʃər"
        ],
        "trans_Explanation": "sɜ́rvɪs-ɔ́rijɛ̀ntɪd ɑ́rkɪtɛ̀ktʃər ɪz ən ɑ̀rkɪtɛ́ktʃərəl əprówtʃ wɛ́ər sɔ́ftwɛ̀ər ɪz dəzájnd æz ə kəlɛ́kʃən əv dɪstɪ́ŋkt sɜ́rvɪsɪz ðət pərfɔ́rm spəsɪ́fɪk bɪ́znəs fʌ́ŋkʃənz ənd kən bij ǽksɛ̀st əkrɔ́s dɪ́fərənt sɪ́stəmz ənd plǽtfɔ̀rmz. ðijz sɜ́rvɪsɪz kəmjúwnɪkèjt wɪð ijtʃ ʌ́ðər θrúw stǽndərdàjzd prówtəkɔ̀lz lájk SOAP ɔr REST ówvər ə nɛ́twɜ̀rk, əláwɪŋ ðɛm tə bij lúwslij kʌ́pəld ənd ɪndəpɛ́ndəntlij dəplɔ́jəbəl. ðɪs əprówtʃ ənhǽnsɪz rìjùwzəbɪ́lɪtij, skéjləbɪ́lɪtij, ənd ɪ̀ntərɔ́pərəbɪ́lɪtij ɪn kɒ́mplɛks sɪ́stəmz. ʌ̀nlájk mɒ̀nəlɪ́θɪk dəzájnz wɛ́ər ɔl kəmpównənts ɑr tájtlij ɪ́ntəɡrejtɪd, SOA prəmówts mɒ́djəlǽrɪtij baj bréjkɪŋ fʌ̀ŋkʃənǽlɪtij ɪntə sɛ́pərət, sɛ́lf-kəntéjnd sɜ́rvɪsɪz ðət kən bij dəvɛ́ləpt, mejntéjnd, ənd ʌ́pɡrèjdɪd ɪndəpɛ́ndəntlij. ɔ̀rɡənɪzéjʃənz ədɒ́pt SOA tə krijéjt mɔr flɛ́ksɪbəl sɪ́stəmz ðət kən ədǽpt tə tʃéjndʒɪŋ bɪ́znəs rəkwájərmənts wájl ɛnéjbəlɪŋ sɜ́rvɪsɪz tə bij ʃɛ́ərd əkrɔ́s mʌ́ltɪpəl æ̀plɪkéjʃənz ənd pətɛ́nʃəlij íjvən wɪð əkstɜ́rnəl pɑ́rtnərz."
    },
    {
        "Question": "Which architectural pattern is characterized by software components producing, detecting, consuming, and reacting to events asynchronously, allowing for loose coupling and high scalability?",
        "RightAnswer": "Event-Driven Architecture",
        "WrongAnswers": [
            "Monolithic Architecture",
            "Layered Architecture",
            "Microkernel Architecture",
            "Client-Server Architecture",
            "Repository Architecture"
        ],
        "Explanation": "Event-Driven Architecture is a software design approach where the flow of the application is determined by events such as user actions, sensor outputs, or messages from other programs. In this architecture, events are produced by event emitters, processed through event channels, and consumed by event handlers that execute appropriate responses. This pattern enables systems to be highly decoupled, as components don't need direct knowledge of each other, they simply react to events they're interested in. Event-Driven Architecture excels in scenarios requiring real-time processing, scalability, and flexibility, making it particularly valuable in distributed systems, IoT applications, and modern web services. The asynchronous nature of this architecture allows systems to handle high volumes of concurrent operations efficiently, as components can process events independently without blocking one another.",
        "trans_Question": "wɪ́tʃ ɑ̀rkɪtɛ́ktʃərəl pǽtərn ɪz kǽrəktərajzd baj sɔ́ftwɛ̀ər kəmpównənts prədúwsɪŋ, dətɛ́ktɪŋ, kənsúwmɪŋ, ənd rijǽktɪŋ tə əvɛ́nts éjsɪ́ŋkrənəslij, əláwɪŋ fɔr lúws kʌ́plɪŋ ənd háj skéjləbɪ́lɪtij?",
        "trans_RightAnswer": "əvɛ́nt-drɪ́vən ɑ́rkɪtɛ̀ktʃər",
        "trans_WrongAnswers": [
            "mɒ̀nəlɪ́θɪk ɑ́rkɪtɛ̀ktʃər",
            "léjərd ɑ́rkɪtɛ̀ktʃər",
            "májkrowkɜ̀rnəl ɑ́rkɪtɛ̀ktʃər",
            "klájənt-sɜ́rvər ɑ́rkɪtɛ̀ktʃər",
            "rijpɒ́zɪtɔ̀rij ɑ́rkɪtɛ̀ktʃər"
        ],
        "trans_Explanation": "əvɛ́nt-drɪ́vən ɑ́rkɪtɛ̀ktʃər ɪz ə sɔ́ftwɛ̀ər dəzájn əprówtʃ wɛ́ər ðə flów əv ðə æ̀plɪkéjʃən ɪz dətɜ́rmɪnd baj əvɛ́nts sʌtʃ æz júwzər ǽkʃənz, sɛ́nsər áwtpʊ̀ts, ɔr mɛ́sɪdʒɪz frəm ʌ́ðər prówɡræ̀mz. ɪn ðɪs ɑ́rkɪtɛ̀ktʃər, əvɛ́nts ɑr prədúwst baj əvɛ́nt ɪmɪ́tərz, prɒ́sɛst θrúw əvɛ́nt tʃǽnəlz, ənd kənsúwmd baj əvɛ́nt hǽndələrz ðət ɛ́ksəkjùwt əprówprijèjt rəspɒ́nsɪz. ðɪs pǽtərn ɛnéjbəlz sɪ́stəmz tə bij hájlij dijkʌ́pəld, æz kəmpównənts dównt níjd dɪərɛ́kt nɒ́lɪdʒ əv ijtʃ ʌ́ðər, ðej sɪ́mplij rijǽkt tə əvɛ́nts ðɛ́ər ɪ́ntərəstɪd ɪn. əvɛ́nt-drɪ́vən ɑ́rkɪtɛ̀ktʃər əksɛ́lz ɪn sənɛ́ərijowz rijkwájərɪŋ ríjəl-tájm prɒ́sɛsɪŋ, skéjləbɪ́lɪtij, ənd flɛ̀ksɪbɪ́lɪtij, méjkɪŋ ɪt pərtɪ́kjələrlij vǽljəbəl ɪn dɪstrɪ́bjətɪd sɪ́stəmz, ijot æ̀plɪkéjʃənz, ənd mɒ́dərn wɛ́b sɜ́rvɪsɪz. ðə éjsɪ́ŋkrənəs néjtʃər əv ðɪs ɑ́rkɪtɛ̀ktʃər əláwz sɪ́stəmz tə hǽndəl háj vɒ́ljuwmz əv kənkɜ́rənt ɒ̀pəréjʃənz əfɪ́ʃəntlij, æz kəmpównənts kən prɒ́sɛs əvɛ́nts ɪndəpɛ́ndəntlij wɪðáwt blɒ́kɪŋ wʌ́n ənʌ́ðər."
    },
    {
        "Question": "What is the term for software that acts as a bridge between an operating system and applications, providing common services and capabilities such as authentication, data management, and messaging across distributed systems?",
        "RightAnswer": "Middleware",
        "WrongAnswers": [
            "Frontend",
            "Firmware",
            "Kernel",
            "Hypervisor",
            "Runtime Environment"
        ],
        "Explanation": "Middleware is specialized software that functions as an intermediary layer between the operating system and the applications running on it. Think of it as the 'glue' or 'bridge' that connects different software components, allowing them to communicate and share data. Middleware abstracts the complexities of underlying systems, providing standardized services such as authentication, authorization, messaging, and data management across distributed computer environments. For example, when you use a web application that needs to access databases on multiple servers, middleware handles the communication protocols, data transformations, and security checks. Common examples include application servers, message brokers, API management platforms, and enterprise service buses. Middleware is particularly crucial in enterprise systems where different applications, potentially built using different technologies, need to work together seamlessly.",
        "trans_Question": "wɒt ɪz ðə tɜ́rm fɔr sɔ́ftwɛ̀ər ðət ǽkts æz ə brɪ́dʒ bijtwíjn ən ɒ́pərèjtɪŋ sɪ́stəm ənd æ̀plɪkéjʃənz, prəvájdɪŋ kɒ́mən sɜ́rvɪsɪz ənd kèjpəbɪ́lɪtijz sʌtʃ æz ɔθɛ̀ntɪkéjʃən, déjtə mǽnədʒmənt, ənd mɛ́sɪdʒɪŋ əkrɔ́s dɪstrɪ́bjətɪd sɪ́stəmz?",
        "trans_RightAnswer": "mɪ́dəlwɛər",
        "trans_WrongAnswers": [
            "frʌntɛ́nd",
            "fɜ́rmwɛ̀ər",
            "kɜ́rnəl",
            "hajpɜ́rvajzər",
            "rʌ́ntàjm ənvájərənmənt"
        ],
        "trans_Explanation": "mɪ́dəlwɛər ɪz spɛ́ʃəlàjzd sɔ́ftwɛ̀ər ðət fʌ́ŋkʃənz æz ən ɪ̀ntərmíjdijɛərij léjər bijtwíjn ðə ɒ́pərèjtɪŋ sɪ́stəm ənd ðə æ̀plɪkéjʃənz rʌ́nɪŋ ɒn ɪt. θɪ́ŋk əv ɪt æz ðə 'ɡlúw' ɔr 'brɪ́dʒ' ðət kənɛ́kts dɪ́fərənt sɔ́ftwɛ̀ər kəmpównənts, əláwɪŋ ðɛm tə kəmjúwnɪkèjt ənd ʃɛ́ər déjtə. mɪ́dəlwɛər ǽbstrækts ðə kəmplɛ́ksɪtijz əv ʌ̀ndərlájɪŋ sɪ́stəmz, prəvájdɪŋ stǽndərdàjzd sɜ́rvɪsɪz sʌtʃ æz ɔθɛ̀ntɪkéjʃən, ɔ̀θərɪzéjʃən, mɛ́sɪdʒɪŋ, ənd déjtə mǽnədʒmənt əkrɔ́s dɪstrɪ́bjətɪd kəmpjúwtər ənvájərənmənts. fɔr əɡzǽmpəl, wɛ́n juw juwz ə wɛ́b æ̀plɪkéjʃən ðət níjdz tə ǽksɛ̀s déjtəbèjsɪz ɒn mʌ́ltɪpəl sɜ́rvərz, mɪ́dəlwɛər hǽndəlz ðə kəmjùwnɪkéjʃən prówtəkɔ̀lz, déjtə træ̀nsfərméjʃənz, ənd səkjʊ́rɪtij tʃɛ́ks. kɒ́mən əɡzǽmpəlz ɪnklúwd æ̀plɪkéjʃən sɜ́rvərz, mɛ́sɪdʒ brówkərz, API mǽnədʒmənt plǽtfɔ̀rmz, ənd ɛ́ntərpràjz sɜ́rvɪs bʌ́sɪz. mɪ́dəlwɛər ɪz pərtɪ́kjələrlij krúwʃəl ɪn ɛ́ntərpràjz sɪ́stəmz wɛ́ər dɪ́fərənt æ̀plɪkéjʃənz, pətɛ́nʃəlij bɪ́lt júwzɪŋ dɪ́fərənt tɛknɒ́lədʒijz, níjd tə wɜ́rk təɡɛ́ðər síjmləslij."
    },
    {
        "Question": "What is the process of converting complex data structures or objects into a format that can be stored or transmitted and later reconstructed in the same or another environment?",
        "RightAnswer": "Serialization",
        "WrongAnswers": [
            "Encapsulation",
            "Abstraction",
            "Normalization",
            "Tokenization",
            "Virtualization"
        ],
        "Explanation": "Serialization is a fundamental concept in computer science that involves converting complex data structures or objects into a linear sequence of bytes that can be easily stored in a file, transmitted across a network, or saved in a database. Think of it as transforming a three-dimensional object into a flat blueprint that contains all the information needed to rebuild the original object later. When you need to use the data again, the reverse process called deserialization converts this linear representation back into its original complex form. Programming languages typically provide built-in mechanisms for serialization, supporting various formats like JSON, XML, or binary. Serialization is essential for data persistence, distributed computing, and any scenario where data needs to move between different parts of a system or between systems. It serves as a bridge that allows complex information to travel across different environments while maintaining its integrity and structure.",
        "trans_Question": "wɒt ɪz ðə prɒ́sɛs əv kənvɜ́rtɪŋ kɒ́mplɛks déjtə strʌ́ktʃərz ɔr ɒ́bdʒɛkts ɪntə ə fɔ́rmæ̀t ðət kən bij stɔ́rd ɔr trænsmɪ́tɪd ənd léjtər rìjkənstrʌ́ktɪd ɪn ðə séjm ɔr ənʌ́ðər ənvájərənmənt?",
        "trans_RightAnswer": "sɪ̀ərìjəlɪzéjʃən",
        "trans_WrongAnswers": [
            "ɛnkǽpsəlèjʃən",
            "æbstrǽkʃən",
            "nɔ̀rməlɪzéjʃən",
            "tòwkənəzéjʃən",
            "vɜ̀rtʃuwəlɪzéjʃən"
        ],
        "trans_Explanation": "sɪ̀ərìjəlɪzéjʃən ɪz ə fʌ̀ndəmɛ́ntəl kɒ́nsɛpt ɪn kəmpjúwtər sájəns ðət ɪnvɒ́lvz kənvɜ́rtɪŋ kɒ́mplɛks déjtə strʌ́ktʃərz ɔr ɒ́bdʒɛkts ɪntə ə lɪ́nijər síjkwəns əv bájts ðət kən bij íjzəlij stɔ́rd ɪn ə fájl, trænsmɪ́tɪd əkrɔ́s ə nɛ́twɜ̀rk, ɔr séjvd ɪn ə déjtəbèjs. θɪ́ŋk əv ɪt æz trænsfɔ́rmɪŋ ə θríj-dajmɛ́nʃənəl ɒ́bdʒəkt ɪntə ə flǽt blúwprɪ̀nt ðət kəntéjnz ɔl ðə ɪnfərméjʃən níjdɪd tə rijbɪ́ld ðə ərɪ́dʒɪnəl ɒ́bdʒəkt léjtər. wɛ́n juw níjd tə juwz ðə déjtə əɡéjn, ðə rijvɜ́rs prɒ́sɛs kɔ́ld dìjsɪərijəlajzéjʃən kɒ́nvərts ðɪs lɪ́nijər rɛ̀prəzɛntéjʃən bǽk ɪntə ɪts ərɪ́dʒɪnəl kɒ́mplɛks fɔ́rm. prówɡræ̀mɪŋ lǽŋɡwədʒɪz tɪ́pɪkəlij prəvájd bɪ́lt-ɪn mɛ́kənɪzəmz fɔr sɪ̀ərìjəlɪzéjʃən, səpɔ́rtɪŋ vɛ́ərijəs fɔ́rmæ̀ts lájk JSON, XML, ɔr bájnərij. sɪ̀ərìjəlɪzéjʃən ɪz əsɛ́nʃəl fɔr déjtə pərsɪ́stəns, dɪstrɪ́bjətɪd kəmpjúwtɪŋ, ənd ɛ́nij sənɛ́ərijow wɛ́ər déjtə níjdz tə múwv bijtwíjn dɪ́fərənt pɑ́rts əv ə sɪ́stəm ɔr bijtwíjn sɪ́stəmz. ɪt sɜ́rvz æz ə brɪ́dʒ ðət əláwz kɒ́mplɛks ɪnfərméjʃən tə trǽvəl əkrɔ́s dɪ́fərənt ənvájərənmənts wájl mejntéjnɪŋ ɪts ɪntɛ́ɡrɪtij ənd strʌ́ktʃər."
    },
    {
        "Question": "In computer science, what is the technical term for the process of converting stored binary data back into a usable program object or data structure?",
        "RightAnswer": "Deserialization",
        "WrongAnswers": [
            "Binary Extraction",
            "Object Encoding",
            "Memory Mapping",
            "Data Decryption",
            "Type Casting"
        ],
        "Explanation": "Deserialization is the process of reconstructing data structures or objects from a stored format, typically from a binary stream or text format like JSON or XML. It is essentially the reverse of serialization. When applications need to transmit data across networks or store it persistently, they first convert complex objects into a format suitable for storage or transmission through serialization. Later, when the application needs to use that data again, deserialization converts that stored representation back into memory-resident objects that the application can manipulate. This process is fundamental in distributed computing, web services, and file systems. However, it can also present security risks if not properly implemented, as malicious data might be deserialized into harmful code, leading to potential vulnerabilities known as deserialization attacks.",
        "trans_Question": "ɪn kəmpjúwtər sájəns, wɒt ɪz ðə tɛ́knɪkəl tɜ́rm fɔr ðə prɒ́sɛs əv kənvɜ́rtɪŋ stɔ́rd bájnərij déjtə bǽk ɪntə ə júwzəbəl prówɡræ̀m ɒ́bdʒəkt ɔr déjtə strʌ́ktʃər?",
        "trans_RightAnswer": "dìjsɪərijəlajzéjʃən",
        "trans_WrongAnswers": [
            "bájnərij əkstrǽkʃən",
            "ɒ́bdʒəkt ɛnkówdɪŋ",
            "mɛ́mərij mǽpɪŋ",
            "déjtə dəkrɪ́pʃən",
            "tájp kǽstɪŋ"
        ],
        "trans_Explanation": "dìjsɪərijəlajzéjʃən ɪz ðə prɒ́sɛs əv rìjkənstrʌ́ktɪŋ déjtə strʌ́ktʃərz ɔr ɒ́bdʒɛkts frəm ə stɔ́rd fɔ́rmæ̀t, tɪ́pɪkəlij frəm ə bájnərij stríjm ɔr tɛ́kst fɔ́rmæ̀t lájk JSON ɔr XML. ɪt ɪz əsɛ́nʃəlij ðə rijvɜ́rs əv sɪ̀ərìjəlɪzéjʃən. wɛ́n æ̀plɪkéjʃənz níjd tə trænzmɪ́t déjtə əkrɔ́s nɛ́twɜ̀rks ɔr stɔ́r ɪt pərsɪ́stəntlij, ðej fɜ́rst kɒ́nvɜrt kɒ́mplɛks ɒ́bdʒɛkts ɪntə ə fɔ́rmæ̀t súwtəbəl fɔr stɔ́rɪdʒ ɔr trænsmɪ́ʃən θrúw sɪ̀ərìjəlɪzéjʃən. léjtər, wɛ́n ðə æ̀plɪkéjʃən níjdz tə juwz ðət déjtə əɡéjn, dìjsɪərijəlajzéjʃən kɒ́nvərts ðət stɔ́rd rɛ̀prəzɛntéjʃən bǽk ɪntə mɛ́mərij-rɛ́zɪdənt ɒ́bdʒɛkts ðət ðə æ̀plɪkéjʃən kən mənɪ́pjəlèjt. ðɪs prɒ́sɛs ɪz fʌ̀ndəmɛ́ntəl ɪn dɪstrɪ́bjətɪd kəmpjúwtɪŋ, wɛ́b sɜ́rvɪsɪz, ənd fájl sɪ́stəmz. hàwɛ́vər, ɪt kən ɔ́lsow prɛ́zənt səkjʊ́rɪtij rɪ́sks ɪf nɒt prɒ́pərlij ɪ́mpləmɛ̀ntɪd, æz məlɪ́ʃəs déjtə majt bij dəsɪ́ərijəlàjzd ɪntə hɑ́rmfəl kówd, líjdɪŋ tə pətɛ́nʃəl vʌ̀lnərəbɪ́lɪtijz nówn æz dìjsɪərijəlajzéjʃən ətǽks."
    },
    {
        "Question": "What technical process transforms objects, data structures, or complex data types into a stream of bytes that can be stored or transmitted, preserving their state for later reconstruction?",
        "RightAnswer": "Binary Serialization",
        "WrongAnswers": [
            "Data Encryption",
            "Memory Paging",
            "Hash Indexing",
            "Object Pooling",
            "Bytecode Compilation"
        ],
        "Explanation": "Binary Serialization is the process of converting complex data structures or objects into a binary format that can be stored in files, memory, or transmitted across networks, while preserving all the original data relationships and structure. Unlike text-based serialization formats such as JSON or XML, binary serialization creates a compact, non-human-readable representation that is typically more efficient in terms of size and processing speed. When needed, the binary data can be deserialized back into its original object form with all properties and relationships intact. This technique is fundamental in scenarios like saving application state, caching, inter-process communication, and distributed computing where objects need to be persisted or shared across system boundaries while maintaining their complete structure and behavior capabilities. Languages and frameworks often provide built-in mechanisms for binary serialization, allowing developers to implement persistent storage or data transmission with minimal effort.",
        "trans_Question": "wɒt tɛ́knɪkəl prɒ́sɛs trænsfɔ́rmz ɒ́bdʒɛkts, déjtə strʌ́ktʃərz, ɔr kɒ́mplɛks déjtə tájps ɪntə ə stríjm əv bájts ðət kən bij stɔ́rd ɔr trænsmɪ́tɪd, prəzɜ́rvɪŋ ðɛər stéjt fɔr léjtər rìjkənstrʌ́kʃən?",
        "trans_RightAnswer": "bájnərij sɪ̀ərìjəlɪzéjʃən",
        "trans_WrongAnswers": [
            "déjtə ɛnkrɪ́pʃən",
            "mɛ́mərij péjdʒɪŋ",
            "hǽʃ ɪ́ndɛksɪŋ",
            "ɒ́bdʒəkt púwlɪŋ",
            "bájtkòwd kɒ̀mpɪléjʃən"
        ],
        "trans_Explanation": "bájnərij sɪ̀ərìjəlɪzéjʃən ɪz ðə prɒ́sɛs əv kənvɜ́rtɪŋ kɒ́mplɛks déjtə strʌ́ktʃərz ɔr ɒ́bdʒɛkts ɪntə ə bájnərij fɔ́rmæ̀t ðət kən bij stɔ́rd ɪn fájlz, mɛ́mərij, ɔr trænsmɪ́tɪd əkrɔ́s nɛ́twɜ̀rks, wájl prəzɜ́rvɪŋ ɔl ðə ərɪ́dʒɪnəl déjtə rəléjʃənʃɪ̀ps ənd strʌ́ktʃər. ʌ̀nlájk tɛ́kst-béjst sɪ̀ərìjəlɪzéjʃən fɔ́rmæ̀ts sʌtʃ æz JSON ɔr XML, bájnərij sɪ̀ərìjəlɪzéjʃən krijéjts ə kɒ́mpækt, nɒn-hjúwmən-ríjdəbəl rɛ̀prəzɛntéjʃən ðət ɪz tɪ́pɪkəlij mɔr əfɪ́ʃənt ɪn tɜ́rmz əv sájz ənd prɒ́sɛsɪŋ spíjd. wɛ́n níjdɪd, ðə bájnərij déjtə kən bij dəsɪ́ərijəlàjzd bǽk ɪntə ɪts ərɪ́dʒɪnəl ɒ́bdʒəkt fɔ́rm wɪð ɔl prɒ́pərtijz ənd rəléjʃənʃɪ̀ps ɪntǽkt. ðɪs tɛkníjk ɪz fʌ̀ndəmɛ́ntəl ɪn sənɛ́ərijowz lájk séjvɪŋ æ̀plɪkéjʃən stéjt, kǽʃɪŋ, ɪntɜ́r-prɒ́sɛs kəmjùwnɪkéjʃən, ənd dɪstrɪ́bjətɪd kəmpjúwtɪŋ wɛ́ər ɒ́bdʒɛkts níjd tə bij pərsɪ́stɪd ɔr ʃɛ́ərd əkrɔ́s sɪ́stəm báwndərijz wájl mejntéjnɪŋ ðɛər kəmplíjt strʌ́ktʃər ənd bəhéjvjər kèjpəbɪ́lɪtijz. lǽŋɡwədʒɪz ənd fréjmwɜ̀rks ɔ́fən prəvájd bɪ́lt-ɪn mɛ́kənɪzəmz fɔr bájnərij sɪ̀ərìjəlɪzéjʃən, əláwɪŋ dəvɛ́ləpərz tə ɪ́mpləmənt pərsɪ́stənt stɔ́rɪdʒ ɔr déjtə trænsmɪ́ʃən wɪð mɪ́nɪməl ɛ́fərt."
    },
    {
        "Question": "What format is commonly used for lightweight data interchange between web applications and is often described as 'self-describing' due to its human-readable text structure?",
        "RightAnswer": "JSON",
        "WrongAnswers": [
            "XML",
            "YAML",
            "CSV",
            "HTML",
            "Protocol Buffers"
        ],
        "Explanation": "JSON, which stands for JavaScript Object Notation, is a lightweight data interchange format that has become a standard for transmitting data between web applications. It emerged as an alternative to XML and gained popularity due to its simplicity and readability. JSON uses a syntax of key-value pairs organized into objects (denoted by curly braces) and arrays (denoted by square brackets), making it both human-readable and machine-parsable. Despite its origins in JavaScript, JSON is language-independent and most modern programming languages include built-in functions to parse and generate JSON data. Its popularity in web APIs, configuration files, and data storage solutions stems from its minimal syntax overhead compared to alternatives, which results in faster parsing and smaller file sizes. JSON supports common data types including strings, numbers, booleans, arrays, objects, and null values, making it versatile for representing complex data structures.",
        "trans_Question": "wɒt fɔ́rmæ̀t ɪz kɒ́mənlij júwzd fɔr lájtwéjt déjtə ɪ́ntərtʃèjndʒ bijtwíjn wɛ́b æ̀plɪkéjʃənz ənd ɪz ɔ́fən dəskrájbd æz 'sɛ́lf-dəskrájbɪŋ' djúw tə ɪts hjúwmən-ríjdəbəl tɛ́kst strʌ́ktʃər?",
        "trans_RightAnswer": "JSON",
        "trans_WrongAnswers": [
            "XML",
            "YAML",
            "CSV",
            "HTML",
            "prówtəkɒ̀l bʌ́fərz"
        ],
        "trans_Explanation": "JSON, wɪ́tʃ stǽndz fɔr dʒɒ́vəskrɪ̀pt ɒ́bdʒəkt nowtéjʃən, ɪz ə lájtwéjt déjtə ɪ́ntərtʃèjndʒ fɔ́rmæ̀t ðət həz bəkʌ́m ə stǽndərd fɔr trænsmɪ́tɪŋ déjtə bijtwíjn wɛ́b æ̀plɪkéjʃənz. ɪt əmɜ́rdʒd æz ən ɔltɜ́rnətɪv tə XML ənd ɡéjnd pɒ̀pjəlɛ́ərɪtij djúw tə ɪts sɪmplɪ́sɪtij ənd rìjdəbɪ́lɪtij. JSON júwsɪz ə sɪ́ntæ̀ks əv kíj-vǽljuw pɛ́ərz ɔ́rɡənàjzd ɪntə ɒ́bdʒɛkts (dənówtɪd baj kɜ́rlij bréjsɪz) ənd əréjz (dənówtɪd baj skwɛ́ər brǽkəts), méjkɪŋ ɪt bówθ hjúwmən-ríjdəbəl ənd məʃíjn-pɑ́rsəbəl. dəspájt ɪts ɔ́rɪdʒɪnz ɪn dʒɒ́vəskrɪ̀pt, JSON ɪz lǽŋɡwədʒ-ɪndəpɛ́ndənt ənd mówst mɒ́dərn prówɡræ̀mɪŋ lǽŋɡwədʒɪz ɪnklúwd bɪ́lt-ɪn fʌ́ŋkʃənz tə pɑ́rs ənd dʒɛ́nərèjt JSON déjtə. ɪts pɒ̀pjəlɛ́ərɪtij ɪn wɛ́b APIz, kənfɪ̀ɡjəréjʃən fájlz, ənd déjtə stɔ́rɪdʒ səlúwʃənz stɛ́mz frəm ɪts mɪ́nɪməl sɪ́ntæ̀ks ówvərhɛ́d kəmpɛ́ərd tə ɔltɜ́rnətɪvz, wɪ́tʃ rəzʌ́lts ɪn fǽstər pɑ́rsɪŋ ənd smɔ́lər fájl sájzɪz. JSON səpɔ́rts kɒ́mən déjtə tájps ɪnklúwdɪŋ strɪ́ŋz, nʌ́mbərz, búwlijənz, əréjz, ɒ́bdʒɛkts, ənd nʌ́l vǽljuwz, méjkɪŋ ɪt vɜ́rsətajl fɔr rɛ̀prəzɛ́ntɪŋ kɒ́mplɛks déjtə strʌ́ktʃərz."
    },
    {
        "Question": "Which technology, developed in the 1990s, is specifically designed to store and transport data in a self-descriptive format that is both human-readable and machine-readable, commonly used for configuration files and web service communication?",
        "RightAnswer": "XML",
        "WrongAnswers": [
            "JSON",
            "HTML",
            "SQL",
            "YAML",
            "CSS"
        ],
        "Explanation": "XML, which stands for eXtensible Markup Language, is a versatile markup language created to structure, store, and transport data across different systems. Unlike HTML, which focuses on displaying data, XML is designed to describe data without any predefined tags. Instead, it allows users to define their own custom tags to create a hierarchical structure of elements, attributes, and values. This self-descriptive nature makes XML particularly useful for sharing structured information between programs, systems, and organizations that might otherwise be incompatible. XML documents are text-based and human-readable, consisting of elements enclosed in opening and closing tags, similar to HTML but with stricter syntax rules. Since its introduction by the World Wide Web Consortium in 1998, XML has become fundamental to numerous technologies including RSS feeds, SOAP web services, document formats like Microsoft Office, and configuration files for applications. Its flexibility and platform independence have made it an enduring standard in computer science, though in recent years alternatives like JSON have gained popularity for certain applications due to their more compact syntax.",
        "trans_Question": "wɪ́tʃ tɛknɒ́lədʒij, dəvɛ́ləpt ɪn ðə 1990s, ɪz spəsɪ́fɪklij dəzájnd tə stɔ́r ənd trǽnspɔrt déjtə ɪn ə sɛ́lf-dəskrɪ́ptɪv fɔ́rmæ̀t ðət ɪz bówθ hjúwmən-ríjdəbəl ənd məʃíjn-ríjdəbəl, kɒ́mənlij júwzd fɔr kənfɪ̀ɡjəréjʃən fájlz ənd wɛ́b sɜ́rvɪs kəmjùwnɪkéjʃən?",
        "trans_RightAnswer": "XML",
        "trans_WrongAnswers": [
            "JSON",
            "HTML",
            "SQL",
            "YAML",
            "CSS"
        ],
        "trans_Explanation": "XML, wɪ́tʃ stǽndz fɔr ɛ̀kstɛ́ndɪbəl mɑ́rkʌ̀p lǽŋɡwədʒ, ɪz ə vɜ́rsətajl mɑ́rkʌ̀p lǽŋɡwədʒ krijéjtɪd tə strʌ́ktʃər, stɔ́r, ənd trǽnspɔrt déjtə əkrɔ́s dɪ́fərənt sɪ́stəmz. ʌ̀nlájk HTML, wɪ́tʃ fówkəsɪz ɒn dɪspléjɪŋ déjtə, XML ɪz dəzájnd tə dəskrájb déjtə wɪðáwt ɛ́nij prìjdəfájnd tǽɡz. ɪnstɛ́d, ɪt əláwz júwzərz tə dəfájn ðɛər ówn kʌ́stəm tǽɡz tə krijéjt ə hàjərɑ́rkɪkəl strʌ́ktʃər əv ɛ́ləmənts, ǽtrəbjùwts, ənd vǽljuwz. ðɪs sɛ́lf-dəskrɪ́ptɪv néjtʃər méjks XML pərtɪ́kjələrlij júwsfəl fɔr ʃɛ́ərɪŋ strʌ́ktʃərd ɪnfərméjʃən bijtwíjn prówɡræ̀mz, sɪ́stəmz, ənd ɔ̀rɡənɪzéjʃənz ðət majt ʌ́ðərwàjz bij ɪ̀nkəmpǽtɪbəl. XML dɒ́kjəmənts ɑr tɛ́kst-béjst ənd hjúwmən-ríjdəbəl, kənsɪ́stɪŋ əv ɛ́ləmənts ɛnklówzd ɪn ówpənɪŋ ənd klówzɪŋ tǽɡz, sɪ́mɪlər tə HTML bʌt wɪð strɪ́ktər sɪ́ntæ̀ks rúwlz. sɪns ɪts ɪntrədʌ́kʃən baj ðə wɜ́rld wájd wɛ́b kənsɔ́rʃijəm ɪn 1998, XML həz bəkʌ́m fʌ̀ndəmɛ́ntəl tə njúwmərəs tɛknɒ́lədʒijz ɪnklúwdɪŋ RSS fíjdz, SOAP wɛ́b sɜ́rvɪsɪz, dɒ́kjəmɛnt fɔ́rmæ̀ts lájk májkròwsɔ́ft ɔ́fɪs, ənd kənfɪ̀ɡjəréjʃən fájlz fɔr æ̀plɪkéjʃənz. ɪts flɛ̀ksɪbɪ́lɪtij ənd plǽtfɔ̀rm ɪndəpɛ́ndəns həv méjd ɪt ən ɛndjʊ́rɪŋ stǽndərd ɪn kəmpjúwtər sájəns, ðów ɪn ríjsənt jɪ́ərz ɔltɜ́rnətɪvz lájk JSON həv ɡéjnd pɒ̀pjəlɛ́ərɪtij fɔr sɜ́rtən æ̀plɪkéjʃənz djúw tə ðɛər mɔr kɒ́mpækt sɪ́ntæ̀ks."
    },
    {
        "Question": "Which data serialization language is often used for configuration files, is designed to be human-readable, and uses indentation to denote structure?",
        "RightAnswer": "YAML",
        "WrongAnswers": [
            "COBOL",
            "LISP",
            "Markdown",
            "GraphQL",
            "TOML"
        ],
        "Explanation": "YAML, which stands for 'YAML Ain't Markup Language' (a recursive acronym), is a human-readable data serialization language. It is commonly used for configuration files, but can be used in many applications where data is being stored or transmitted. YAML uses indentation and minimal syntax to represent hierarchical data structures, making it more readable than formats like XML or JSON. The design philosophy of YAML emphasizes simplicity, making it particularly accessible to humans while still being machine-parsable. It supports complex data types including lists, associative arrays, and scalars. Due to its readability and flexibility, YAML has become popular in modern development environments, especially in DevOps contexts for tools like Docker, Kubernetes, and various CI/CD pipelines.",
        "trans_Question": "wɪ́tʃ déjtə sɪ̀ərìjəlɪzéjʃən lǽŋɡwədʒ ɪz ɔ́fən júwzd fɔr kənfɪ̀ɡjəréjʃən fájlz, ɪz dəzájnd tə bij hjúwmən-ríjdəbəl, ənd júwsɪz ɪndɛ̀ntéjʃən tə dənówt strʌ́ktʃər?",
        "trans_RightAnswer": "YAML",
        "trans_WrongAnswers": [
            "COBOL",
            "LISP",
            "mɑ́rkdàwn",
            "ɡrǽfkwɛ̀l",
            "TOML"
        ],
        "trans_Explanation": "YAML, wɪ́tʃ stǽndz fɔr 'YAML éjnt mɑ́rkʌ̀p lǽŋɡwədʒ' (ə rəkɜ́rsɪv ǽkrənɪm), ɪz ə hjúwmən-ríjdəbəl déjtə sɪ̀ərìjəlɪzéjʃən lǽŋɡwədʒ. ɪt ɪz kɒ́mənlij júwzd fɔr kənfɪ̀ɡjəréjʃən fájlz, bʌt kən bij júwzd ɪn mɛ́nij æ̀plɪkéjʃənz wɛ́ər déjtə ɪz bíjɪŋ stɔ́rd ɔr trænsmɪ́tɪd. YAML júwsɪz ɪndɛ̀ntéjʃən ənd mɪ́nɪməl sɪ́ntæ̀ks tə rɛ̀prəzɛ́nt hàjərɑ́rkɪkəl déjtə strʌ́ktʃərz, méjkɪŋ ɪt mɔr ríjdəbəl ðʌn fɔ́rmæ̀ts lájk XML ɔr JSON. ðə dəzájn fɪlɒ́səfij əv YAML ɛ́mfəsajzɪz sɪmplɪ́sɪtij, méjkɪŋ ɪt pərtɪ́kjələrlij æksɛ́sɪbəl tə hjúwmənz wájl stɪ́l bíjɪŋ məʃíjn-pɑ́rsəbəl. ɪt səpɔ́rts kɒ́mplɛks déjtə tájps ɪnklúwdɪŋ lɪ́sts, əsówʃətɪ̀v əréjz, ənd skéjlərz. djúw tə ɪts rìjdəbɪ́lɪtij ənd flɛ̀ksɪbɪ́lɪtij, YAML həz bəkʌ́m pɒ́pjələr ɪn mɒ́dərn dəvɛ́ləpmənt ənvájərənmənts, əspɛ́ʃəlij ɪn dɛ́vɒps kɒ́ntɛ̀ksts fɔr túwlz lájk dɒ́kər, kuwbərnɛ́tɪs, ənd vɛ́ərijəs CI/CD pájplàjnz."
    },
    {
        "Question": "Which computing term refers to the standardized process of sharing structured information between different systems, often using agreed-upon formats to ensure compatibility across platforms?",
        "RightAnswer": "Data Interchange",
        "WrongAnswers": [
            "Memory Allocation",
            "Protocol Buffering",
            "System Integration",
            "Information Encapsulation",
            "Resource Virtualization"
        ],
        "Explanation": "Data Interchange refers to the structured exchange of information between different computer systems or software applications. It involves the use of standardized formats and protocols that allow diverse systems to understand and process each other's data, even when they run on different platforms or use different technologies. Common examples include XML, JSON, and EDI formats which provide rules for how data should be organized and interpreted. Data Interchange is fundamental to modern computing because it enables seamless communication between systems that would otherwise be incompatible, facilitating everything from business transactions to software integrations. Without effective Data Interchange standards, our interconnected digital world would face significant barriers to sharing information across organizational and technological boundaries.",
        "trans_Question": "wɪ́tʃ kəmpjúwtɪŋ tɜ́rm rəfɜ́rz tə ðə stǽndərdàjzd prɒ́sɛs əv ʃɛ́ərɪŋ strʌ́ktʃərd ɪnfərméjʃən bijtwíjn dɪ́fərənt sɪ́stəmz, ɔ́fən júwzɪŋ əɡríjd-əpɒ́n fɔ́rmæ̀ts tə ənʃʊ́r kəmpæ̀tɪbɪ́lɪtij əkrɔ́s plǽtfɔ̀rmz?",
        "trans_RightAnswer": "déjtə ɪ́ntərtʃèjndʒ",
        "trans_WrongAnswers": [
            "mɛ́mərij æ̀ləkéjʃən",
            "prówtəkɒ̀l bʌ́fərɪŋ",
            "sɪ́stəm ɪntəɡrejʃən",
            "ɪnfərméjʃən ɛnkǽpsəlèjʃən",
            "ríjsɔrs vɜ̀rtʃuwəlɪzéjʃən"
        ],
        "trans_Explanation": "déjtə ɪ́ntərtʃèjndʒ rəfɜ́rz tə ðə strʌ́ktʃərd əkstʃéjndʒ əv ɪnfərméjʃən bijtwíjn dɪ́fərənt kəmpjúwtər sɪ́stəmz ɔr sɔ́ftwɛ̀ər æ̀plɪkéjʃənz. ɪt ɪnvɒ́lvz ðə juwz əv stǽndərdàjzd fɔ́rmæ̀ts ənd prówtəkɔ̀lz ðət əláw dajvɜ́rs sɪ́stəmz tə ʌ̀ndərstǽnd ənd prɒ́sɛs ijtʃ ʌ́ðər'z déjtə, íjvən wɛ́n ðej rʌ́n ɒn dɪ́fərənt plǽtfɔ̀rmz ɔr juwz dɪ́fərənt tɛknɒ́lədʒijz. kɒ́mən əɡzǽmpəlz ɪnklúwd XML, JSON, ənd EDI fɔ́rmæ̀ts wɪ́tʃ prəvájd rúwlz fɔr háw déjtə ʃʊd bij ɔ́rɡənàjzd ənd ɪntɜ́rprətɪd. déjtə ɪ́ntərtʃèjndʒ ɪz fʌ̀ndəmɛ́ntəl tə mɒ́dərn kəmpjúwtɪŋ bəkɒ́z ɪt ɛnéjbəlz síjmləs kəmjùwnɪkéjʃən bijtwíjn sɪ́stəmz ðət wʊd ʌ́ðərwàjz bij ɪ̀nkəmpǽtɪbəl, fəsɪ́lətèjtɪŋ ɛ́vrijθɪ̀ŋ frəm bɪ́znəs trænzǽkʃənz tə sɔ́ftwɛ̀ər ɪntəɡrejʃənz. wɪðáwt əféktɪv déjtə ɪ́ntərtʃèjndʒ stǽndərdz, awər ɪ̀ntərkənɛ́ktɪd dɪ́dʒɪtəl wɜ́rld wʊd féjs sɪɡnɪ́fɪkənt bǽrijərz tə ʃɛ́ərɪŋ ɪnfərméjʃən əkrɔ́s ɔ̀rɡənɪzéjʃənəl ənd tɛ̀knəlɒ́dʒɪkəl báwndərijz."
    },
    {
        "Question": "What term describes the programming technique that establishes communication between networked computers using endpoints called Internet sockets?",
        "RightAnswer": "Socket Programming",
        "WrongAnswers": [
            "Thread Synchronization",
            "Database Connectivity",
            "Kernel Virtualization",
            "Stream Serialization",
            "Port Forwarding"
        ],
        "Explanation": "Socket Programming is a fundamental concept in computer networking that enables communication between different processes running on the same or different machines across a network. It provides an interface for programmers to create connection points (sockets) that act as endpoints for sending and receiving data. Think of sockets as telephone connections - they require addressing information (IP addresses and ports) to establish communication channels between applications. Socket Programming abstracts the complex networking protocols, allowing developers to focus on application logic while the underlying system handles data transmission details. It forms the foundation for almost all internet applications including web browsers, email clients, chat applications, and online games. By using standard socket APIs available in most programming languages, developers can implement client-server architectures and peer-to-peer systems that communicate reliably across networks.",
        "trans_Question": "wɒt tɜ́rm dəskrájbz ðə prówɡræ̀mɪŋ tɛkníjk ðət əstǽblɪʃɪz kəmjùwnɪkéjʃən bijtwíjn nɛ́twɜ̀rkt kəmpjúwtərz júwzɪŋ ɛ́ndpɔ̀jnts kɔ́ld ɪ́ntərnɛ̀t sɒ́kəts?",
        "trans_RightAnswer": "sɒ́kət prówɡræ̀mɪŋ",
        "trans_WrongAnswers": [
            "θrɛ́d sɪ̀ŋkrənɪzéjʃən",
            "déjtəbèjs kənɛktɪ́vɪtij",
            "kɜ́rnəl vɜ̀rtʃuwəlɪzéjʃən",
            "stríjm sɪ̀ərìjəlɪzéjʃən",
            "pɔ́rt fɔ́rwərdɪŋ"
        ],
        "trans_Explanation": "sɒ́kət prówɡræ̀mɪŋ ɪz ə fʌ̀ndəmɛ́ntəl kɒ́nsɛpt ɪn kəmpjúwtər nɛ́twɜ̀rkɪŋ ðət ɛnéjbəlz kəmjùwnɪkéjʃən bijtwíjn dɪ́fərənt prɒ́sɛsɪz rʌ́nɪŋ ɒn ðə séjm ɔr dɪ́fərənt məʃíjnz əkrɔ́s ə nɛ́twɜ̀rk. ɪt prəvájdz ən ɪ́ntərfèjs fɔr prówɡræ̀mərz tə krijéjt kənɛ́kʃən pɔ́jnts (sɒ́kəts) ðət ǽkt æz ɛ́ndpɔ̀jnts fɔr sɛ́ndɪŋ ənd rəsíjvɪŋ déjtə. θɪ́ŋk əv sɒ́kəts æz tɛ́ləfòwn kənɛ́kʃənz - ðej rəkwájər ədrɛ́sɪŋ ɪnfərméjʃən (IP ǽdrɛ́sɪz ənd pɔ́rts) tə əstǽblɪʃ kəmjùwnɪkéjʃən tʃǽnəlz bijtwíjn æ̀plɪkéjʃənz. sɒ́kət prówɡræ̀mɪŋ ǽbstrækts ðə kɒ́mplɛks nɛ́twɜ̀rkɪŋ prówtəkɔ̀lz, əláwɪŋ dəvɛ́ləpərz tə fówkəs ɒn æ̀plɪkéjʃən lɒ́dʒɪk wájl ðə ʌ̀ndərlájɪŋ sɪ́stəm hǽndəlz déjtə trænsmɪ́ʃən díjtejlz. ɪt fɔ́rmz ðə fawndéjʃən fɔr ɔ́lmowst ɔl ɪ́ntərnɛ̀t æ̀plɪkéjʃənz ɪnklúwdɪŋ wɛ́b bráwzərz, íjmejl klájənts, tʃǽt æ̀plɪkéjʃənz, ənd ɔ́nlàjn ɡéjmz. baj júwzɪŋ stǽndərd sɒ́kət APIz əvéjləbəl ɪn mówst prówɡræ̀mɪŋ lǽŋɡwədʒɪz, dəvɛ́ləpərz kən ɪ́mpləmənt klájənt-sɜ́rvər ɑ́rkɪtɛ̀ktʃərz ənd pɪ́ər-tə-pɪ́ər sɪ́stəmz ðət kəmjúwnɪkèjt rəlájəblij əkrɔ́s nɛ́twɜ̀rks."
    },
    {
        "Question": "Which protocol serves as the foundation for data communication on the World Wide Web, allowing web browsers to communicate with web servers?",
        "RightAnswer": "HTTP",
        "WrongAnswers": [
            "SMTP",
            "FTP",
            "TCP",
            "SSH",
            "DNS"
        ],
        "Explanation": "HTTP, which stands for Hypertext Transfer Protocol, is the fundamental protocol that powers the web. It operates as a request-response protocol between clients (typically web browsers) and servers (websites). When you type a URL into your browser, HTTP facilitates the process of requesting web resources like HTML pages, images, or videos from the server and delivering them back to your browser. HTTP is stateless, meaning each request is independent and unaware of previous requests. The protocol has evolved over time, with versions like HTTP/1.1 and HTTP/2 adding important features such as persistent connections and multiplexing. HTTPS is the secure version of HTTP that adds encryption through TLS/SSL to protect data during transmission. Without HTTP, the seamless web browsing experience we take for granted would not be possible, as it provides the standardized rules that enable the diverse ecosystem of web applications to function.",
        "trans_Question": "wɪ́tʃ prówtəkɒ̀l sɜ́rvz æz ðə fawndéjʃən fɔr déjtə kəmjùwnɪkéjʃən ɒn ðə wɜ́rld wájd wɛ́b, əláwɪŋ wɛ́b bráwzərz tə kəmjúwnɪkèjt wɪð wɛ́b sɜ́rvərz?",
        "trans_RightAnswer": "HTTP",
        "trans_WrongAnswers": [
            "SMTP",
            "FTP",
            "TCP",
            "SSH",
            "DNS"
        ],
        "trans_Explanation": "HTTP, wɪ́tʃ stǽndz fɔr hájpərtɛ̀kst trǽnsfər prówtəkɒ̀l, ɪz ðə fʌ̀ndəmɛ́ntəl prówtəkɒ̀l ðət páwərz ðə wɛ́b. ɪt ɒ́pərèjts æz ə rəkwɛ́st-rəspɒ́ns prówtəkɒ̀l bijtwíjn klájənts (tɪ́pɪkəlij wɛ́b bráwzərz) ənd sɜ́rvərz (wɛ́bsàjts). wɛ́n juw tájp ə URL ɪntə jɔr bráwzər, HTTP fəsɪ́lətèjts ðə prɒ́sɛs əv rəkwɛ́stɪŋ wɛ́b ríjsɔrsɪz lájk HTML péjdʒɪz, ɪ́mɪdʒɪz, ɔr vɪ́dijowz frəm ðə sɜ́rvər ənd dəlɪ́vərɪŋ ðɛm bǽk tə jɔr bráwzər. HTTP ɪz stéjtləs, míjnɪŋ ijtʃ rəkwɛ́st ɪz ɪndəpɛ́ndənt ənd ʌ̀nəwɛ́ər əv príjvijəs rəkwɛ́s. ðə prówtəkɒ̀l həz əvɒ́lvd ówvər tájm, wɪð vɜ́rʒənz lájk HTTP/1.1 ənd HTTP/2 ǽdɪŋ ɪmpɔ́rtənt fíjtʃərz sʌtʃ æz pərsɪ́stənt kənɛ́kʃənz ənd mʌ̀ltijplɛ́ksɪŋ. HTTPS ɪz ðə səkjʊ́r vɜ́rʒən əv HTTP ðət ǽdz ɛnkrɪ́pʃən θrúw TLS/SSL tə prətɛ́kt déjtə dʊ́rɪŋ trænsmɪ́ʃən. wɪðáwt HTTP, ðə síjmləs wɛ́b bráwzɪŋ əkspɪ́ərijəns wij téjk fɔr ɡrǽntɪd wʊd nɒt bij pɒ́sɪbəl, æz ɪt prəvájdz ðə stǽndərdàjzd rúwlz ðət ɛnéjbəl ðə dajvɜ́rs íjkowsɪ̀stəm əv wɛ́b æ̀plɪkéjʃənz tə fʌ́ŋkʃən."
    },
    {
        "Question": "Which protocol is specifically designed to provide encrypted communication between a web browser and a website, preventing potential eavesdropping and data tampering?",
        "RightAnswer": "HTTPS",
        "WrongAnswers": [
            "FTP",
            "SMTP",
            "DNS",
            "Telnet",
            "SSH"
        ],
        "Explanation": "HTTPS stands for Hypertext Transfer Protocol Secure. It is the secure version of HTTP, the primary protocol used for sending data between a web browser and a website. HTTPS incorporates SSL/TLS encryption to establish a protected connection, ensuring that all communications between the user's browser and the website remain private and integral. This security is particularly crucial when handling sensitive information such as credit card details, passwords, or personal data. When you visit a website using HTTPS, you'll typically see a padlock icon in your browser's address bar, indicating that your connection is encrypted and secure. HTTPS has become the standard for website security, with major browsers now marking non-HTTPS websites as 'not secure' to encourage safer browsing practices across the internet.",
        "trans_Question": "wɪ́tʃ prówtəkɒ̀l ɪz spəsɪ́fɪklij dəzájnd tə prəvájd ɛnkrɪ́ptɪd kəmjùwnɪkéjʃən bijtwíjn ə wɛ́b bráwzər ənd ə wɛ́bsàjt, prəvɛ́ntɪŋ pətɛ́nʃəl íjvzdrɒ̀pɪŋ ənd déjtə tǽmpərɪŋ?",
        "trans_RightAnswer": "HTTPS",
        "trans_WrongAnswers": [
            "FTP",
            "SMTP",
            "DNS",
            "tɛ́lnɛt",
            "SSH"
        ],
        "trans_Explanation": "HTTPS stǽndz fɔr hájpərtɛ̀kst trǽnsfər prówtəkɒ̀l səkjʊ́r. ɪt ɪz ðə səkjʊ́r vɜ́rʒən əv HTTP, ðə prájmɛ̀ərij prówtəkɒ̀l júwzd fɔr sɛ́ndɪŋ déjtə bijtwíjn ə wɛ́b bráwzər ənd ə wɛ́bsàjt. HTTPS ɪnkɔ́rpərejts SSL/TLS ɛnkrɪ́pʃən tə əstǽblɪʃ ə prətɛ́ktɪd kənɛ́kʃən, ɛnʃʊ́rɪŋ ðət ɔl kəmjùwnɪkéjʃənz bijtwíjn ðə júwzər'z bráwzər ənd ðə wɛ́bsàjt rəméjn prájvət ənd ɪ́ntəɡrəl. ðɪs səkjʊ́rɪtij ɪz pərtɪ́kjələrlij krúwʃəl wɛ́n hǽndəlɪŋ sɛ́nsɪtɪv ɪnfərméjʃən sʌtʃ æz krɛ́dɪt kɑ́rd díjtejlz, pǽswɜ̀rdz, ɔr pɜ́rsənəl déjtə. wɛ́n juw vɪ́zɪt ə wɛ́bsàjt júwzɪŋ HTTPS, júwl tɪ́pɪkəlij síj ə pǽdlɒ̀k ájkɒn ɪn jɔr bráwzər'z æ̀drɛ́s bɑ́r, ɪ́ndɪkèjtɪŋ ðət jɔr kənɛ́kʃən ɪz ɛnkrɪ́ptɪd ənd səkjʊ́r. HTTPS həz bəkʌ́m ðə stǽndərd fɔr wɛ́bsàjt səkjʊ́rɪtij, wɪð méjdʒər bráwzərz náw mɑ́rkɪŋ nɒn-èjtʃtìjpìjs wɛ́bsàjts æz 'nɒt səkjʊ́r' tə ənkɜ́rɪdʒ séjfər bráwzɪŋ prǽktɪsɪz əkrɔ́s ðə ɪ́ntərnɛ̀t."
    },
    {
        "Question": "What networking protocol stack serves as the foundation for data communication on the internet, enabling devices to connect and exchange information regardless of their hardware or operating system?",
        "RightAnswer": "TCP/IP",
        "WrongAnswers": [
            "HTTP/FTP",
            "DNS/DHCP",
            "OSI/ISO",
            "SMTP/POP3",
            "UDP/ICMP"
        ],
        "Explanation": "TCP/IP is the fundamental communication protocol suite that powers the internet and most modern computer networks. Its name comes from two core protocols: Transmission Control Protocol (TCP) and Internet Protocol (IP). TCP/IP works as a layered architecture that handles everything from how data gets broken into packets, addressed, transmitted, routed, and received between devices. What makes TCP/IP special is its universality - it allows different types of computers, running different operating systems, to communicate seamlessly across networks of any size. When you send an email, browse a website, or stream a video, TCP/IP is working behind the scenes to ensure your data reaches its destination correctly. Unlike other networking models, TCP/IP was designed with built-in redundancy, allowing data to find alternative paths if certain network connections fail, which is why the internet is so resilient. This protocol suite has become the standard language of the internet because it solves the complex problem of getting diverse systems to reliably exchange information across global networks.",
        "trans_Question": "wɒt nɛ́twɜ̀rkɪŋ prówtəkɒ̀l stǽk sɜ́rvz æz ðə fawndéjʃən fɔr déjtə kəmjùwnɪkéjʃən ɒn ðə ɪ́ntərnɛ̀t, ɛnéjbəlɪŋ dəvájsɪz tə kənɛ́kt ənd əkstʃéjndʒ ɪnfərméjʃən rəɡɑ́rdləs əv ðɛər hɑ́rdwɛ̀ər ɔr ɒ́pərèjtɪŋ sɪ́stəm?",
        "trans_RightAnswer": "TCP/IP",
        "trans_WrongAnswers": [
            "HTTP/FTP",
            "DNS/DHCP",
            "OSI/ISO",
            "SMTP/POP3",
            "UDP/ICMP"
        ],
        "trans_Explanation": "TCP/IP ɪz ðə fʌ̀ndəmɛ́ntəl kəmjùwnɪkéjʃən prówtəkɒ̀l swíjt ðət páwərz ðə ɪ́ntərnɛ̀t ənd mówst mɒ́dərn kəmpjúwtər nɛ́twɜ̀rks. ɪts néjm kʌ́mz frəm túw kɔ́r prówtəkɔ̀lz: trænsmɪ́ʃən kəntrówl prówtəkɒ̀l (TCP) ənd ɪ́ntərnɛ̀t prówtəkɒ̀l (IP). TCP/IP wɜ́rks æz ə léjərd ɑ́rkɪtɛ̀ktʃər ðət hǽndəlz ɛ́vrijθɪ̀ŋ frəm háw déjtə ɡɛ́ts brówkən ɪntə pǽkəts, ədrɛ́st, trænsmɪ́tɪd, ráwtɪd, ənd rəsíjvd bijtwíjn dəvájsɪz. wɒt méjks TCP/IP spɛ́ʃəl ɪz ɪts jùwnɪvərsǽlɪtij - ɪt əláwz dɪ́fərənt tájps əv kəmpjúwtərz, rʌ́nɪŋ dɪ́fərənt ɒ́pərèjtɪŋ sɪ́stəmz, tə kəmjúwnɪkèjt síjmləslij əkrɔ́s nɛ́twɜ̀rks əv ɛ́nij sájz. wɛ́n juw sɛ́nd ən íjmejl, bráwz ə wɛ́bsàjt, ɔr stríjm ə vɪ́dijow, TCP/IP ɪz wɜ́rkɪŋ bəhájnd ðə síjnz tə ənʃʊ́r jɔr déjtə ríjtʃɪz ɪts dɛ̀stɪnéjʃən kərɛ́ktlij. ʌ̀nlájk ʌ́ðər nɛ́twɜ̀rkɪŋ mɒ́dəlz, TCP/IP wɒz dəzájnd wɪð bɪ́lt-ɪn rədʌ́ndənsij, əláwɪŋ déjtə tə fájnd ɔltɜ́rnətɪv pǽðz ɪf sɜ́rtən nɛ́twɜ̀rk kənɛ́kʃənz féjl, wɪ́tʃ ɪz wáj ðə ɪ́ntərnɛ̀t ɪz sow rəzɪ́ljənt. ðɪs prówtəkɒ̀l swíjt həz bəkʌ́m ðə stǽndərd lǽŋɡwədʒ əv ðə ɪ́ntərnɛ̀t bəkɒ́z ɪt sɒ́lvz ðə kɒ́mplɛks prɒ́bləm əv ɡɛ́tɪŋ dajvɜ́rs sɪ́stəmz tə rəlájəblij əkstʃéjndʒ ɪnfərméjʃən əkrɔ́s ɡlówbəl nɛ́twɜ̀rks."
    },
    {
        "Question": "Which network protocol is known for providing fast, connectionless communication at the expense of reliability and guaranteed delivery?",
        "RightAnswer": "UDP",
        "WrongAnswers": [
            "TCP",
            "HTTP",
            "SMTP",
            "HTTPS",
            "FTP"
        ],
        "Explanation": "UDP (User Datagram Protocol) is a transport layer protocol that prioritizes speed over reliability in network communications. Unlike its counterpart TCP, UDP does not establish a formal connection before transmitting data, nor does it verify that packets arrive at their destination correctly or in the right order. This 'fire and forget' approach makes UDP significantly faster and more efficient for applications where occasional data loss is acceptable, such as video streaming, online gaming, or VoIP calls. The protocol achieves this efficiency by eliminating the overhead of handshaking, error checking, and packet acknowledgment mechanisms. While this means some packets might get lost or arrive out of sequence, many real-time applications prefer UDP precisely because dropping a packet is often better than waiting for it to be resent. UDP is essentially the digital equivalent of sending a postcard without requiring a signature confirmation—it might not guarantee delivery, but it's quick, lightweight, and perfectly suitable for many modern internet applications.",
        "trans_Question": "wɪ́tʃ nɛ́twɜ̀rk prówtəkɒ̀l ɪz nówn fɔr prəvájdɪŋ fǽst, kənɛ́kʃənləs kəmjùwnɪkéjʃən æt ðə əkspɛ́ns əv rəlàjəbɪ́lɪtij ənd ɡɛ̀ərəntíjd dəlɪ́vərij?",
        "trans_RightAnswer": "UDP",
        "trans_WrongAnswers": [
            "TCP",
            "HTTP",
            "SMTP",
            "HTTPS",
            "FTP"
        ],
        "trans_Explanation": "UDP (júwzər dǽtəɡræ̀m prówtəkɒ̀l) ɪz ə trǽnspɔrt léjər prówtəkɒ̀l ðət prajɔ́rɪtajzɪz spíjd ówvər rəlàjəbɪ́lɪtij ɪn nɛ́twɜ̀rk kəmjùwnɪkéjʃənz. ʌ̀nlájk ɪts káwntərpɑ̀rt TCP, UDP dʌz nɒt əstǽblɪʃ ə fɔ́rməl kənɛ́kʃən bəfɔ́r trænsmɪ́tɪŋ déjtə, nɔ́r dʌz ɪt vɛ́ərɪfaj ðət pǽkəts ərájv æt ðɛər dɛ̀stɪnéjʃən kərɛ́ktlij ɔr ɪn ðə rájt ɔ́rdər. ðɪs 'fájər ənd fərɡɛ́t' əprówtʃ méjks UDP sɪɡnɪ́fɪkəntlij fǽstər ənd mɔr əfɪ́ʃənt fɔr æ̀plɪkéjʃənz wɛ́ər əkéjʒənəl déjtə lɔ́s ɪz æksɛ́ptəbəl, sʌtʃ æz vɪ́dijow stríjmɪŋ, ɔ́nlàjn ɡéjmɪŋ, ɔr vɔjp kɔ́lz. ðə prówtəkɒ̀l ətʃíjvz ðɪs əfɪ́ʃənsij baj əlɪ́mɪnèjtɪŋ ðə ówvərhɛ́d əv hǽndʃèjkɪŋ, ɛ́ərər tʃɛ́kɪŋ, ənd pǽkət æknɒ́lɪdʒmənt mɛ́kənɪzəmz. wájl ðɪs míjnz sʌm pǽkəts majt ɡɛt lɔ́st ɔr ərájv awt əv síjkwəns, mɛ́nij ríjəl-tájm æ̀plɪkéjʃənz prəfɜ́r UDP prəsájslij bəkɒ́z drɒ́pɪŋ ə pǽkət ɪz ɔ́fən bɛ́tər ðʌn wéjtɪŋ fɔr ɪt tə bij rijzɛ́nt. UDP ɪz əsɛ́nʃəlij ðə dɪ́dʒɪtəl əkwɪ́vələnt əv sɛ́ndɪŋ ə pówskɑ̀rd wɪðáwt rijkwájərɪŋ ə sɪ́ɡnətʃər kɒ̀nfərméjʃən—ɪt majt nɒt ɡɛ̀ərəntíj dəlɪ́vərij, bʌt ɪt's kwɪ́k, lájtwéjt, ənd pɜ́rfəktlij súwtəbəl fɔr mɛ́nij mɒ́dərn ɪ́ntərnɛ̀t æ̀plɪkéjʃənz."
    },
    {
        "Question": "What is the formal set of rules that dictates how data is transmitted and received between computing devices on a network, ensuring standardized communication regardless of the devices' internal workings?",
        "RightAnswer": "Network Protocol",
        "WrongAnswers": [
            "Data Stream",
            "Network Topology",
            "Bandwidth Allocator",
            "Communication Sandbox",
            "Packet Scheduler"
        ],
        "Explanation": "A Network Protocol is a set of established rules and conventions that govern how data is formatted, transmitted, received, and processed between devices on a computer network. Think of it as a universal language or diplomatic etiquette that enables different systems to communicate effectively regardless of their underlying hardware or software. For example, when you browse a website, your device and the web server communicate using HTTP or HTTPS protocols. Similarly, when you send an email, SMTP carries your message to its destination. Protocols define numerous aspects of network communication including error detection and correction, data compression methods, how devices signal the beginning and end of messages, and how they coordinate the exchange of data. Without standardized protocols, the internet as we know it could not function, as devices from different manufacturers with diverse operating systems would be unable to exchange information coherently. Common examples include TCP/IP (the foundation of internet communication), HTTP (for web browsing), FTP (for file transfers), and DNS (for translating domain names to IP addresses).",
        "trans_Question": "wɒt ɪz ðə fɔ́rməl sɛ́t əv rúwlz ðət dɪ́ktèjts háw déjtə ɪz trænsmɪ́tɪd ənd rəsíjvd bijtwíjn kəmpjúwtɪŋ dəvájsɪz ɒn ə nɛ́twɜ̀rk, ɛnʃʊ́rɪŋ stǽndərdàjzd kəmjùwnɪkéjʃən rəɡɑ́rdləs əv ðə dəvájsɪz' ɪ̀ntɜ́rnəl wɜ́rkɪŋz?",
        "trans_RightAnswer": "nɛ́twɜ̀rk prówtəkɒ̀l",
        "trans_WrongAnswers": [
            "déjtə stríjm",
            "nɛ́twɜ̀rk təpɔ́lədʒij",
            "bǽndwɪdθ ǽləkèjtər",
            "kəmjùwnɪkéjʃən sǽndbɒ̀ks",
            "pǽkət skɛ́dʒuwlər"
        ],
        "trans_Explanation": "ə nɛ́twɜ̀rk prówtəkɒ̀l ɪz ə sɛ́t əv əstǽblɪʃt rúwlz ənd kənvɛ́nʃənz ðət ɡʌ́vərn háw déjtə ɪz fɔ́rmæ̀tɪd(), trænsmɪ́tɪd, rəsíjvd, ənd prɒ́sɛst bijtwíjn dəvájsɪz ɒn ə kəmpjúwtər nɛ́twɜ̀rk. θɪ́ŋk əv ɪt æz ə jùwnɪvɜ́rsəl lǽŋɡwədʒ ɔr dɪ̀pləmǽtɪk ɛ́tɪkət ðət ɛnéjbəlz dɪ́fərənt sɪ́stəmz tə kəmjúwnɪkèjt əfɛ́ktɪvlij rəɡɑ́rdləs əv ðɛər ʌ̀ndərlájɪŋ hɑ́rdwɛ̀ər ɔr sɔ́ftwɛ̀ər. fɔr əɡzǽmpəl, wɛ́n juw bráwz ə wɛ́bsàjt, jɔr dəvájs ənd ðə wɛ́b sɜ́rvər kəmjúwnɪkèjt júwzɪŋ HTTP ɔr HTTPS prówtəkɔ̀lz. sɪ́mɪlərlij, wɛ́n juw sɛ́nd ən íjmejl, SMTP kǽrijz jɔr mɛ́sɪdʒ tə ɪts dɛ̀stɪnéjʃən. prówtəkɔ̀lz dəfájn njúwmərəs ǽspɛkts əv nɛ́twɜ̀rk kəmjùwnɪkéjʃən ɪnklúwdɪŋ ɛ́ərər dətɛ́kʃən ənd kərɛ́kʃən, déjtə kəmprɛ́ʃən mɛ́θədz, háw dəvájsɪz sɪ́ɡnəl ðə bəɡɪ́nɪŋ ənd ɛ́nd əv mɛ́sɪdʒɪz, ənd háw ðej kowɔ́rdɪnèjt ðə əkstʃéjndʒ əv déjtə. wɪðáwt stǽndərdàjzd prówtəkɔ̀lz, ðə ɪ́ntərnɛ̀t æz wij nów ɪt kʊ́d nɒt fʌ́ŋkʃən, æz dəvájsɪz frəm dɪ́fərənt mæ̀njəfǽktʃərərz wɪð dajvɜ́rs ɒ́pərèjtɪŋ sɪ́stəmz wʊd bij ənéjbəl tə əkstʃéjndʒ ɪnfərméjʃən kowhíjərəntlij. kɒ́mən əɡzǽmpəlz ɪnklúwd TCP/IP (ðə fawndéjʃən əv ɪ́ntərnɛ̀t kəmjùwnɪkéjʃən), HTTP (fɔr wɛ́b bráwzɪŋ), FTP (fɔr fájl trǽnsfərz), ənd DNS (fɔr trǽnslèjtɪŋ dowméjn néjmz tə IP ǽdrɛ́sɪz)."
    },
    {
        "Question": "Which network device operates at the network layer, directs data packets between networks, and determines the most efficient path for data transmission?",
        "RightAnswer": "Router",
        "WrongAnswers": [
            "Switch",
            "Modem",
            "Hub",
            "Firewall",
            "Network Interface Card"
        ],
        "Explanation": "A Router is a specialized networking device that connects multiple networks together and directs data packets between them. Operating at Layer 3 (the Network layer) of the OSI model, routers use logical addressing information contained in packets to make intelligent forwarding decisions. Unlike simpler devices such as hubs or switches that operate within a single network, routers maintain routing tables that help them determine the optimal path for data to travel across complex network topologies. Modern routers perform numerous functions beyond basic packet forwarding, including network address translation (NAT), quality of service management, and security filtering. In home networks, routers typically connect your local network to the broader Internet, while in enterprise environments, they form the backbone infrastructure that enables global communications. Think of a router as a sophisticated traffic controller that not only knows all possible routes that data can take, but also evaluates factors like congestion and distance to ensure information reaches its destination efficiently.",
        "trans_Question": "wɪ́tʃ nɛ́twɜ̀rk dəvájs ɒ́pərèjts æt ðə nɛ́twɜ̀rk léjər, dɪərɛ́kts déjtə pǽkəts bijtwíjn nɛ́twɜ̀rks, ənd dətɜ́rmɪnz ðə mówst əfɪ́ʃənt pǽθ fɔr déjtə trænsmɪ́ʃən?",
        "trans_RightAnswer": "ráwtər",
        "trans_WrongAnswers": [
            "swɪ́tʃ",
            "mówdəm",
            "hʌ́b",
            "fájərwɒl",
            "nɛ́twɜ̀rk ɪ́ntərfèjs kɑ́rd"
        ],
        "trans_Explanation": "ə ráwtər ɪz ə spɛ́ʃəlàjzd nɛ́twɜ̀rkɪŋ dəvájs ðət kənɛ́kts mʌ́ltɪpəl nɛ́twɜ̀rks təɡɛ́ðər ənd dɪərɛ́kts déjtə pǽkəts bijtwíjn ðɛm. ɒ́pərèjtɪŋ æt léjər 3 (ðə nɛ́twɜ̀rk léjər) əv ðə OSI mɒ́dəl, ráwtərz juwz lɒ́dʒɪkəl ədrɛ́sɪŋ ɪnfərméjʃən kəntéjnd ɪn pǽkəts tə méjk ɪntɛ́lɪdʒənt fɔ́rwərdɪŋ dəsɪ́ʒənz. ʌ̀nlájk sɪ́mplər dəvájsɪz sʌtʃ æz hʌ́bz ɔr swɪ́tʃɪz ðət ɒ́pərèjt wɪðɪ́n ə sɪ́ŋɡəl nɛ́twɜ̀rk, ráwtərz mejntéjn ráwtɪŋ téjbəlz ðət hɛ́lp ðɛm dətɜ́rmɪn ðə ɒ́ptɪməl pǽθ fɔr déjtə tə trǽvəl əkrɔ́s kɒ́mplɛks nɛ́twɜ̀rk təpɒ́lədʒijz. mɒ́dərn ráwtərz pərfɔ́rm njúwmərəs fʌ́ŋkʃənz bìjɔ́nd béjsɪk pǽkət fɔ́rwərdɪŋ, ɪnklúwdɪŋ nɛ́twɜ̀rk æ̀drɛ́s trænsléjʃən (NAT), kwɑ́lɪtij əv sɜ́rvɪs mǽnədʒmənt, ənd səkjʊ́rɪtij fɪ́ltərɪŋ. ɪn hówm nɛ́twɜ̀rks, ráwtərz tɪ́pɪkəlij kənɛ́kt jɔr lówkəl nɛ́twɜ̀rk tə ðə brɔ́dər ɪ́ntərnɛ̀t, wájl ɪn ɛ́ntərpràjz ənvájərənmənts, ðej fɔ́rm ðə bǽkbòwn ɪnfrəstrʌ́ktʃər ðət ɛnéjbəlz ɡlówbəl kəmjùwnɪkéjʃənz. θɪ́ŋk əv ə ráwtər æz ə səfɪ́stɪkèjtɪd trǽfɪk kəntrówlər ðət nɒt ównlij nówz ɔl pɒ́sɪbəl ráwts ðət déjtə kən téjk, bʌt ɔ́lsow əvǽljuwèjts fǽktərz lájk kəndʒɛ́stʃən ənd dɪ́stəns tə ənʃʊ́r ɪnfərméjʃən ríjtʃɪz ɪts dɛ̀stɪnéjʃən əfɪ́ʃəntlij."
    },
    {
        "Question": "What is the name of the networking device that connects multiple computers within a local area network (LAN) by examining incoming data packets and forwarding them to their intended destination?",
        "RightAnswer": "Switch",
        "WrongAnswers": [
            "Gateway",
            "Router",
            "Hub",
            "Bridge",
            "Modem"
        ],
        "Explanation": "A Switch is a crucial networking device in computer science that intelligently connects multiple devices within a local area network. Unlike its predecessor the hub, a switch examines each data packet's destination address and forwards it only to the specific port where the intended recipient is connected. This selective forwarding creates dedicated connections between communicating devices, improving network efficiency by reducing unnecessary traffic. Switches operate at the data link layer of the OSI model, using MAC addresses to make forwarding decisions. Modern switches offer features like virtual LANs, quality of service controls, and port mirroring. Beyond networking, the term 'switch' in programming refers to control flow statements that allow code to execute different paths based on the value of an expression, offering an alternative to multiple if-else conditions. Both contexts highlight the switch's fundamental role in directing information flow, whether digital data packets or program execution.",
        "trans_Question": "wɒt ɪz ðə néjm əv ðə nɛ́twɜ̀rkɪŋ dəvájs ðət kənɛ́kts mʌ́ltɪpəl kəmpjúwtərz wɪðɪ́n ə lówkəl ɛ́ərijə nɛ́twɜ̀rk (LAN) baj əɡzǽmɪnɪŋ ɪ́nkʌ̀mɪŋ déjtə pǽkəts ənd fɔ́rwərdɪŋ ðɛm tə ðɛər ɪntɛ́ndɪd dɛ̀stɪnéjʃən?",
        "trans_RightAnswer": "swɪ́tʃ",
        "trans_WrongAnswers": [
            "ɡéjtwèj",
            "ráwtər",
            "hʌ́b",
            "brɪ́dʒ",
            "mówdəm"
        ],
        "trans_Explanation": "ə swɪ́tʃ ɪz ə krúwʃəl nɛ́twɜ̀rkɪŋ dəvájs ɪn kəmpjúwtər sájəns ðət ɪntɛ́lɪdʒəntlij kənɛ́kts mʌ́ltɪpəl dəvájsɪz wɪðɪ́n ə lówkəl ɛ́ərijə nɛ́twɜ̀rk. ʌ̀nlájk ɪts prɛ́dəsɛ̀sər ðə hʌ́b, ə swɪ́tʃ əɡzǽmɪnz ijtʃ déjtə pǽkət's dɛ̀stɪnéjʃən æ̀drɛ́s ənd fɔ́rwərdz ɪt ównlij tə ðə spəsɪ́fɪk pɔ́rt wɛ́ər ðə ɪntɛ́ndɪd rəsɪ́pijənt ɪz kənɛ́ktɪd. ðɪs səlɛ́ktɪv fɔ́rwərdɪŋ krijéjts dɛ́dɪkejtɪd kənɛ́kʃənz bijtwíjn kəmjúwnɪkèjtɪŋ dəvájsɪz, ɪmprúwvɪŋ nɛ́twɜ̀rk əfɪ́ʃənsij baj rədjúwsɪŋ ʌ̀nnɛ́səsɛ̀ərij trǽfɪk. swɪ́tʃɪz ɒ́pərèjt æt ðə déjtə lɪ́ŋk léjər əv ðə OSI mɒ́dəl, júwzɪŋ MAC ǽdrɛ́sɪz tə méjk fɔ́rwərdɪŋ dəsɪ́ʒənz. mɒ́dərn swɪ́tʃɪz ɔ́fər fíjtʃərz lájk vɜ́rtʃuwəl lænz, kwɑ́lɪtij əv sɜ́rvɪs kəntrówlz, ənd pɔ́rt mɪ́ərərɪŋ. bìjɔ́nd nɛ́twɜ̀rkɪŋ, ðə tɜ́rm 'swɪ́tʃ' ɪn prówɡræ̀mɪŋ rəfɜ́rz tə kəntrówl flów stéjtmənts ðət əláw kówd tə ɛ́ksəkjùwt dɪ́fərənt pǽðz béjst ɒn ðə vǽljuw əv ən əksprɛ́ʃən, ɔ́fərɪŋ ən ɔltɜ́rnətɪv tə mʌ́ltɪpəl ɪf-ɛ́ls kəndɪ́ʃənz. bówθ kɒ́ntɛ̀ksts hájlàjt ðə swɪ́tʃ'z fʌ̀ndəmɛ́ntəl rówl ɪn dɪərɛ́ktɪŋ ɪnfərméjʃən flów, wɛ́ðər dɪ́dʒɪtəl déjtə pǽkəts ɔr prówɡræ̀m ɛ̀ksəkjúwʃən."
    },
    {
        "Question": "Which technique distributes network traffic across multiple servers to ensure no single server becomes overwhelmed while maximizing reliability and availability?",
        "RightAnswer": "Load Balancing",
        "WrongAnswers": [
            "Data Sharding",
            "Traffic Tunneling",
            "Request Queueing",
            "Resource Pooling",
            "Network Partitioning"
        ],
        "Explanation": "Load Balancing is a critical technique in computer science that intelligently distributes incoming network traffic, computational tasks, or application requests across multiple servers or resources. The primary goal is to prevent any single server from becoming overwhelmed with too many requests, which could lead to slowdowns or crashes. Load balancers act as traffic conductors, using various algorithms such as round-robin, least connections, or weighted distribution to determine which server should handle each incoming request. This technique significantly improves system reliability, maximizes throughput, minimizes response time, and ensures high availability. Load balancing is fundamental to cloud computing, large websites, and distributed systems where handling variable workloads efficiently is essential. Without effective load balancing, popular services might crash during traffic spikes or provide inconsistent performance to users.",
        "trans_Question": "wɪ́tʃ tɛkníjk dɪstrɪ́bjuwts nɛ́twɜ̀rk trǽfɪk əkrɔ́s mʌ́ltɪpəl sɜ́rvərz tə ənʃʊ́r now sɪ́ŋɡəl sɜ́rvər bəkʌ́mz òwvərwɛ́lmd wájl mǽksɪmàjzɪŋ rəlàjəbɪ́lɪtij ənd əvèjləbɪ́lɪtij?",
        "trans_RightAnswer": "lówd bǽlənsɪŋ",
        "trans_WrongAnswers": [
            "déjtə ʃɑ́rdɪŋ",
            "trǽfɪk tʌ́nəlɪŋ",
            "rəkwɛ́st kjúwɪŋ",
            "ríjsɔrs púwlɪŋ",
            "nɛ́twɜ̀rk pɑrtɪ́ʃənɪŋ"
        ],
        "trans_Explanation": "lówd bǽlənsɪŋ ɪz ə krɪ́tɪkəl tɛkníjk ɪn kəmpjúwtər sájəns ðət ɪntɛ́lɪdʒəntlij dɪstrɪ́bjuwts ɪ́nkʌ̀mɪŋ nɛ́twɜ̀rk trǽfɪk, kɒ̀mpjuwtéjʃənəl tǽsks, ɔr æ̀plɪkéjʃən rəkwɛ́s əkrɔ́s mʌ́ltɪpəl sɜ́rvərz ɔr ríjsɔrsɪz. ðə prájmɛ̀ərij ɡówl ɪz tə prəvɛ́nt ɛ́nij sɪ́ŋɡəl sɜ́rvər frəm bəkʌ́mɪŋ òwvərwɛ́lmd wɪð túw mɛ́nij rəkwɛ́s, wɪ́tʃ kʊ́d líjd tə slówdàwnz ɔr krǽʃɪz. lówd bǽlənsərz ǽkt æz trǽfɪk kəndʌ́ktərz, júwzɪŋ vɛ́ərijəs ǽlɡərɪ̀ðəmz sʌtʃ æz ráwnd-rɒ́bɪn, líjst kənɛ́kʃənz, ɔr wéjtɪd dɪ̀strəbjúwʃən tə dətɜ́rmɪn wɪ́tʃ sɜ́rvər ʃʊd hǽndəl ijtʃ ɪ́nkʌ̀mɪŋ rəkwɛ́st. ðɪs tɛkníjk sɪɡnɪ́fɪkəntlij ɪmprúwvz sɪ́stəm rəlàjəbɪ́lɪtij, mǽksɪmàjzɪz θrúwpʊ̀t, mɪ́nɪmàjzɪz rəspɒ́ns tájm, ənd ənʃʊ́rz háj əvèjləbɪ́lɪtij. lówd bǽlənsɪŋ ɪz fʌ̀ndəmɛ́ntəl tə kláwd kəmpjúwtɪŋ, lɑ́rdʒ wɛ́bsàjts, ənd dɪstrɪ́bjətɪd sɪ́stəmz wɛ́ər hǽndəlɪŋ vɛ́ərijəbəl wɜ́rklòwdz əfɪ́ʃəntlij ɪz əsɛ́nʃəl. wɪðáwt əféktɪv lówd bǽlənsɪŋ, pɒ́pjələr sɜ́rvɪsɪz majt krǽʃ dʊ́rɪŋ trǽfɪk spájks ɔr prəvájd ɪ̀nkənsɪ́stənt pərfɔ́rməns tə júwzərz."
    },
    {
        "Question": "Which network protocol is primarily responsible for translating human-readable domain names like 'google.com' into the numerical IP addresses that computers use to identify each other?",
        "RightAnswer": "DNS",
        "WrongAnswers": [
            "HTTP",
            "SMTP",
            "FTP",
            "TCP/IP",
            "SSH"
        ],
        "Explanation": "DNS, which stands for Domain Name System, serves as the internet's directory service. It acts like a phone book for the internet by translating the domain names we can easily remember (like 'wikipedia.org') into the numerical IP addresses (like 192.0.2.1) that computers need to locate each other. Without DNS, we would need to memorize complex strings of numbers to visit websites or send emails. When you type a web address into your browser, a DNS query is initiated behind the scenes to find the corresponding IP address, enabling your device to connect to the correct server. DNS operates through a global, hierarchical network of servers that work together to resolve these queries efficiently, making it one of the fundamental technologies that makes the internet user-friendly and accessible.",
        "trans_Question": "wɪ́tʃ nɛ́twɜ̀rk prówtəkɒ̀l ɪz prajmɛ́ərɪlij rəspɒ́nsɪbəl fɔr trǽnslèjtɪŋ hjúwmən-ríjdəbəl dowméjn néjmz lájk 'googlecom' ɪntə ðə njuwmɛ́ərɪkəl IP ǽdrɛ́sɪz ðət kəmpjúwtərz juwz tə ajdɛ́ntɪfàj ijtʃ ʌ́ðər?",
        "trans_RightAnswer": "DNS",
        "trans_WrongAnswers": [
            "HTTP",
            "SMTP",
            "FTP",
            "TCP/IP",
            "SSH"
        ],
        "trans_Explanation": "DNS, wɪ́tʃ stǽndz fɔr dowméjn néjm sɪ́stəm, sɜ́rvz æz ðə ɪ́ntərnɛ̀t's dɪərɛ́ktərij sɜ́rvɪs. ɪt ǽkts lájk ə fówn bʊ́k fɔr ðə ɪ́ntərnɛ̀t baj trǽnslèjtɪŋ ðə dowméjn néjmz wij kən íjzəlij rəmɛ́mbər (lájk 'wɪ̀kɪpíjdijə') ɪntə ðə njuwmɛ́ərɪkəl IP ǽdrɛ́sɪz (lájk 192.0.2.1) ðət kəmpjúwtərz níjd tə lówkèjt ijtʃ ʌ́ðər. wɪðáwt DNS, wij wʊd níjd tə mɛ́məràjz kɒ́mplɛks strɪ́ŋz əv nʌ́mbərz tə vɪ́zɪt wɛ́bsàjts ɔr sɛ́nd íjmejlz. wɛ́n juw tájp ə wɛ́b æ̀drɛ́s ɪntə jɔr bráwzər, ə DNS kwɛ́ərij ɪz ɪnɪ́ʃijejtɪd bəhájnd ðə síjnz tə fájnd ðə kɔ̀rəspɒ́ndɪŋ IP æ̀drɛ́s, ɛnéjbəlɪŋ jɔr dəvájs tə kənɛ́kt tə ðə kərɛ́kt sɜ́rvər. DNS ɒ́pərèjts θrúw ə ɡlówbəl, hàjərɑ́rkɪkəl nɛ́twɜ̀rk əv sɜ́rvərz ðət wɜ́rk təɡɛ́ðər tə rijzɒ́lv ðijz kwɛ́ərijz əfɪ́ʃəntlij, méjkɪŋ ɪt wʌ́n əv ðə fʌ̀ndəmɛ́ntəl tɛknɒ́lədʒijz ðət méjks ðə ɪ́ntərnɛ̀t júwzər-frɛ́ndlij ənd æksɛ́sɪbəl."
    },
    {
        "Question": "Which network protocol automatically assigns IP addresses to devices joining a network, allowing them to communicate without manual configuration?",
        "RightAnswer": "DHCP",
        "WrongAnswers": [
            "SMTP",
            "HTTP",
            "FTP",
            "DNS",
            "ARP"
        ],
        "Explanation": "DHCP stands for Dynamic Host Configuration Protocol, which is a network management protocol used to automate the process of configuring devices on IP networks. When a device connects to a network, the DHCP server assigns it a unique IP address, subnet mask, default gateway, and other network parameters. This automation eliminates the need for network administrators to manually assign IP addresses to all network devices. DHCP operates on a client-server model where the client (your device) requests an IP address, and the server responds with the necessary configuration information. This protocol is fundamental to modern networks as it simplifies network administration and allows devices to seamlessly join and leave networks without creating IP conflicts. Without DHCP, every device would need manual configuration before it could communicate on a network.",
        "trans_Question": "wɪ́tʃ nɛ́twɜ̀rk prówtəkɒ̀l ɔ̀təmǽtɪklij əsájnz IP ǽdrɛ́sɪz tə dəvájsɪz dʒɔ́jnɪŋ ə nɛ́twɜ̀rk, əláwɪŋ ðɛm tə kəmjúwnɪkèjt wɪðáwt mǽnjuwəl kənfɪ̀ɡjəréjʃən?",
        "trans_RightAnswer": "DHCP",
        "trans_WrongAnswers": [
            "SMTP",
            "HTTP",
            "FTP",
            "DNS",
            "ARP"
        ],
        "trans_Explanation": "DHCP stǽndz fɔr dajnǽmɪk hówst kənfɪ̀ɡjəréjʃən prówtəkɒ̀l, wɪ́tʃ ɪz ə nɛ́twɜ̀rk mǽnədʒmənt prówtəkɒ̀l júwzd tə ɔ́təmèjt ðə prɒ́sɛs əv kənfɪ́ɡjərɪŋ dəvájsɪz ɒn IP nɛ́twɜ̀rks. wɛ́n ə dəvájs kənɛ́kts tə ə nɛ́twɜ̀rk, ðə DHCP sɜ́rvər əsájnz ɪt ə juwnɪ́k IP æ̀drɛ́s, sʌ́bnɛ̀t mǽsk, dəfɔ́lt ɡéjtwèj, ənd ʌ́ðər nɛ́twɜ̀rk pərǽmətərz. ðɪs ɔtəméjʃən əlɪ́mɪnèjts ðə níjd fɔr nɛ́twɜ̀rk ædmɪ́nɪstrèjtərz tə mǽnjuwəlij əsájn IP ǽdrɛ́sɪz tə ɔl nɛ́twɜ̀rk dəvájsɪz. DHCP ɒ́pərèjts ɒn ə klájənt-sɜ́rvər mɒ́dəl wɛ́ər ðə klájənt (jɔr dəvájs) rəkwɛ́s ən IP æ̀drɛ́s, ənd ðə sɜ́rvər rəspɒ́ndz wɪð ðə nɛ́səsɛ̀ərij kənfɪ̀ɡjəréjʃən ɪnfərméjʃən. ðɪs prówtəkɒ̀l ɪz fʌ̀ndəmɛ́ntəl tə mɒ́dərn nɛ́twɜ̀rks æz ɪt sɪ́mpləfajz nɛ́twɜ̀rk ædmɪ̀nɪstréjʃən ənd əláwz dəvájsɪz tə síjmləslij dʒɔ́jn ənd líjv nɛ́twɜ̀rks wɪðáwt krijéjtɪŋ IP kɒ́nflɪkts. wɪðáwt DHCP, ɛvərij dəvájs wʊd níjd mǽnjuwəl kənfɪ̀ɡjəréjʃən bəfɔ́r ɪt kʊ́d kəmjúwnɪkèjt ɒn ə nɛ́twɜ̀rk."
    },
    {
        "Question": "What is the system of assigning unique numerical labels to every device connected to a computer network that uses the Internet Protocol for communication?",
        "RightAnswer": "IP Addressing",
        "WrongAnswers": [
            "MAC Allocation",
            "Network Enumeration",
            "Device Registration",
            "Digital Identification",
            "Protocol Mapping"
        ],
        "Explanation": "IP Addressing is the method used to assign unique numerical identifiers to devices participating in a computer network that uses the Internet Protocol. These addresses serve two critical functions: they identify the host or network interface, and they provide the location of the host in the network. IP addresses function like postal addresses in the digital world, ensuring that data packets reach their intended destinations across the vast internet. There are two main versions in use today: IPv4 which uses a 32-bit format typically displayed as four numbers separated by dots (like 192.168.1.1), and IPv6 which uses a 128-bit format displayed as eight groups of hexadecimal digits separated by colons to accommodate the growing number of connected devices. IP addressing enables routers to forward data packets across networks worldwide, forming the foundation of internet connectivity.",
        "trans_Question": "wɒt ɪz ðə sɪ́stəm əv əsájnɪŋ juwnɪ́k njuwmɛ́ərɪkəl léjbəlz tə ɛvərij dəvájs kənɛ́ktɪd tə ə kəmpjúwtər nɛ́twɜ̀rk ðət júwsɪz ðə ɪ́ntərnɛ̀t prówtəkɒ̀l fɔr kəmjùwnɪkéjʃən?",
        "trans_RightAnswer": "IP ədrɛ́sɪŋ",
        "trans_WrongAnswers": [
            "MAC æ̀ləkéjʃən",
            "nɛ́twɜ̀rk ənjùwməréjʃən",
            "dəvájs rɛ̀dʒɪstréjʃən",
            "dɪ́dʒɪtəl ajdɛ̀ntɪfɪkéjʃən",
            "prówtəkɒ̀l mǽpɪŋ"
        ],
        "trans_Explanation": "IP ədrɛ́sɪŋ ɪz ðə mɛ́θəd júwzd tə əsájn juwnɪ́k njuwmɛ́ərɪkəl ajdɛ́ntɪfàjərz tə dəvájsɪz pɑrtɪ́sɪpèjtɪŋ ɪn ə kəmpjúwtər nɛ́twɜ̀rk ðət júwsɪz ðə ɪ́ntərnɛ̀t prówtəkɒ̀l. ðijz ǽdrɛ́sɪz sɜ́rv túw krɪ́tɪkəl fʌ́ŋkʃənz: ðej ajdɛ́ntɪfàj ðə hówst ɔr nɛ́twɜ̀rk ɪ́ntərfèjs, ənd ðej prəvájd ðə lowkéjʃən əv ðə hówst ɪn ðə nɛ́twɜ̀rk. IP ǽdrɛ́sɪz fʌ́ŋkʃən lájk pówstəl ǽdrɛ́sɪz ɪn ðə dɪ́dʒɪtəl wɜ́rld, ɛnʃʊ́rɪŋ ðət déjtə pǽkəts ríjtʃ ðɛər ɪntɛ́ndɪd dɛ̀stɪnéjʃənz əkrɔ́s ðə vǽst ɪ́ntərnɛ̀t. ðɛər ɑr túw méjn vɜ́rʒənz ɪn juwz tədéj: IPV4 wɪ́tʃ júwsɪz ə 32-bɪ́t fɔ́rmæ̀t tɪ́pɪkəlij dɪspléjd æz fɔ́r nʌ́mbərz sɛ́pərèjtɪd baj dɒ́ts (lájk 192.168.1.1), ənd IPV6 wɪ́tʃ júwsɪz ə 128-bɪ́t fɔ́rmæ̀t dɪspléjd æz éjt ɡrúwps əv hɛ̀ksədɛ́sɪməl dɪ́dʒɪts sɛ́pərèjtɪd baj kówlənz tə əkɒ́mədèjt ðə ɡrówɪŋ nʌ́mbər əv kənɛ́ktɪd dəvájsɪz. IP ədrɛ́sɪŋ ɛnéjbəlz ráwtərz tə fɔ́rwərd déjtə pǽkəts əkrɔ́s nɛ́twɜ̀rks wɜ́rldwájd, fɔ́rmɪŋ ðə fawndéjʃən əv ɪ́ntərnɛ̀t kənɛktɪ́vɪtij."
    },
    {
        "Question": "What is the process of dividing a large network into smaller, more manageable segments to improve network performance and security?",
        "RightAnswer": "Subnetting",
        "WrongAnswers": [
            "Fragmentation",
            "Partitioning",
            "Network Slicing",
            "Routing Protocol",
            "Domain Splitting"
        ],
        "Explanation": "Subnetting is a technique in computer networking that involves dividing a single large network into multiple smaller logical networks called subnets. This process allows network administrators to create separate network segments that can operate more efficiently by reducing network traffic congestion, improving security through isolation, and making the overall network more manageable. Subnetting works by borrowing bits from the host portion of an IP address to create a subnet mask, which determines which part of an address identifies the network and which part identifies the host. For example, a large organization might subnet its network to separate different departments, ensuring that traffic between accounting and engineering only crosses network boundaries when necessary. Beyond improved efficiency and security, subnetting also helps conserve IP addresses by allowing organizations to use private addressing schemes within their networks. This technique forms a fundamental part of modern network design and is essential knowledge for network engineers and administrators.",
        "trans_Question": "wɒt ɪz ðə prɒ́sɛs əv dɪvájdɪŋ ə lɑ́rdʒ nɛ́twɜ̀rk ɪntə smɔ́lər, mɔr mǽnədʒəbəl sɛ́ɡmənts tə ɪmprúwv nɛ́twɜ̀rk pərfɔ́rməns ənd səkjʊ́rɪtij?",
        "trans_RightAnswer": "sʌ́bnɛtɪŋ",
        "trans_WrongAnswers": [
            "fræ̀ɡməntéjʃən",
            "pɑrtɪ́ʃənɪŋ",
            "nɛ́twɜ̀rk slájsɪŋ",
            "ráwtɪŋ prówtəkɒ̀l",
            "dowméjn splɪ́tɪŋ"
        ],
        "trans_Explanation": "sʌ́bnɛtɪŋ ɪz ə tɛkníjk ɪn kəmpjúwtər nɛ́twɜ̀rkɪŋ ðət ɪnvɒ́lvz dɪvájdɪŋ ə sɪ́ŋɡəl lɑ́rdʒ nɛ́twɜ̀rk ɪntə mʌ́ltɪpəl smɔ́lər lɒ́dʒɪkəl nɛ́twɜ̀rks kɔ́ld sʌ́bnɛts. ðɪs prɒ́sɛs əláwz nɛ́twɜ̀rk ædmɪ́nɪstrèjtərz tə krijéjt sɛ́pərət nɛ́twɜ̀rk sɛ́ɡmənts ðət kən ɒ́pərèjt mɔr əfɪ́ʃəntlij baj rədjúwsɪŋ nɛ́twɜ̀rk trǽfɪk kəndʒɛ́stʃən, ɪmprúwvɪŋ səkjʊ́rɪtij θrúw àjsəléjʃən, ənd méjkɪŋ ðə ówvərɔ̀l nɛ́twɜ̀rk mɔr mǽnədʒəbəl. sʌ́bnɛtɪŋ wɜ́rks baj bɑ́rowɪŋ bɪ́ts frəm ðə hówst pɔ́rʃən əv ən IP æ̀drɛ́s tə krijéjt ə sʌ́bnɛ̀t mǽsk, wɪ́tʃ dətɜ́rmɪnz wɪ́tʃ pɑ́rt əv ən æ̀drɛ́s ajdɛ́ntɪfàjz ðə nɛ́twɜ̀rk ənd wɪ́tʃ pɑ́rt ajdɛ́ntɪfàjz ðə hówst. fɔr əɡzǽmpəl, ə lɑ́rdʒ ɔ̀rɡənɪzéjʃən majt sʌ́bnɛ̀t ɪts nɛ́twɜ̀rk tə sɛ́pərət dɪ́fərənt dəpɑ́rtmənts, ɛnʃʊ́rɪŋ ðət trǽfɪk bijtwíjn əkáwntɪŋ ənd ɛ̀ndʒɪnɪ́ərɪŋ ównlij krɔ́sɪz nɛ́twɜ̀rk báwndərijz wɛ́n nɛ́səsɛ̀ərij. bìjɔ́nd ɪmprúwvd əfɪ́ʃənsij ənd səkjʊ́rɪtij, sʌ́bnɛtɪŋ ɔ́lsow hɛ́lps kənsɜ́rv IP ǽdrɛ́sɪz baj əláwɪŋ ɔ̀rɡənɪzéjʃənz tə juwz prájvət ədrɛ́sɪŋ skíjmz wɪðɪ́n ðɛər nɛ́twɜ̀rks. ðɪs tɛkníjk fɔ́rmz ə fʌ̀ndəmɛ́ntəl pɑ́rt əv mɒ́dərn nɛ́twɜ̀rk dəzájn ənd ɪz əsɛ́nʃəl nɒ́lɪdʒ fɔr nɛ́twɜ̀rk ɛ̀ndʒɪnɪ́ərz ənd ædmɪ́nɪstrèjtərz."
    },
    {
        "Question": "In computer networks, which technology allows multiple private devices to share a single public IP address, enabling them to communicate with external networks like the internet?",
        "RightAnswer": "NAT",
        "WrongAnswers": [
            "DNS",
            "DHCP",
            "VPN",
            "SSH",
            "ARP"
        ],
        "Explanation": "NAT, or Network Address Translation, is a technology that allows multiple devices on a private network to connect to the internet using a single public IP address. It works like a receptionist for a large office building: when devices from your private network send requests to the internet, NAT modifies the source IP address to the public one and keeps track of which internal device made which request. When responses come back, NAT translates the destination address back to the correct private IP. This technology has been crucial in extending the lifespan of IPv4 by conserving public IP addresses, since it allows potentially hundreds of devices to share just one public address. NAT also provides a basic security layer by hiding internal network addresses from the outside world. Common implementations include Source NAT (SNAT), which modifies outgoing traffic, and Destination NAT (DNAT), which redirects incoming traffic to specific internal hosts.",
        "trans_Question": "ɪn kəmpjúwtər nɛ́twɜ̀rks, wɪ́tʃ tɛknɒ́lədʒij əláwz mʌ́ltɪpəl prájvət dəvájsɪz tə ʃɛ́ər ə sɪ́ŋɡəl pʌ́blɪk IP æ̀drɛ́s, ɛnéjbəlɪŋ ðɛm tə kəmjúwnɪkèjt wɪð əkstɜ́rnəl nɛ́twɜ̀rks lájk ðə ɪ́ntərnɛ̀t?",
        "trans_RightAnswer": "NAT",
        "trans_WrongAnswers": [
            "DNS",
            "DHCP",
            "VPN",
            "SSH",
            "ARP"
        ],
        "trans_Explanation": "NAT, ɔr nɛ́twɜ̀rk æ̀drɛ́s trænsléjʃən, ɪz ə tɛknɒ́lədʒij ðət əláwz mʌ́ltɪpəl dəvájsɪz ɒn ə prájvət nɛ́twɜ̀rk tə kənɛ́kt tə ðə ɪ́ntərnɛ̀t júwzɪŋ ə sɪ́ŋɡəl pʌ́blɪk IP æ̀drɛ́s. ɪt wɜ́rks lájk ə rəsɛ́pʃənɪst fɔr ə lɑ́rdʒ ɔ́fɪs bɪ́ldɪŋ: wɛ́n dəvájsɪz frəm jɔr prájvət nɛ́twɜ̀rk sɛ́nd rəkwɛ́s tə ðə ɪ́ntərnɛ̀t, NAT mɒ́dɪfàjz ðə sɔ́rs IP æ̀drɛ́s tə ðə pʌ́blɪk wʌ́n ənd kíjps trǽk əv wɪ́tʃ ɪ̀ntɜ́rnəl dəvájs méjd wɪ́tʃ rəkwɛ́st. wɛ́n rəspɒ́nsɪz kʌ́m bǽk, NAT trǽnslèjts ðə dɛ̀stɪnéjʃən æ̀drɛ́s bǽk tə ðə kərɛ́kt prájvət IP. ðɪs tɛknɒ́lədʒij həz bɪn krúwʃəl ɪn əkstɛ́ndɪŋ ðə lájfspæ̀n əv IPV4 baj kənsɜ́rvɪŋ pʌ́blɪk IP ǽdrɛ́sɪz, sɪns ɪt əláwz pətɛ́nʃəlij hʌ́ndərdz əv dəvájsɪz tə ʃɛ́ər dʒəst wʌ́n pʌ́blɪk æ̀drɛ́s. NAT ɔ́lsow prəvájdz ə béjsɪk səkjʊ́rɪtij léjər baj hájdɪŋ ɪ̀ntɜ́rnəl nɛ́twɜ̀rk ǽdrɛ́sɪz frəm ðə áwtsájd wɜ́rld. kɒ́mən ɪ̀mpləmɛntéjʃənz ɪnklúwd sɔ́rs NAT (SNAT), wɪ́tʃ mɒ́dɪfàjz áwtɡòwɪŋ trǽfɪk, ənd dɛ̀stɪnéjʃən NAT (DNAT), wɪ́tʃ rìjdɪərɛ́kts ɪ́nkʌ̀mɪŋ trǽfɪk tə spəsɪ́fɪk ɪ̀ntɜ́rnəl hówsts."
    },
    {
        "Question": "Which technology allows multiple devices on a private network to connect to the internet using a single public IP address, providing both address conservation and a level of security?",
        "RightAnswer": "Network Address Translation",
        "WrongAnswers": [
            "Domain Name System",
            "Virtual Private Network",
            "Border Gateway Protocol",
            "Dynamic Host Configuration Protocol",
            "Subnet Masking"
        ],
        "Explanation": "Network Address Translation (NAT) is a technology that modifies network address information in packet headers while they traverse a traffic routing device, typically a router or firewall. NAT allows multiple devices on a private network to access external networks like the internet using a single public IP address. It works by maintaining a translation table that maps private IP addresses to the router's public IP address, changing the packet headers as they pass through. This serves two important purposes: it conserves the limited pool of available public IPv4 addresses (since many private devices can share one public address), and it provides a basic security layer by hiding internal network addresses from the outside world. NAT has become nearly ubiquitous in home and business networks, where routers perform this translation automatically, allowing all connected devices to access the internet simultaneously through a single internet connection.",
        "trans_Question": "wɪ́tʃ tɛknɒ́lədʒij əláwz mʌ́ltɪpəl dəvájsɪz ɒn ə prájvət nɛ́twɜ̀rk tə kənɛ́kt tə ðə ɪ́ntərnɛ̀t júwzɪŋ ə sɪ́ŋɡəl pʌ́blɪk IP æ̀drɛ́s, prəvájdɪŋ bówθ æ̀drɛ́s kɒ̀nsərvéjʃən ənd ə lɛ́vəl əv səkjʊ́rɪtij?",
        "trans_RightAnswer": "nɛ́twɜ̀rk æ̀drɛ́s trænsléjʃən",
        "trans_WrongAnswers": [
            "dowméjn néjm sɪ́stəm",
            "vɜ́rtʃuwəl prájvət nɛ́twɜ̀rk",
            "bɔ́rdər ɡéjtwèj prówtəkɒ̀l",
            "dajnǽmɪk hówst kənfɪ̀ɡjəréjʃən prówtəkɒ̀l",
            "sʌ́bnɛ̀t mǽskɪŋ"
        ],
        "trans_Explanation": "nɛ́twɜ̀rk æ̀drɛ́s trænsléjʃən (NAT) ɪz ə tɛknɒ́lədʒij ðət mɒ́dɪfàjz nɛ́twɜ̀rk æ̀drɛ́s ɪnfərméjʃən ɪn pǽkət hɛ́dərz wájl ðej trǽvərs ə trǽfɪk ráwtɪŋ dəvájs, tɪ́pɪkəlij ə ráwtər ɔr fájərwɒl. NAT əláwz mʌ́ltɪpəl dəvájsɪz ɒn ə prájvət nɛ́twɜ̀rk tə ǽksɛ̀s əkstɜ́rnəl nɛ́twɜ̀rks lájk ðə ɪ́ntərnɛ̀t júwzɪŋ ə sɪ́ŋɡəl pʌ́blɪk IP æ̀drɛ́s. ɪt wɜ́rks baj mejntéjnɪŋ ə trænsléjʃən téjbəl ðət mǽps prájvət IP ǽdrɛ́sɪz tə ðə ráwtər'z pʌ́blɪk IP æ̀drɛ́s, tʃéjndʒɪŋ ðə pǽkət hɛ́dərz æz ðej pǽs θrúw. ðɪs sɜ́rvz túw ɪmpɔ́rtənt pɜ́rpəsɪz: ɪt kənsɜ́rvz ðə lɪ́mɪtɪd púwl əv əvéjləbəl pʌ́blɪk IPV4 ǽdrɛ́sɪz (sɪns mɛ́nij prájvət dəvájsɪz kən ʃɛ́ər wʌ́n pʌ́blɪk æ̀drɛ́s), ənd ɪt prəvájdz ə béjsɪk səkjʊ́rɪtij léjər baj hájdɪŋ ɪ̀ntɜ́rnəl nɛ́twɜ̀rk ǽdrɛ́sɪz frəm ðə áwtsájd wɜ́rld. NAT həz bəkʌ́m nɪ́ərlij juwbɪ́kwɪtəs ɪn hówm ənd bɪ́znəs nɛ́twɜ̀rks, wɛ́ər ráwtərz pərfɔ́rm ðɪs trænsléjʃən ɔ̀təmǽtɪklij, əláwɪŋ ɔl kənɛ́ktɪd dəvájsɪz tə ǽksɛ̀s ðə ɪ́ntərnɛ̀t sàjməltéjnijəslij θrúw ə sɪ́ŋɡəl ɪ́ntərnɛ̀t kənɛ́kʃən."
    },
    {
        "Question": "Which protocol suite provides secure, encrypted communications between a client and server over the internet, protecting sensitive information like passwords and credit card details?",
        "RightAnswer": "SSL/TLS",
        "WrongAnswers": [
            "HTTP/AJAX",
            "FTP/SFTP",
            "TCP/UDP",
            "SMTP/POP3",
            "DHCP/DNS"
        ],
        "Explanation": "SSL/TLS (Secure Sockets Layer/Transport Layer Security) is a protocol suite that establishes an encrypted connection between a client and server over the internet. Think of it as a secure tunnel that protects data traveling between your browser and websites. When you see 'https' or a padlock icon in your browser, SSL/TLS is at work. It operates through a handshake process where the server presents a digital certificate to verify its identity, then both parties agree on encryption methods. SSL was developed in the 1990s, but has largely been replaced by its successor, TLS, though many people still refer to both protocols collectively as 'SSL/TLS'. This technology is fundamental to internet security, preventing attackers from intercepting or tampering with sensitive information like passwords, credit card details, and personal data as it travels across the internet.",
        "trans_Question": "wɪ́tʃ prówtəkɒ̀l swíjt prəvájdz səkjʊ́r, ɛnkrɪ́ptɪd kəmjùwnɪkéjʃənz bijtwíjn ə klájənt ənd sɜ́rvər ówvər ðə ɪ́ntərnɛ̀t, prətɛ́ktɪŋ sɛ́nsɪtɪv ɪnfərméjʃən lájk pǽswɜ̀rdz ənd krɛ́dɪt kɑ́rd díjtejlz?",
        "trans_RightAnswer": "SSL/TLS",
        "trans_WrongAnswers": [
            "HTTP/AJAX",
            "FTP/SFTP",
            "TCP/UDP",
            "SMTP/POP3",
            "DHCP/DNS"
        ],
        "trans_Explanation": "SSL/TLS (səkjʊ́r sɒ́kəts léjər/trǽnspɔrt léjər səkjʊ́rɪtij) ɪz ə prówtəkɒ̀l swíjt ðət əstǽblɪʃɪz ən ɛnkrɪ́ptɪd kənɛ́kʃən bijtwíjn ə klájənt ənd sɜ́rvər ówvər ðə ɪ́ntərnɛ̀t. θɪ́ŋk əv ɪt æz ə səkjʊ́r tʌ́nəl ðət prətɛ́kts déjtə trǽvəlɪŋ bijtwíjn jɔr bráwzər ənd wɛ́bsàjts. wɛ́n juw síj 'èjtʃtìjpìjs' ɔr ə pǽdlɒ̀k ájkɒn ɪn jɔr bráwzər, SSL/TLS ɪz æt wɜ́rk. ɪt ɒ́pərèjts θrúw ə hǽndʃèjk prɒ́sɛs wɛ́ər ðə sɜ́rvər prɛ́zənts ə dɪ́dʒɪtəl sərtɪ́fɪkət tə vɛ́ərɪfaj ɪts ajdɛ́ntɪtij, ðɛn bówθ pɑ́rtijz əɡríj ɒn ɛnkrɪ́pʃən mɛ́θədz. SSL wɒz dəvɛ́ləpt ɪn ðə 1990s, bʌt həz lɑ́rdʒlij bɪn rìjpléjst baj ɪts səksɛ́sər, TLS, ðów mɛ́nij píjpəl stɪ́l rəfɜ́r tə bówθ prówtəkɔ̀lz kəlɛ́ktɪvlij æz 'SSL/TLS'. ðɪs tɛknɒ́lədʒij ɪz fʌ̀ndəmɛ́ntəl tə ɪ́ntərnɛ̀t səkjʊ́rɪtij, prəvɛ́ntɪŋ ətǽkərz frəm ɪ̀ntərsɛ́ptɪŋ ɔr tǽmpərɪŋ wɪð sɛ́nsɪtɪv ɪnfərméjʃən lájk pǽswɜ̀rdz, krɛ́dɪt kɑ́rd díjtejlz, ənd pɜ́rsənəl déjtə æz ɪt trǽvəlz əkrɔ́s ðə ɪ́ntərnɛ̀t."
    },
    {
        "Question": "In web security, what digital documents are issued by trusted authorities to verify the identity of entities and secure online communications through cryptographic techniques?",
        "RightAnswer": "Certificates",
        "WrongAnswers": [
            "Tokens",
            "Credentials",
            "Signatures",
            "Passports",
            "Handshakes"
        ],
        "Explanation": "In computer science, Certificates (specifically Digital Certificates or Public Key Certificates) are electronic documents that establish trust in digital environments. They're issued by trusted Certificate Authorities and serve as digital proof of identity, binding a public key to an entity such as a website, organization, or individual. Certificates contain information about the identity of the certificate holder, the issuing authority, validity period, and cryptographic keys. The most common type, SSL/TLS certificates, secure communications between web servers and browsers by encrypting data transmission. When you see a padlock icon in your browser's address bar, it indicates the website has a valid certificate. Certificates form a crucial component of Public Key Infrastructure (PKI) and are fundamental to establishing secure connections, verifying authenticity, and maintaining privacy in our digital interactions.",
        "trans_Question": "ɪn wɛ́b səkjʊ́rɪtij, wɒt dɪ́dʒɪtəl dɒ́kjəmənts ɑr ɪ́ʃuwd baj trʌ́stɪd əθɔ́rɪtijz tə vɛ́ərɪfaj ðə ajdɛ́ntɪtij əv ɛ́ntɪtijz ənd səkjʊ́r ɔ́nlàjn kəmjùwnɪkéjʃənz θrúw krɪptɒ́ɡrəfɪk tɛkníjks?",
        "trans_RightAnswer": "sərtɪ́fɪkəts",
        "trans_WrongAnswers": [
            "tówkənz",
            "krədɛ́nʃəlz",
            "sɪ́ɡnətʃərz",
            "pǽspɔ̀rts",
            "hǽndʃèjks"
        ],
        "trans_Explanation": "ɪn kəmpjúwtər sájəns, sərtɪ́fɪkəts (spəsɪ́fɪklij dɪ́dʒɪtəl sərtɪ́fɪkəts ɔr pʌ́blɪk kíj sərtɪ́fɪkəts) ɑr ələktrɒ́nɪk dɒ́kjəmənts ðət əstǽblɪʃ trʌ́st ɪn dɪ́dʒɪtəl ənvájərənmənts. ðɛ́ər ɪ́ʃuwd baj trʌ́stɪd sərtɪ́fɪkət əθɔ́rɪtijz ənd sɜ́rv æz dɪ́dʒɪtəl prúwf əv ajdɛ́ntɪtij, bájndɪŋ ə pʌ́blɪk kíj tə ən ɛ́ntɪtij sʌtʃ æz ə wɛ́bsàjt, ɔ̀rɡənɪzéjʃən, ɔr ɪndɪvɪ́dʒəwəl. sərtɪ́fɪkəts kəntéjn ɪnfərméjʃən əbawt ðə ajdɛ́ntɪtij əv ðə sərtɪ́fɪkət hówldər, ðə ɪ́ʃuwɪŋ əθɔ́rɪtij, væ̀lɪ́dɪtij pɪ́ərijəd, ənd krɪptɒ́ɡrəfɪk kíjz. ðə mówst kɒ́mən tájp, SSL/TLS sərtɪ́fɪkəts, səkjʊ́r kəmjùwnɪkéjʃənz bijtwíjn wɛ́b sɜ́rvərz ənd bráwzərz baj ɛnkrɪ́ptɪŋ déjtə trænsmɪ́ʃən. wɛ́n juw síj ə pǽdlɒ̀k ájkɒn ɪn jɔr bráwzər'z æ̀drɛ́s bɑ́r, ɪt ɪ́ndɪkèjts ðə wɛ́bsàjt həz ə vǽlɪd sərtɪ́fɪkət. sərtɪ́fɪkəts fɔ́rm ə krúwʃəl kəmpównənt əv pʌ́blɪk kíj ɪnfrəstrʌ́ktʃər (PKI) ənd ɑr fʌ̀ndəmɛ́ntəl tə əstǽblɪʃɪŋ səkjʊ́r kənɛ́kʃənz, vɛ́ərɪfajɪŋ ɔ̀θəntɪ́sɪtij, ənd mejntéjnɪŋ prájvəsij ɪn awər dɪ́dʒɪtəl ɪ̀ntərǽkʃənz."
    },
    {
        "Question": "Which technology establishes a framework for secure communication through the management of digital certificates and cryptographic keys in networked environments?",
        "RightAnswer": "Public Key Infrastructure",
        "WrongAnswers": [
            "Network Address Translation",
            "Transport Layer Security",
            "Symmetric Encryption Framework",
            "Digital Signature Algorithm",
            "Certificate Revocation Protocol"
        ],
        "Explanation": "Public Key Infrastructure (PKI) is a comprehensive system designed to enable secure digital communications in networked environments. It manages the creation, distribution, storage, and revocation of digital certificates and public keys. At its core, PKI establishes trust between communicating parties who may have never met by using trusted third parties called Certificate Authorities (CAs). These CAs validate identities and issue digital certificates that bind public keys to entities like individuals, organizations, or servers. When you connect to a secure website, PKI is working behind the scenes to verify the site's authenticity. PKI supports essential security functions including encryption for privacy, digital signatures for authentication and non-repudiation, and secure key exchange. By providing this trusted framework, PKI forms the backbone of secure e-commerce, secure email, and other protected communications across the internet.",
        "trans_Question": "wɪ́tʃ tɛknɒ́lədʒij əstǽblɪʃɪz ə fréjmwɜ̀rk fɔr səkjʊ́r kəmjùwnɪkéjʃən θrúw ðə mǽnədʒmənt əv dɪ́dʒɪtəl sərtɪ́fɪkəts ənd krɪptɒ́ɡrəfɪk kíjz ɪn nɛ́twɜ̀rkt ənvájərənmənts?",
        "trans_RightAnswer": "pʌ́blɪk kíj ɪnfrəstrʌ́ktʃər",
        "trans_WrongAnswers": [
            "nɛ́twɜ̀rk æ̀drɛ́s trænsléjʃən",
            "trǽnspɔrt léjər səkjʊ́rɪtij",
            "sɪmɛ́trɪk ɛnkrɪ́pʃən fréjmwɜ̀rk",
            "dɪ́dʒɪtəl sɪ́ɡnətʃər ǽlɡərɪ̀ðəm",
            "sərtɪ́fɪkət rɛ̀vəkéjʃən prówtəkɒ̀l"
        ],
        "trans_Explanation": "pʌ́blɪk kíj ɪnfrəstrʌ́ktʃər (PKI) ɪz ə kɒ̀mprəhɛ́nsɪv sɪ́stəm dəzájnd tə ɛnéjbəl səkjʊ́r dɪ́dʒɪtəl kəmjùwnɪkéjʃənz ɪn nɛ́twɜ̀rkt ənvájərənmənts. ɪt mǽnɪdʒɪz ðə krijéjʃən, dɪ̀strəbjúwʃən, stɔ́rɪdʒ, ənd rɛ̀vəkéjʃən əv dɪ́dʒɪtəl sərtɪ́fɪkəts ənd pʌ́blɪk kíjz. æt ɪts kɔ́r, PKI əstǽblɪʃɪz trʌ́st bijtwíjn kəmjúwnɪkèjtɪŋ pɑ́rtijz huw mej həv nɛ́vər mɛ́t baj júwzɪŋ trʌ́stɪd θɜ́rd pɑ́rtijz kɔ́ld sərtɪ́fɪkət əθɔ́rɪtijz (kǽs). ðijz kǽs vǽlɪdèjt ajdɛ́ntɪtijz ənd ɪ́ʃuw dɪ́dʒɪtəl sərtɪ́fɪkəts ðət bájnd pʌ́blɪk kíjz tə ɛ́ntɪtijz lájk ɪndɪvɪ́dʒəwəlz, ɔ̀rɡənɪzéjʃənz, ɔr sɜ́rvərz. wɛ́n juw kənɛ́kt tə ə səkjʊ́r wɛ́bsàjt, PKI ɪz wɜ́rkɪŋ bəhájnd ðə síjnz tə vɛ́ərɪfaj ðə sájt'z ɔ̀θəntɪ́sɪtij. PKI səpɔ́rts əsɛ́nʃəl səkjʊ́rɪtij fʌ́ŋkʃənz ɪnklúwdɪŋ ɛnkrɪ́pʃən fɔr prájvəsij, dɪ́dʒɪtəl sɪ́ɡnətʃərz fɔr ɔθɛ̀ntɪkéjʃən ənd nɒn-rəpjùwdijéjʃən, ənd səkjʊ́r kíj əkstʃéjndʒ. baj prəvájdɪŋ ðɪs trʌ́stɪd fréjmwɜ̀rk, PKI fɔ́rmz ðə bǽkbòwn əv səkjʊ́r e-kɒ́mərs, səkjʊ́r íjmejl, ənd ʌ́ðər prətɛ́ktɪd kəmjùwnɪkéjʃənz əkrɔ́s ðə ɪ́ntərnɛ̀t."
    },
    {
        "Question": "In a typical client-server architecture, which component is dedicated to providing resources, services, and functionality to multiple client devices across a network?",
        "RightAnswer": "Server",
        "WrongAnswers": [
            "Gateway",
            "Firewall",
            "Terminal",
            "Compiler",
            "Cache"
        ],
        "Explanation": "A server is a specialized computer or software system designed to process requests and deliver data to other computers over a local network or the internet. Unlike personal computers, servers are optimized for network use, often featuring redundant components, enhanced security features, and the ability to run continuously. Servers can fulfill various roles depending on their configuration, such as web servers that deliver website content, file servers that provide access to shared files, database servers that store and manage data, or application servers that run software applications. In the client-server model, the server acts as the centralized resource provider, allowing multiple client devices to access its services simultaneously without requiring those resources to be duplicated across each client machine. This architecture forms the backbone of most modern computing infrastructure, from small business networks to global cloud computing platforms.",
        "trans_Question": "ɪn ə tɪ́pɪkəl klájənt-sɜ́rvər ɑ́rkɪtɛ̀ktʃər, wɪ́tʃ kəmpównənt ɪz dɛ́dɪkejtɪd tə prəvájdɪŋ ríjsɔrsɪz, sɜ́rvɪsɪz, ənd fʌ̀ŋkʃənǽlɪtij tə mʌ́ltɪpəl klájənt dəvájsɪz əkrɔ́s ə nɛ́twɜ̀rk?",
        "trans_RightAnswer": "sɜ́rvər",
        "trans_WrongAnswers": [
            "ɡéjtwèj",
            "fájərwɒl",
            "tɜ́rmɪnəl",
            "kəmpájlər",
            "kǽʃ"
        ],
        "trans_Explanation": "ə sɜ́rvər ɪz ə spɛ́ʃəlàjzd kəmpjúwtər ɔr sɔ́ftwɛ̀ər sɪ́stəm dəzájnd tə prɒ́sɛs rəkwɛ́s ənd dəlɪ́vər déjtə tə ʌ́ðər kəmpjúwtərz ówvər ə lówkəl nɛ́twɜ̀rk ɔr ðə ɪ́ntərnɛ̀t. ʌ̀nlájk pɜ́rsənəl kəmpjúwtərz, sɜ́rvərz ɑr ɒ́ptɪmàjzd fɔr nɛ́twɜ̀rk juwz, ɔ́fən fíjtʃərɪŋ rədʌ́ndənt kəmpównənts, ənhǽnst səkjʊ́rɪtij fíjtʃərz, ənd ðə əbɪ́lɪtij tə rʌ́n kəntɪ́njuwəslij. sɜ́rvərz kən fʊlfɪ́l vɛ́ərijəs rówlz dəpɛ́ndɪŋ ɒn ðɛər kənfɪ̀ɡjəréjʃən, sʌtʃ æz wɛ́b sɜ́rvərz ðət dəlɪ́vər wɛ́bsàjt kɒ́ntənt, fájl sɜ́rvərz ðət prəvájd ǽksɛ̀s tə ʃɛ́ərd fájlz, déjtəbèjs sɜ́rvərz ðət stɔ́r ənd mǽnɪdʒ déjtə, ɔr æ̀plɪkéjʃən sɜ́rvərz ðət rʌ́n sɔ́ftwɛ̀ər æ̀plɪkéjʃənz. ɪn ðə klájənt-sɜ́rvər mɒ́dəl, ðə sɜ́rvər ǽkts æz ðə sɛ́ntrəlàjzd ríjsɔrs prəvájdər, əláwɪŋ mʌ́ltɪpəl klájənt dəvájsɪz tə ǽksɛ̀s ɪts sɜ́rvɪsɪz sàjməltéjnijəslij wɪðáwt rijkwájərɪŋ ðowz ríjsɔrsɪz tə bij djúwplɪkèjtɪd əkrɔ́s ijtʃ klájənt məʃíjn. ðɪs ɑ́rkɪtɛ̀ktʃər fɔ́rmz ðə bǽkbòwn əv mówst mɒ́dərn kəmpjúwtɪŋ ɪnfrəstrʌ́ktʃər, frəm smɔ́l bɪ́znəs nɛ́twɜ̀rks tə ɡlówbəl kláwd kəmpjúwtɪŋ plǽtfɔ̀rmz."
    },
    {
        "Question": "What computing architecture consists of powerful central computers that handle processing requests from multiple simpler devices that primarily handle user interaction?",
        "RightAnswer": "Client-Server Model",
        "WrongAnswers": [
            "Peer-to-Peer Network",
            "Distributed Computing System",
            "Mainframe Architecture",
            "Edge Computing Paradigm",
            "Cloud Virtualization"
        ],
        "Explanation": "The Client-Server Model is a fundamental architecture in computer science where computing workloads are divided between providers of resources or services (servers) and service requesters (clients). In this model, client devices—like laptops, smartphones, or desktop computers—send requests to more powerful server computers that store data, run applications, or perform complex processing tasks. The server processes these requests and returns results to the client. This model underlies most modern computing experiences, from browsing websites (where your browser is the client and the website host is the server) to using email or streaming services. Unlike peer-to-peer systems where all computers have equal roles, the client-server model clearly separates responsibilities, allowing for centralized resource management, improved security, and scalability as additional clients can be added without rebuilding the entire system.",
        "trans_Question": "wɒt kəmpjúwtɪŋ ɑ́rkɪtɛ̀ktʃər kənsɪ́sts əv páwərfəl sɛ́ntrəl kəmpjúwtərz ðət hǽndəl prɒ́sɛsɪŋ rəkwɛ́s frəm mʌ́ltɪpəl sɪ́mplər dəvájsɪz ðət prajmɛ́ərɪlij hǽndəl júwzər ɪ̀ntərǽkʃən?",
        "trans_RightAnswer": "klájənt-sɜ́rvər mɒ́dəl",
        "trans_WrongAnswers": [
            "pɪ́ər-tə-pɪ́ər nɛ́twɜ̀rk",
            "dɪstrɪ́bjətɪd kəmpjúwtɪŋ sɪ́stəm",
            "méjnfrèjm ɑ́rkɪtɛ̀ktʃər",
            "ɛ́dʒ kəmpjúwtɪŋ pǽrədàjm",
            "kláwd vɜ̀rtʃuwəlɪzéjʃən"
        ],
        "trans_Explanation": "ðə klájənt-sɜ́rvər mɒ́dəl ɪz ə fʌ̀ndəmɛ́ntəl ɑ́rkɪtɛ̀ktʃər ɪn kəmpjúwtər sájəns wɛ́ər kəmpjúwtɪŋ wɜ́rklòwdz ɑr dɪvájdɪd bijtwíjn prəvájdərz əv ríjsɔrsɪz ɔr sɜ́rvɪsɪz (sɜ́rvərz) ənd sɜ́rvɪs rɪkwɛ́stərz (klájənts). ɪn ðɪs mɒ́dəl, klájənt dəvájsɪz—lájk lǽptɒ̀ps, smɑ́rtfòwnz, ɔr dɛ́sktɒ̀p kəmpjúwtərz—sɛ́nd rəkwɛ́s tə mɔr páwərfəl sɜ́rvər kəmpjúwtərz ðət stɔ́r déjtə, rʌ́n æ̀plɪkéjʃənz, ɔr pərfɔ́rm kɒ́mplɛks prɒ́sɛsɪŋ tǽsks. ðə sɜ́rvər prɒ́sɛsɪz ðijz rəkwɛ́s ənd rətɜ́rnz rəzʌ́lts tə ðə klájənt. ðɪs mɒ́dəl ʌ̀ndərlájz mówst mɒ́dərn kəmpjúwtɪŋ əkspɪ́ərijənsijz, frəm bráwzɪŋ wɛ́bsàjts (wɛ́ər jɔr bráwzər ɪz ðə klájənt ənd ðə wɛ́bsàjt hówst ɪz ðə sɜ́rvər) tə júwzɪŋ íjmejl ɔr stríjmɪŋ sɜ́rvɪsɪz. ʌ̀nlájk pɪ́ər-tə-pɪ́ər sɪ́stəmz wɛ́ər ɔl kəmpjúwtərz həv íjkwəl rówlz, ðə klájənt-sɜ́rvər mɒ́dəl klɪ́ərlij sɛ́pərèjts rəspɒ̀nsɪbɪ́lɪtijz, əláwɪŋ fɔr sɛ́ntrəlàjzd ríjsɔrs mǽnədʒmənt, ɪmprúwvd səkjʊ́rɪtij, ənd skéjləbɪ́lɪtij æz ədɪ́ʃənəl klájənts kən bij ǽdɪd wɪðáwt rijbɪ́ldɪŋ ðə əntájər sɪ́stəm."
    },
    {
        "Question": "Which network architecture allows individual computers to connect directly with each other without requiring a central server to facilitate the connection?",
        "RightAnswer": "Peer-to-Peer",
        "WrongAnswers": [
            "Client-Server",
            "Hub-and-Spoke",
            "Master-Slave",
            "Hierarchical Distribution",
            "Centralized Network"
        ],
        "Explanation": "Peer-to-Peer refers to a network architecture where computers, called peers, function as both clients and servers simultaneously. Unlike traditional client-server models where data flows from central servers to clients, peer-to-peer systems allow direct exchange of resources and services between participants without requiring central coordination. Examples include file-sharing networks like BitTorrent, cryptocurrency systems like Bitcoin, and collaborative applications. This architecture offers advantages including improved scalability, resilience against central points of failure, and efficient resource utilization. However, it also introduces challenges related to security, consistency, and discovery of resources across the distributed network. Peer-to-Peer represents a fundamental shift from hierarchical to distributed computing paradigms.",
        "trans_Question": "wɪ́tʃ nɛ́twɜ̀rk ɑ́rkɪtɛ̀ktʃər əláwz ɪndɪvɪ́dʒəwəl kəmpjúwtərz tə kənɛ́kt dɪərɛ́klij wɪð ijtʃ ʌ́ðər wɪðáwt rijkwájərɪŋ ə sɛ́ntrəl sɜ́rvər tə fəsɪ́lətèjt ðə kənɛ́kʃən?",
        "trans_RightAnswer": "pɪ́ər-tə-pɪ́ər",
        "trans_WrongAnswers": [
            "klájənt-sɜ́rvər",
            "hʌ́b-ənd-spówk",
            "mǽstər-sléjv",
            "hàjərɑ́rkɪkəl dɪ̀strəbjúwʃən",
            "sɛ́ntrəlàjzd nɛ́twɜ̀rk"
        ],
        "trans_Explanation": "pɪ́ər-tə-pɪ́ər rəfɜ́rz tə ə nɛ́twɜ̀rk ɑ́rkɪtɛ̀ktʃər wɛ́ər kəmpjúwtərz, kɔ́ld pɪ́ərz, fʌ́ŋkʃən æz bówθ klájənts ənd sɜ́rvərz sàjməltéjnijəslij. ʌ̀nlájk trədɪ́ʃənəl klájənt-sɜ́rvər mɒ́dəlz wɛ́ər déjtə flówz frəm sɛ́ntrəl sɜ́rvərz tə klájənts, pɪ́ər-tə-pɪ́ər sɪ́stəmz əláw dɪərɛ́kt əkstʃéjndʒ əv ríjsɔrsɪz ənd sɜ́rvɪsɪz bijtwíjn pɑrtɪ́səpənts wɪðáwt rijkwájərɪŋ sɛ́ntrəl kowɔ̀rdɪnéjʃən. əɡzǽmpəlz ɪnklúwd fájl-ʃɛ́ərɪŋ nɛ́twɜ̀rks lájk bɪ́ttɔ̀rənt, krɪptówkərənsij sɪ́stəmz lájk bɪ́tkɔ́jn, ənd kəlǽbərətɪv æ̀plɪkéjʃənz. ðɪs ɑ́rkɪtɛ̀ktʃər ɔ́fərz ədvǽntɪdʒɪz ɪnklúwdɪŋ ɪmprúwvd skéjləbɪ́lɪtij, rəzɪ́lijəns əɡéjnst sɛ́ntrəl pɔ́jnts əv féjljər, ənd əfɪ́ʃənt ríjsɔrs jùwtɪlɪzéjʃən. hàwɛ́vər, ɪt ɔ́lsow ɪntrədúwsɪz tʃǽləndʒɪz rəléjtɪd tə səkjʊ́rɪtij, kənsɪ́stənsij, ənd dɪ̀skʌ́vrij əv ríjsɔrsɪz əkrɔ́s ðə dɪstrɪ́bjətɪd nɛ́twɜ̀rk. pɪ́ər-tə-pɪ́ər rɛ̀prəzɛ́nts ə fʌ̀ndəmɛ́ntəl ʃɪ́ft frəm hàjərɑ́rkɪkəl tə dɪstrɪ́bjətɪd kəmpjúwtɪŋ pǽrədàjmz."
    },
    {
        "Question": "What technology concept refers to the network of physical objects embedded with sensors, software, and connectivity that enables them to collect and exchange data without requiring human interaction?",
        "RightAnswer": "Internet of Things",
        "WrongAnswers": [
            "Distributed Computing",
            "Virtual Networking",
            "Cloud Architecture",
            "Machine Learning Pipeline",
            "Neural Networking Protocol"
        ],
        "Explanation": "The Internet of Things (IoT) is a paradigm where everyday physical objects are connected to the internet and can identify themselves to other devices. These objects, equipped with sensors and software, collect and exchange data with minimal human intervention. IoT extends internet connectivity beyond traditional devices like computers and smartphones to everyday objects, enabling them to send, receive, and process data. From smart homes where thermostats adjust automatically based on your preferences, to industrial applications where machines predict their own maintenance needs, IoT creates a more interconnected world. This technology relies on various components including sensors for data collection, connectivity protocols for transmission, and data processing capabilities either on the device itself or in the cloud. As IoT continues to evolve, it raises important considerations around security, privacy, and standardization across the expanding ecosystem of connected devices.",
        "trans_Question": "wɒt tɛknɒ́lədʒij kɒ́nsɛpt rəfɜ́rz tə ðə nɛ́twɜ̀rk əv fɪ́zɪkəl ɒ́bdʒɛkts ɛmbɛ́dɪd wɪð sɛ́nsərz, sɔ́ftwɛ̀ər, ənd kənɛktɪ́vɪtij ðət ɛnéjbəlz ðɛm tə kəlɛ́kt ənd əkstʃéjndʒ déjtə wɪðáwt rijkwájərɪŋ hjúwmən ɪ̀ntərǽkʃən?",
        "trans_RightAnswer": "ɪ́ntərnɛ̀t əv θɪ́ŋz",
        "trans_WrongAnswers": [
            "dɪstrɪ́bjətɪd kəmpjúwtɪŋ",
            "vɜ́rtʃuwəl nɛ́twɜ̀rkɪŋ",
            "kláwd ɑ́rkɪtɛ̀ktʃər",
            "məʃíjn lɜ́rnɪŋ pájplàjn",
            "nʊ́rəl nɛ́twɜ̀rkɪŋ prówtəkɒ̀l"
        ],
        "trans_Explanation": "ðə ɪ́ntərnɛ̀t əv θɪ́ŋz (ijot) ɪz ə pǽrədàjm wɛ́ər ɛ́vrijdéj fɪ́zɪkəl ɒ́bdʒɛkts ɑr kənɛ́ktɪd tə ðə ɪ́ntərnɛ̀t ənd kən ajdɛ́ntɪfàj ðəmsɛ́lvz tə ʌ́ðər dəvájsɪz. ðijz ɒ́bdʒɛkts, əkwɪ́pt wɪð sɛ́nsərz ənd sɔ́ftwɛ̀ər, kəlɛ́kt ənd əkstʃéjndʒ déjtə wɪð mɪ́nɪməl hjúwmən ɪ̀ntərvɛ́nʃən. ijot əkstɛ́ndz ɪ́ntərnɛ̀t kənɛktɪ́vɪtij bìjɔ́nd trədɪ́ʃənəl dəvájsɪz lájk kəmpjúwtərz ənd smɑ́rtfòwnz tə ɛ́vrijdéj ɒ́bdʒɛkts, ɛnéjbəlɪŋ ðɛm tə sɛ́nd, rəsíjv, ənd prɒ́sɛs déjtə. frəm smɑ́rt hówmz wɛ́ər θɜ́rməstæ̀ts ədʒʌ́st ɔ̀təmǽtɪklij béjst ɒn jɔr prɛ́fərənsɪz, tə ɪndʌ́strijəl æ̀plɪkéjʃənz wɛ́ər məʃíjnz prədɪ́kt ðɛər ówn méjntənəns níjdz, ijot krijéjts ə mɔr ɪ̀ntərkənɛ́ktɪd wɜ́rld. ðɪs tɛknɒ́lədʒij rəlájz ɒn vɛ́ərijəs kəmpównənts ɪnklúwdɪŋ sɛ́nsərz fɔr déjtə kəlɛ́kʃən, kənɛktɪ́vɪtij prówtəkɔ̀lz fɔr trænsmɪ́ʃən, ənd déjtə prɒ́sɛsɪŋ kèjpəbɪ́lɪtijz ájðər ɒn ðə dəvájs ɪtsɛ́lf ɔr ɪn ðə kláwd. æz ijot kəntɪ́njuwz tə əvɒ́lv, ɪt réjzɪz ɪmpɔ́rtənt kənsɪ̀dəréjʃənz əráwnd səkjʊ́rɪtij, prájvəsij, ənd stændərdɪzéjʃən əkrɔ́s ðə əkspǽndɪŋ íjkowsɪ̀stəm əv kənɛ́ktɪd dəvájsɪz."
    },
    {
        "Question": "Which computing technology refers to specialized computer systems that are designed to perform dedicated functions within a larger mechanical or electrical system, often with real-time operational constraints?",
        "RightAnswer": "Embedded Systems",
        "WrongAnswers": [
            "Cloud Computing",
            "Distributed Databases",
            "Virtual Machines",
            "Parallel Processing",
            "Quantum Computing"
        ],
        "Explanation": "Embedded Systems are specialized computing systems that are integrated into larger devices or products to control specific functions. Unlike general-purpose computers such as laptops or smartphones, embedded systems are designed for dedicated tasks with specific requirements. They can be found in everything from simple digital watches, microwave ovens, and automotive control systems to complex medical equipment and industrial robots. These systems typically combine hardware and software components engineered to meet strict requirements for reliability, efficiency, size, and cost. Embedded systems often operate with limited resources (memory, processing power) and frequently need to respond in real-time to environmental inputs. Their ubiquity makes them fundamental to modern technology - most people interact with dozens of embedded systems daily without even realizing it. The field bridges computer science, electrical engineering, and domain-specific knowledge, requiring interdisciplinary expertise for effective design and implementation.",
        "trans_Question": "wɪ́tʃ kəmpjúwtɪŋ tɛknɒ́lədʒij rəfɜ́rz tə spɛ́ʃəlàjzd kəmpjúwtər sɪ́stəmz ðət ɑr dəzájnd tə pərfɔ́rm dɛ́dɪkejtɪd fʌ́ŋkʃənz wɪðɪ́n ə lɑ́rdʒər məkǽnɪkəl ɔr əlɛ́ktrɪkəl sɪ́stəm, ɔ́fən wɪð ríjəl-tájm ɒ̀pəréjʃənəl kənstréjnts?",
        "trans_RightAnswer": "ɛmbɛ́dɪd sɪ́stəmz",
        "trans_WrongAnswers": [
            "kláwd kəmpjúwtɪŋ",
            "dɪstrɪ́bjətɪd déjtəbèjsɪz",
            "vɜ́rtʃuwəl məʃíjnz",
            "pǽrəlɛ̀l prɒ́sɛsɪŋ",
            "kwɑ́ntəm kəmpjúwtɪŋ"
        ],
        "trans_Explanation": "ɛmbɛ́dɪd sɪ́stəmz ɑr spɛ́ʃəlàjzd kəmpjúwtɪŋ sɪ́stəmz ðət ɑr ɪ́ntəɡrejtɪd ɪntə lɑ́rdʒər dəvájsɪz ɔr prɒ́dəkts tə kəntrówl spəsɪ́fɪk fʌ́ŋkʃənz. ʌ̀nlájk dʒɛ́nərəl-pɜ́rpəs kəmpjúwtərz sʌtʃ æz lǽptɒ̀ps ɔr smɑ́rtfòwnz, ɛmbɛ́dɪd sɪ́stəmz ɑr dəzájnd fɔr dɛ́dɪkejtɪd tǽsks wɪð spəsɪ́fɪk rəkwájərmənts. ðej kən bij fáwnd ɪn ɛ́vrijθɪ̀ŋ frəm sɪ́mpəl dɪ́dʒɪtəl wɒ́tʃɪz, májkrəwèjv ʌ́vənz, ənd ɔ̀təmówtɪv kəntrówl sɪ́stəmz tə kɒ́mplɛks mɛ́dɪkəl əkwɪ́pmənt ənd ɪndʌ́strijəl rówbɒ̀ts. ðijz sɪ́stəmz tɪ́pɪkəlij kɒ́mbajn hɑ́rdwɛ̀ər ənd sɔ́ftwɛ̀ər kəmpównənts ɛ̀ndʒɪníjərd tə míjt strɪ́kt rəkwájərmənts fɔr rəlàjəbɪ́lɪtij, əfɪ́ʃənsij, sájz, ənd kɒ́st. ɛmbɛ́dɪd sɪ́stəmz ɔ́fən ɒ́pərèjt wɪð lɪ́mɪtɪd ríjsɔrsɪz (mɛ́mərij, prɒ́sɛsɪŋ páwər) ənd fríjkwəntlij níjd tə rəspɒ́nd ɪn ríjəl-tájm tə ənvàjərənmɛ́ntəl ɪ́npʊ̀ts. ðɛər juwbɪ́kwɪtij méjks ðɛm fʌ̀ndəmɛ́ntəl tə mɒ́dərn tɛknɒ́lədʒij - mówst píjpəl ɪ̀ntərǽkt wɪð dʌ́zənz əv ɛmbɛ́dɪd sɪ́stəmz déjlij wɪðáwt íjvən ríjəlàjzɪŋ ɪt. ðə fíjld brɪ́dʒɪz kəmpjúwtər sájəns, əlɛ́ktrɪkəl ɛ̀ndʒɪnɪ́ərɪŋ, ənd dowméjn-spəsɪ́fɪk nɒ́lɪdʒ, rijkwájərɪŋ ɪ̀ntərdɪ́sɪplənɛ̀ərij ɛ̀kspərtíjz fɔr əféktɪv dəzájn ənd ɪ̀mpləmɛntéjʃən."
    },
    {
        "Question": "Which computer system category guarantees that responses to input events will occur within specified time constraints, crucial for applications like aircraft control systems and medical devices?",
        "RightAnswer": "Real-time Systems",
        "WrongAnswers": [
            "Distributed Processing Systems",
            "Batch Processing Systems",
            "Time-sharing Systems",
            "Virtualized Computing Systems",
            "Cloud Computing Platforms"
        ],
        "Explanation": "Real-time Systems are specialized computing environments designed to process data and generate responses within guaranteed time constraints. Unlike conventional computing systems that prioritize throughput or average performance, real-time systems focus on predictability and meeting deadlines. They operate on the principle that the correctness of an operation depends not just on its logical outcome but also on the time at which it is delivered. These systems are categorized into hard real-time (where missing a deadline is considered a system failure) and soft real-time (where occasional missed deadlines are tolerable but undesirable). Real-time systems are essential in domains where timing is critical, such as industrial automation, vehicle control systems, medical devices, aerospace applications, and multimedia streaming. Their design requires careful attention to scheduling algorithms, interrupt handling, resource management, and often involves specialized hardware and operating systems to ensure deterministic behavior.",
        "trans_Question": "wɪ́tʃ kəmpjúwtər sɪ́stəm kǽtəɡɔ̀rij ɡɛ̀ərəntíjz ðət rəspɒ́nsɪz tə ɪ́npʊ̀t əvɛ́nts wɪl əkɜ́r wɪðɪ́n spɛ́sɪfàjd tájm kənstréjnts, krúwʃəl fɔr æ̀plɪkéjʃənz lájk ɛ́ərkræ̀ft kəntrówl sɪ́stəmz ənd mɛ́dɪkəl dəvájsɪz?",
        "trans_RightAnswer": "ríjəl-tájm sɪ́stəmz",
        "trans_WrongAnswers": [
            "dɪstrɪ́bjətɪd prɒ́sɛsɪŋ sɪ́stəmz",
            "bǽtʃ prɒ́sɛsɪŋ sɪ́stəmz",
            "tájm-ʃɛ́ərɪŋ sɪ́stəmz",
            "vɜ́rtʃuwəlajzd kəmpjúwtɪŋ sɪ́stəmz",
            "kláwd kəmpjúwtɪŋ plǽtfɔ̀rmz"
        ],
        "trans_Explanation": "ríjəl-tájm sɪ́stəmz ɑr spɛ́ʃəlàjzd kəmpjúwtɪŋ ənvájərənmənts dəzájnd tə prɒ́sɛs déjtə ənd dʒɛ́nərèjt rəspɒ́nsɪz wɪðɪ́n ɡɛ̀ərəntíjd tájm kənstréjnts. ʌ̀nlájk kənvɛ́nʃənəl kəmpjúwtɪŋ sɪ́stəmz ðət prajɔ́rɪtajz θrúwpʊ̀t ɔr ǽvərɪdʒ pərfɔ́rməns, ríjəl-tájm sɪ́stəmz fówkəs ɒn prədɪ̀ktəbɪ́lɪtij ənd míjtɪŋ dɛ́dlàjnz. ðej ɒ́pərèjt ɒn ðə prɪ́nsɪpəl ðət ðə kərɛ́ktnəs əv ən ɒ̀pəréjʃən dəpɛ́ndz nɒt dʒəst ɒn ɪts lɒ́dʒɪkəl áwtkʌ̀m bʌt ɔ́lsow ɒn ðə tájm æt wɪ́tʃ ɪt ɪz dəlɪ́vərd. ðijz sɪ́stəmz ɑr kǽtəɡəràjzd ɪntə hɑ́rd ríjəl-tájm (wɛ́ər mɪ́sɪŋ ə dɛ́dlàjn ɪz kənsɪ́dərd ə sɪ́stəm féjljər) ənd sɒ́ft ríjəl-tájm (wɛ́ər əkéjʒənəl mɪ́st dɛ́dlàjnz ɑr tɒ́lərəbəl bʌt ʌ̀ndəzájərəbəl). ríjəl-tájm sɪ́stəmz ɑr əsɛ́nʃəl ɪn dowméjnz wɛ́ər tájmɪŋ ɪz krɪ́tɪkəl, sʌtʃ æz ɪndʌ́strijəl ɔtəméjʃən, víjhəkəl kəntrówl sɪ́stəmz, mɛ́dɪkəl dəvájsɪz, ɛ́ərowspèjs æ̀plɪkéjʃənz, ənd mʌ̀ltijmíjdijə stríjmɪŋ. ðɛər dəzájn rəkwájərz kɛ́ərfəl ətɛ́nʃən tə skɛ́dʒuwlɪŋ ǽlɡərɪ̀ðəmz, ɪ̀ntərʌ́pt hǽndəlɪŋ, ríjsɔrs mǽnədʒmənt, ənd ɔ́fən ɪnvɒ́lvz spɛ́ʃəlàjzd hɑ́rdwɛ̀ər ənd ɒ́pərèjtɪŋ sɪ́stəmz tə ənʃʊ́r dətɜ̀rmɪnɪ́stɪk bəhéjvjər."
    },
    {
        "Question": "What is the compact computing device that integrates a processor core, memory, and programmable input/output peripherals on a single chip, often used in embedded systems?",
        "RightAnswer": "Microcontroller",
        "WrongAnswers": [
            "Graphics Processing Unit",
            "Application-Specific Integrated Circuit",
            "Memory Management Unit",
            "Field-Programmable Gate Array",
            "System on Module"
        ],
        "Explanation": "A microcontroller is a small, self-contained computing device that combines processing capability, memory resources, and input/output interfaces all within a single integrated circuit. Unlike general-purpose computers, microcontrollers are designed for specific tasks and embedded applications where efficiency, reliability, and low power consumption are crucial. They serve as the 'brains' behind countless electronic devices we use daily, from household appliances and automotive systems to industrial controls and medical devices. Microcontrollers typically run simple, dedicated programs stored in their internal memory, executing instructions to monitor inputs, process data according to programmed logic, and control outputs in real-time. Their architecture emphasizes practicality and functionality in space-constrained environments rather than raw computing power, making them the perfect solution for dedicated control applications where a full computer system would be excessive and impractical.",
        "trans_Question": "wɒt ɪz ðə kɒ́mpækt kəmpjúwtɪŋ dəvájs ðət ɪ́ntəɡrejts ə prɒ́sɛsər kɔ́r, mɛ́mərij, ənd prówɡræ̀məbəl ɪ́npʊ̀t/áwtpʊ̀t pərɪ́fərəlz ɒn ə sɪ́ŋɡəl tʃɪ́p, ɔ́fən júwzd ɪn ɛmbɛ́dɪd sɪ́stəmz?",
        "trans_RightAnswer": "májkrowkəntrówlər",
        "trans_WrongAnswers": [
            "ɡrǽfɪks prɒ́sɛsɪŋ júwnɪt",
            "æ̀plɪkéjʃən-spəsɪ́fɪk ɪ́ntəɡrejtɪd sɜ́rkət",
            "mɛ́mərij mǽnədʒmənt júwnɪt",
            "fíjld-prówɡræ̀məbəl ɡéjt əréj",
            "sɪ́stəm ɒn mɒ́dʒuwl"
        ],
        "trans_Explanation": "ə májkrowkəntrówlər ɪz ə smɔ́l, sɛ́lf-kəntéjnd kəmpjúwtɪŋ dəvájs ðət kəmbájnz prɒ́sɛsɪŋ kèjpəbɪ́lɪtij, mɛ́mərij ríjsɔrsɪz, ənd ɪ́npʊ̀t/áwtpʊ̀t ɪ́ntərfèjsɪz ɔl wɪðɪ́n ə sɪ́ŋɡəl ɪ́ntəɡrejtɪd sɜ́rkət. ʌ̀nlájk dʒɛ́nərəl-pɜ́rpəs kəmpjúwtərz, májkrowkəntrówlərz ɑr dəzájnd fɔr spəsɪ́fɪk tǽsks ənd ɛmbɛ́dɪd æ̀plɪkéjʃənz wɛ́ər əfɪ́ʃənsij, rəlàjəbɪ́lɪtij, ənd lów páwər kənsʌ́mpʃən ɑr krúwʃəl. ðej sɜ́rv æz ðə 'bréjnz' bəhájnd káwntləs ələktrɒ́nɪk dəvájsɪz wij juwz déjlij, frəm háwshòwld əplájənsɪz ənd ɔ̀təmówtɪv sɪ́stəmz tə ɪndʌ́strijəl kəntrówlz ənd mɛ́dɪkəl dəvájsɪz. májkrowkəntrówlərz tɪ́pɪkəlij rʌ́n sɪ́mpəl, dɛ́dɪkejtɪd prówɡræ̀mz stɔ́rd ɪn ðɛər ɪ̀ntɜ́rnəl mɛ́mərij, ɛ́ksəkjùwtɪŋ ɪnstrʌ́kʃənz tə mɒ́nɪtər ɪ́npʊ̀ts, prɒ́sɛs déjtə əkɔ́rdɪŋ tə prówɡræ̀md lɒ́dʒɪk, ənd kəntrówl áwtpʊ̀ts ɪn ríjəl-tájm. ðɛər ɑ́rkɪtɛ̀ktʃər ɛ́mfəsajzɪz præ̀ktɪkǽlɪtij ənd fʌ̀ŋkʃənǽlɪtij ɪn spéjs-kənstréjnd ənvájərənmənts rǽðər ðʌn rɔ́ kəmpjúwtɪŋ páwər, méjkɪŋ ðɛm ðə pɜ́rfəkt səlúwʃən fɔr dɛ́dɪkejtɪd kəntrówl æ̀plɪkéjʃənz wɛ́ər ə fʊ́l kəmpjúwtər sɪ́stəm wʊd bij əksɛ́sɪv ənd ɪ̀mprǽktɪkəl."
    },
    {
        "Question": "What foundational component of computer architecture is concerned with the theory and application of Boolean algebra, the implementation of binary operations, and the design of gates and circuits to manipulate bits?",
        "RightAnswer": "Digital Logic",
        "WrongAnswers": [
            "Memory Hierarchy",
            "Instruction Set Architecture",
            "Virtual Memory",
            "Operating System Kernel",
            "Compiler Theory"
        ],
        "Explanation": "Digital Logic is the fundamental building block of computer systems that deals with binary information processing. It encompasses the theory and practical implementation of circuits that perform operations on binary values (zeros and ones). At its core, Digital Logic uses Boolean algebra principles to design gates like AND, OR, and NOT that can be combined to create more complex circuits such as adders, multiplexers, and flip-flops. These circuits form the basis of all digital systems, from the arithmetic logic unit in your computer's processor to the control systems in modern appliances. Digital Logic provides the critical link between the physical electronic components and the abstract computational processes that make modern computing possible. Understanding Digital Logic is essential for grasping how computers can perform complex calculations and make decisions using only two states: on and off.",
        "trans_Question": "wɒt fawndéjʃənəl kəmpównənt əv kəmpjúwtər ɑ́rkɪtɛ̀ktʃər ɪz kənsɜ́rnd wɪð ðə θíjərij ənd æ̀plɪkéjʃən əv buwlíjən ǽldʒəbrə, ðə ɪ̀mpləmɛntéjʃən əv bájnərij ɒ̀pəréjʃənz, ənd ðə dəzájn əv ɡéjts ənd sɜ́rkəts tə mənɪ́pjəlèjt bɪ́ts?",
        "trans_RightAnswer": "dɪ́dʒɪtəl lɒ́dʒɪk",
        "trans_WrongAnswers": [
            "mɛ́mərij hájərɑ̀rkij",
            "ɪnstrʌ́kʃən sɛ́t ɑ́rkɪtɛ̀ktʃər",
            "vɜ́rtʃuwəl mɛ́mərij",
            "ɒ́pərèjtɪŋ sɪ́stəm kɜ́rnəl",
            "kəmpájlər θíjərij"
        ],
        "trans_Explanation": "dɪ́dʒɪtəl lɒ́dʒɪk ɪz ðə fʌ̀ndəmɛ́ntəl bɪ́ldɪŋ blɒ́k əv kəmpjúwtər sɪ́stəmz ðət díjlz wɪð bájnərij ɪnfərméjʃən prɒ́sɛsɪŋ. ɪt ɛnkʌ́mpəsɪz ðə θíjərij ənd prǽktɪkəl ɪ̀mpləmɛntéjʃən əv sɜ́rkəts ðət pərfɔ́rm ɒ̀pəréjʃənz ɒn bájnərij vǽljuwz (zɪ́ərowz ənd wʌ́nz). æt ɪts kɔ́r, dɪ́dʒɪtəl lɒ́dʒɪk júwsɪz buwlíjən ǽldʒəbrə prɪ́nsɪpəlz tə dəzájn ɡéjts lájk AND, OR, ənd NOT ðət kən bij kəmbájnd tə krijéjt mɔr kɒ́mplɛks sɜ́rkəts sʌtʃ æz ǽdərz, mʌ́ltijplɛ̀ksərz, ənd flɪ́p-flɒ́ps. ðijz sɜ́rkəts fɔ́rm ðə béjsɪs əv ɔl dɪ́dʒɪtəl sɪ́stəmz, frəm ðə ɛ̀ərɪθmɛ́tɪk lɒ́dʒɪk júwnɪt ɪn jɔr kəmpjúwtər'z prɒ́sɛsər tə ðə kəntrówl sɪ́stəmz ɪn mɒ́dərn əplájənsɪz. dɪ́dʒɪtəl lɒ́dʒɪk prəvájdz ðə krɪ́tɪkəl lɪ́ŋk bijtwíjn ðə fɪ́zɪkəl ələktrɒ́nɪk kəmpównənts ənd ðə ǽbstræ̀kt kɒ̀mpjuwtéjʃənəl prɒ́sɛsɪz ðət méjk mɒ́dərn kəmpjúwtɪŋ pɒ́sɪbəl. ʌ̀ndərstǽndɪŋ dɪ́dʒɪtəl lɒ́dʒɪk ɪz əsɛ́nʃəl fɔr ɡrǽspɪŋ háw kəmpjúwtərz kən pərfɔ́rm kɒ́mplɛks kæ̀lkjəléjʃənz ənd méjk dəsɪ́ʒənz júwzɪŋ ównlij túw stéjts: ɒn ənd ɔ́f."
    },
    {
        "Question": "What mathematical system, named after mathematician George Boole, forms the theoretical foundation for digital circuit design, logical operations, and is essential for understanding the fundamental operations of modern computers?",
        "RightAnswer": "Boolean Algebra",
        "WrongAnswers": [
            "Quantum Computation",
            "Linear Calculus",
            "Numerical Analysis",
            "Differential Logic",
            "Binary Arithmetic"
        ],
        "Explanation": "Boolean Algebra is a branch of mathematics that deals with operations on logical values and incorporates binary variables and logic operators. Developed by George Boole in the mid-19th century, it provides the mathematical foundation for digital electronics and computer science. Unlike traditional algebra that works with numerical values, Boolean Algebra operates with only two values: true and false (often represented as 1 and 0). It defines operations like AND, OR, and NOT that combine these values according to specific rules. These operations directly correspond to the logical gates that form the building blocks of computer hardware. Boolean Algebra allows computer scientists to design circuits, create logical expressions, analyze algorithms, and understand the fundamental operations that underpin all computing systems. Every search query, every condition in a program, and every digital circuit relies on Boolean logic, making it one of the most practical mathematical systems in our technology-driven world.",
        "trans_Question": "wɒt mæ̀θəmǽtɪkəl sɪ́stəm, néjmd ǽftər mæ̀θmətɪ́ʃən dʒɔ́rdʒ búwl, fɔ́rmz ðə θìjərɛ́tɪkəl fawndéjʃən fɔr dɪ́dʒɪtəl sɜ́rkət dəzájn, lɒ́dʒɪkəl ɒ̀pəréjʃənz, ənd ɪz əsɛ́nʃəl fɔr ʌ̀ndərstǽndɪŋ ðə fʌ̀ndəmɛ́ntəl ɒ̀pəréjʃənz əv mɒ́dərn kəmpjúwtərz?",
        "trans_RightAnswer": "buwlíjən ǽldʒəbrə",
        "trans_WrongAnswers": [
            "kwɑ́ntəm kɒ̀mpjətéjʃən",
            "lɪ́nijər kǽlkjələs",
            "njuwmɛ́ərɪkəl ənǽlɪsɪs",
            "dɪ̀fərɛ́nʃəl lɒ́dʒɪk",
            "bájnərij ɛ̀ərɪθmɛ́tɪk"
        ],
        "trans_Explanation": "buwlíjən ǽldʒəbrə ɪz ə brǽntʃ əv mæ̀θəmǽtɪks ðət díjlz wɪð ɒ̀pəréjʃənz ɒn lɒ́dʒɪkəl vǽljuwz ənd ɪnkɔ́rpərejts bájnərij vɛ́ərijəbəlz ənd lɒ́dʒɪk ɒ́pərèjtərz. dəvɛ́ləpt baj dʒɔ́rdʒ búwl ɪn ðə mɪ́d-19th sɛ́ntʃərij, ɪt prəvájdz ðə mæ̀θəmǽtɪkəl fawndéjʃən fɔr dɪ́dʒɪtəl ələktrɒ́nɪks ənd kəmpjúwtər sájəns. ʌ̀nlájk trədɪ́ʃənəl ǽldʒəbrə ðət wɜ́rks wɪð njuwmɛ́ərɪkəl vǽljuwz, buwlíjən ǽldʒəbrə ɒ́pərèjts wɪð ównlij túw vǽljuwz: trúw ənd fɔ́ls (ɔ́fən rɛ̀prəzɛ́ntɪd æz 1 ənd 0). ɪt dəfájnz ɒ̀pəréjʃənz lájk AND, OR, ənd NOT ðət kɒ́mbajn ðijz vǽljuwz əkɔ́rdɪŋ tə spəsɪ́fɪk rúwlz. ðijz ɒ̀pəréjʃənz dɪərɛ́klij kɔ̀rəspɒ́nd tə ðə lɒ́dʒɪkəl ɡéjts ðət fɔ́rm ðə bɪ́ldɪŋ blɒ́ks əv kəmpjúwtər hɑ́rdwɛ̀ər. buwlíjən ǽldʒəbrə əláwz kəmpjúwtər sájəntɪsts tə dəzájn sɜ́rkəts, krijéjt lɒ́dʒɪkəl əksprɛ́ʃənz, ǽnəlàjz ǽlɡərɪ̀ðəmz, ənd ʌ̀ndərstǽnd ðə fʌ̀ndəmɛ́ntəl ɒ̀pəréjʃənz ðət ʌ́ndərpɪ̀n ɔl kəmpjúwtɪŋ sɪ́stəmz. ɛvərij sɜ́rtʃ kwɛ́ərij, ɛvərij kəndɪ́ʃən ɪn ə prówɡræ̀m, ənd ɛvərij dɪ́dʒɪtəl sɜ́rkət rəlájz ɒn buwlíjən lɒ́dʒɪk, méjkɪŋ ɪt wʌ́n əv ðə mówst prǽktɪkəl mæ̀θəmǽtɪkəl sɪ́stəmz ɪn awər tɛknɒ́lədʒij-drɪ́vən wɜ́rld."
    },
    {
        "Question": "What fundamental components in computer architecture serve as the building blocks for digital circuits, performing binary operations like AND, OR, and NOT on input signals to produce specific outputs?",
        "RightAnswer": "Logic Gates",
        "WrongAnswers": [
            "Memory Registers",
            "Bus Controllers",
            "Instruction Decoders",
            "Clock Oscillators",
            "Cache Units"
        ],
        "Explanation": "Logic Gates are the fundamental building blocks of digital circuits and computer systems. These electronic components implement Boolean logic operations, taking one or more binary inputs (signals that are either 0 or 1) and producing a single binary output according to predefined logical rules. The most common logic gates include AND (outputs 1 only when all inputs are 1), OR (outputs 1 if at least one input is 1), NOT (inverts the input), XOR (outputs 1 when inputs differ), NAND (negated AND), and NOR (negated OR). By combining these simple elements in various arrangements, engineers can create complex digital systems capable of performing arithmetic operations, storing information, and making decisions—essentially enabling all the functionality we associate with modern computing. From the simplest calculator to the most powerful supercomputer, logic gates form the foundation upon which all digital technology is built.",
        "trans_Question": "wɒt fʌ̀ndəmɛ́ntəl kəmpównənts ɪn kəmpjúwtər ɑ́rkɪtɛ̀ktʃər sɜ́rv æz ðə bɪ́ldɪŋ blɒ́ks fɔr dɪ́dʒɪtəl sɜ́rkəts, pərfɔ́rmɪŋ bájnərij ɒ̀pəréjʃənz lájk AND, OR, ənd NOT ɒn ɪ́npʊ̀t sɪ́ɡnəlz tə prədúws spəsɪ́fɪk áwtpʊ̀ts?",
        "trans_RightAnswer": "lɒ́dʒɪk ɡéjts",
        "trans_WrongAnswers": [
            "mɛ́mərij rɛ́dʒəstərz",
            "bʌ́s kəntrówlərz",
            "ɪnstrʌ́kʃən dəkówdərz",
            "klɒ́k ɒ́səlèjtərz",
            "kǽʃ júwnɪts"
        ],
        "trans_Explanation": "lɒ́dʒɪk ɡéjts ɑr ðə fʌ̀ndəmɛ́ntəl bɪ́ldɪŋ blɒ́ks əv dɪ́dʒɪtəl sɜ́rkəts ənd kəmpjúwtər sɪ́stəmz. ðijz ələktrɒ́nɪk kəmpównənts ɪ́mpləmənt buwlíjən lɒ́dʒɪk ɒ̀pəréjʃənz, téjkɪŋ wʌ́n ɔr mɔr bájnərij ɪ́npʊ̀ts (sɪ́ɡnəlz ðət ɑr ájðər 0 ɔr 1) ənd prədúwsɪŋ ə sɪ́ŋɡəl bájnərij áwtpʊ̀t əkɔ́rdɪŋ tə prìjdəfájnd lɒ́dʒɪkəl rúwlz. ðə mówst kɒ́mən lɒ́dʒɪk ɡéjts ɪnklúwd AND (áwtpʊ̀ts 1 ównlij wɛ́n ɔl ɪ́npʊ̀ts ɑr 1), OR (áwtpʊ̀ts 1 ɪf æt líjst wʌ́n ɪ́npʊ̀t ɪz 1), NOT (ɪnvɜ́rts ðə ɪ́npʊ̀t), XOR (áwtpʊ̀ts 1 wɛ́n ɪ́npʊ̀ts dɪ́fər), NAND (níjɡejtɪd AND), ənd NOR (níjɡejtɪd OR). baj kəmbájnɪŋ ðijz sɪ́mpəl ɛ́ləmənts ɪn vɛ́ərijəs əréjndʒmənts, ɛ̀ndʒɪnɪ́ərz kən krijéjt kɒ́mplɛks dɪ́dʒɪtəl sɪ́stəmz kéjpəbəl əv pərfɔ́rmɪŋ ɛ̀ərɪθmɛ́tɪk ɒ̀pəréjʃənz, stɔ́rɪŋ ɪnfərméjʃən, ənd méjkɪŋ dəsɪ́ʒənz—əsɛ́nʃəlij ɛnéjbəlɪŋ ɔl ðə fʌ̀ŋkʃənǽlɪtij wij əsówsijejt wɪð mɒ́dərn kəmpjúwtɪŋ. frəm ðə sɪ́mpləst kǽlkjəlèjtər tə ðə mówst páwərfəl sùwpərkəmpjúwtər, lɒ́dʒɪk ɡéjts fɔ́rm ðə fawndéjʃən əpɒ́n wɪ́tʃ ɔl dɪ́dʒɪtəl tɛknɒ́lədʒij ɪz bɪ́lt."
    },
    {
        "Question": "In digital circuit design, which term describes a type of logic circuit whose output is purely a function of its current inputs, with no memory of previous states?",
        "RightAnswer": "Combinational Logic",
        "WrongAnswers": [
            "Sequential Logic",
            "Temporal Logic",
            "Imperative Logic",
            "State Machine Logic",
            "Recursive Logic"
        ],
        "Explanation": "Combinational Logic refers to digital circuits whose outputs depend exclusively on the current values of their inputs, with no dependency on past inputs or states. Unlike sequential logic, combinational logic circuits do not have memory elements or feedback loops. They process data using components such as AND gates, OR gates, and NOT gates to perform operations like addition, multiplication, and comparison. Common examples include multiplexers, decoders, and arithmetic logic units. The term 'combinational' reflects how these circuits combine multiple input signals through logic gates to produce specific output results. This type of logic forms the foundation for many computational operations in processors and digital systems, where immediate transformation of inputs to outputs is required without considering historical information.",
        "trans_Question": "ɪn dɪ́dʒɪtəl sɜ́rkət dəzájn, wɪ́tʃ tɜ́rm dəskrájbz ə tájp əv lɒ́dʒɪk sɜ́rkət húwz áwtpʊ̀t ɪz pjʊ́rlij ə fʌ́ŋkʃən əv ɪts kɑ́rənt ɪ́npʊ̀ts, wɪð now mɛ́mərij əv príjvijəs stéjts?",
        "trans_RightAnswer": "kəmbɪ̀néjʃənəl lɒ́dʒɪk",
        "trans_WrongAnswers": [
            "səkwɛ́nʃəl lɒ́dʒɪk",
            "tɛ́mpərəl lɒ́dʒɪk",
            "ɪ̀mpɛ́ərətɪv lɒ́dʒɪk",
            "stéjt məʃíjn lɒ́dʒɪk",
            "rəkɜ́rsɪv lɒ́dʒɪk"
        ],
        "trans_Explanation": "kəmbɪ̀néjʃənəl lɒ́dʒɪk rəfɜ́rz tə dɪ́dʒɪtəl sɜ́rkəts húwz áwtpʊ̀ts dəpɛ́nd əksklúwsɪvlij ɒn ðə kɑ́rənt vǽljuwz əv ðɛər ɪ́npʊ̀ts, wɪð now dəpɛ́ndənsij ɒn pǽst ɪ́npʊ̀ts ɔr stéjts. ʌ̀nlájk səkwɛ́nʃəl lɒ́dʒɪk, kəmbɪ̀néjʃənəl lɒ́dʒɪk sɜ́rkəts dúw nɒt həv mɛ́mərij ɛ́ləmənts ɔr fíjdbæ̀k lúwps. ðej prɒ́sɛs déjtə júwzɪŋ kəmpównənts sʌtʃ æz AND ɡéjts, OR ɡéjts, ənd NOT ɡéjts tə pərfɔ́rm ɒ̀pəréjʃənz lájk ədɪ́ʃən, mʌ̀ltijpləkéjʃən, ənd kəmpɛ́ərɪsən. kɒ́mən əɡzǽmpəlz ɪnklúwd mʌ́ltijplɛ̀ksərz, dəkówdərz, ənd ɛ̀ərɪθmɛ́tɪk lɒ́dʒɪk júwnɪts. ðə tɜ́rm 'kəmbɪ̀néjʃənəl' rəflɛ́kts háw ðijz sɜ́rkəts kɒ́mbajn mʌ́ltɪpəl ɪ́npʊ̀t sɪ́ɡnəlz θrúw lɒ́dʒɪk ɡéjts tə prədúws spəsɪ́fɪk áwtpʊ̀t rəzʌ́lts. ðɪs tájp əv lɒ́dʒɪk fɔ́rmz ðə fawndéjʃən fɔr mɛ́nij kɒ̀mpjuwtéjʃənəl ɒ̀pəréjʃənz ɪn prɒ́sɛsərz ənd dɪ́dʒɪtəl sɪ́stəmz, wɛ́ər ɪmíjdijət træ̀nsfərméjʃən əv ɪ́npʊ̀ts tə áwtpʊ̀ts ɪz rəkwájərd wɪðáwt kənsɪ́dərɪŋ hɪstɔ́rɪkəl ɪnfərméjʃən."
    },
    {
        "Question": "Which digital logic system uses memory elements to store information about previous inputs and produces outputs based on both current and past inputs?",
        "RightAnswer": "Sequential Logic",
        "WrongAnswers": [
            "Combinational Logic",
            "Parallel Processing",
            "Asynchronous Logic",
            "Boolean Algebra",
            "Pipeline Architecture"
        ],
        "Explanation": "Sequential Logic is a fundamental concept in computer science that describes digital circuits whose outputs depend not only on the current inputs but also on the history of inputs. Unlike combinational logic, sequential logic has memory and can remember previous states. This memory is implemented using flip-flops or latches that store binary information. Sequential logic forms the basis for registers, counters, memory units, and state machines in digital systems. It enables computers to perform complex operations that require tracking progress over time, such as executing program instructions in sequence or implementing algorithms that require multiple steps. Sequential logic circuits typically operate with a clock signal that synchronizes when state changes occur, making them essential building blocks for creating computers and other digital systems that can perform sophisticated tasks.",
        "trans_Question": "wɪ́tʃ dɪ́dʒɪtəl lɒ́dʒɪk sɪ́stəm júwsɪz mɛ́mərij ɛ́ləmənts tə stɔ́r ɪnfərméjʃən əbawt príjvijəs ɪ́npʊ̀ts ənd prədúwsɪz áwtpʊ̀ts béjst ɒn bówθ kɑ́rənt ənd pǽst ɪ́npʊ̀ts?",
        "trans_RightAnswer": "səkwɛ́nʃəl lɒ́dʒɪk",
        "trans_WrongAnswers": [
            "kəmbɪ̀néjʃənəl lɒ́dʒɪk",
            "pǽrəlɛ̀l prɒ́sɛsɪŋ",
            "éjsɪ́ŋkrənəs lɒ́dʒɪk",
            "buwlíjən ǽldʒəbrə",
            "pájplàjn ɑ́rkɪtɛ̀ktʃər"
        ],
        "trans_Explanation": "səkwɛ́nʃəl lɒ́dʒɪk ɪz ə fʌ̀ndəmɛ́ntəl kɒ́nsɛpt ɪn kəmpjúwtər sájəns ðət dəskrájbz dɪ́dʒɪtəl sɜ́rkəts húwz áwtpʊ̀ts dəpɛ́nd nɒt ównlij ɒn ðə kɑ́rənt ɪ́npʊ̀ts bʌt ɔ́lsow ɒn ðə hɪ́stərij əv ɪ́npʊ̀ts. ʌ̀nlájk kəmbɪ̀néjʃənəl lɒ́dʒɪk, səkwɛ́nʃəl lɒ́dʒɪk həz mɛ́mərij ənd kən rəmɛ́mbər príjvijəs stéjts. ðɪs mɛ́mərij ɪz ɪ́mpləmɛ̀ntɪd júwzɪŋ flɪ́p-flɒ́ps ɔr lǽtʃɪz ðət stɔ́r bájnərij ɪnfərméjʃən. səkwɛ́nʃəl lɒ́dʒɪk fɔ́rmz ðə béjsɪs fɔr rɛ́dʒəstərz, káwntərz, mɛ́mərij júwnɪts, ənd stéjt məʃíjnz ɪn dɪ́dʒɪtəl sɪ́stəmz. ɪt ɛnéjbəlz kəmpjúwtərz tə pərfɔ́rm kɒ́mplɛks ɒ̀pəréjʃənz ðət rəkwájər trǽkɪŋ prɒ́ɡrɛ̀s ówvər tájm, sʌtʃ æz ɛ́ksəkjùwtɪŋ prówɡræ̀m ɪnstrʌ́kʃənz ɪn síjkwəns ɔr ɪ́mpləmɛ̀ntɪŋ ǽlɡərɪ̀ðəmz ðət rəkwájər mʌ́ltɪpəl stɛ́ps. səkwɛ́nʃəl lɒ́dʒɪk sɜ́rkəts tɪ́pɪkəlij ɒ́pərèjt wɪð ə klɒ́k sɪ́ɡnəl ðət sɪ́ŋkrənàjzɪz wɛ́n stéjt tʃéjndʒɪz əkɜ́r, méjkɪŋ ðɛm əsɛ́nʃəl bɪ́ldɪŋ blɒ́ks fɔr krijéjtɪŋ kəmpjúwtərz ənd ʌ́ðər dɪ́dʒɪtəl sɪ́stəmz ðət kən pərfɔ́rm səfɪ́stɪkèjtɪd tǽsks."
    },
    {
        "Question": "In computer science, which computational model consists of a set of states, transitions between those states, and actions, used to design algorithms and recognize patterns in data?",
        "RightAnswer": "Finite State Machine (FSM)",
        "WrongAnswers": [
            "Binary Search Tree (BST)",
            "Hash Table Algorithm",
            "Neural Network Architecture",
            "Dynamic Programming Framework",
            "Greedy Algorithm Method"
        ],
        "Explanation": "A Finite State Machine (FSM) is a computational model that represents a system which can be in exactly one of a finite number of states at any given time. The machine can transition from one state to another in response to inputs, and these transitions are governed by a set of predefined rules. FSMs are widely used in computer science for designing algorithms, parsing text, controlling game character behavior, implementing protocols, and recognizing patterns. They are particularly valuable for systems where behavior depends on both current input and previous history. The beauty of FSMs lies in their simplicity and clarity, making complex behaviors easier to visualize, implement, and debug. They can be represented visually as diagrams with nodes (states) connected by edges (transitions), making them accessible even to those new to computer science concepts.",
        "trans_Question": "ɪn kəmpjúwtər sájəns, wɪ́tʃ kɒ̀mpjuwtéjʃənəl mɒ́dəl kənsɪ́sts əv ə sɛ́t əv stéjts, trænzɪ́ʃənz bijtwíjn ðowz stéjts, ənd ǽkʃənz, júwzd tə dəzájn ǽlɡərɪ̀ðəmz ənd rɛ́kəɡnàjz pǽtərnz ɪn déjtə?",
        "trans_RightAnswer": "fájnàjt stéjt məʃíjn (FSM)",
        "trans_WrongAnswers": [
            "bájnərij sɜ́rtʃ tríj (BST)",
            "hǽʃ téjbəl ǽlɡərɪ̀ðəm",
            "nʊ́rəl nɛ́twɜ̀rk ɑ́rkɪtɛ̀ktʃər",
            "dajnǽmɪk prówɡræ̀mɪŋ fréjmwɜ̀rk",
            "ɡríjdij ǽlɡərɪ̀ðəm mɛ́θəd"
        ],
        "trans_Explanation": "ə fájnàjt stéjt məʃíjn (FSM) ɪz ə kɒ̀mpjuwtéjʃənəl mɒ́dəl ðət rɛ̀prəzɛ́nts ə sɪ́stəm wɪ́tʃ kən bij ɪn əɡzǽktlij wʌ́n əv ə fájnàjt nʌ́mbər əv stéjts æt ɛ́nij ɡɪ́vən tájm. ðə məʃíjn kən trænzɪ́ʃən frəm wʌ́n stéjt tə ənʌ́ðər ɪn rəspɒ́ns tə ɪ́npʊ̀ts, ənd ðijz trænzɪ́ʃənz ɑr ɡʌ́vərnd baj ə sɛ́t əv prìjdəfájnd rúwlz. FSMS ɑr wájdlij júwzd ɪn kəmpjúwtər sájəns fɔr dəzájnɪŋ ǽlɡərɪ̀ðəmz, pɑ́rsɪŋ tɛ́kst, kəntrówlɪŋ ɡéjm kǽrəktər bəhéjvjər, ɪ́mpləmɛ̀ntɪŋ prówtəkɔ̀lz, ənd rɛ́kəɡnàjzɪŋ pǽtərnz. ðej ɑr pərtɪ́kjələrlij vǽljəbəl fɔr sɪ́stəmz wɛ́ər bəhéjvjər dəpɛ́ndz ɒn bówθ kɑ́rənt ɪ́npʊ̀t ənd príjvijəs hɪ́stərij. ðə bjúwtij əv FSMS lájz ɪn ðɛər sɪmplɪ́sɪtij ənd klɛ́ərɪtij, méjkɪŋ kɒ́mplɛks bəhéjvjərz íjzijər tə vɪ́ʒwəlàjz, ɪ́mpləmənt, ənd dijbʌ́ɡ. ðej kən bij rɛ̀prəzɛ́ntɪd vɪ́ʒwəlij æz dájəɡræ̀mz wɪð nówdz (stéjts) kənɛ́ktɪd baj ɛ́dʒɪz (trænzɪ́ʃənz), méjkɪŋ ðɛm æksɛ́sɪbəl íjvən tə ðowz núw tə kəmpjúwtər sájəns kɒ́nsɛpts."
    },
    {
        "Question": "Which computing technique divides tasks into multiple smaller subtasks that can be executed simultaneously across multiple processors to significantly reduce overall processing time?",
        "RightAnswer": "Parallel Processing",
        "WrongAnswers": [
            "Sequential Computing",
            "Batch Processing",
            "Time Sharing",
            "Distributed Queueing",
            "Linear Execution"
        ],
        "Explanation": "Parallel Processing is a computing approach that breaks down complex computational tasks into smaller subtasks that can be executed simultaneously across multiple processors or computing cores. Unlike traditional sequential processing where tasks are completed one after another, parallel processing allows multiple operations to occur at the same time, significantly improving efficiency and reducing execution time. This technique is particularly valuable for computationally intensive tasks like scientific simulations, data analysis, graphics rendering, and artificial intelligence applications. Modern computing systems, from multicore processors in everyday laptops to massive supercomputers, leverage parallel processing to handle increasingly complex workloads. The primary challenge in parallel processing involves effectively dividing tasks and managing the communication between processors to ensure they work together efficiently without conflicts.",
        "trans_Question": "wɪ́tʃ kəmpjúwtɪŋ tɛkníjk dɪvájdz tǽsks ɪntə mʌ́ltɪpəl smɔ́lər sʌ́btæ̀sks ðət kən bij ɛ́ksəkjùwtɪd sàjməltéjnijəslij əkrɔ́s mʌ́ltɪpəl prɒ́sɛsərz tə sɪɡnɪ́fɪkəntlij rədjúws ówvərɔ̀l prɒ́sɛsɪŋ tájm?",
        "trans_RightAnswer": "pǽrəlɛ̀l prɒ́sɛsɪŋ",
        "trans_WrongAnswers": [
            "səkwɛ́nʃəl kəmpjúwtɪŋ",
            "bǽtʃ prɒ́sɛsɪŋ",
            "tájm ʃɛ́ərɪŋ",
            "dɪstrɪ́bjətɪd kjúwɪŋ",
            "lɪ́nijər ɛ̀ksəkjúwʃən"
        ],
        "trans_Explanation": "pǽrəlɛ̀l prɒ́sɛsɪŋ ɪz ə kəmpjúwtɪŋ əprówtʃ ðət bréjks dawn kɒ́mplɛks kɒ̀mpjuwtéjʃənəl tǽsks ɪntə smɔ́lər sʌ́btæ̀sks ðət kən bij ɛ́ksəkjùwtɪd sàjməltéjnijəslij əkrɔ́s mʌ́ltɪpəl prɒ́sɛsərz ɔr kəmpjúwtɪŋ kɔ́rz. ʌ̀nlájk trədɪ́ʃənəl səkwɛ́nʃəl prɒ́sɛsɪŋ wɛ́ər tǽsks ɑr kəmplíjtɪd wʌ́n ǽftər ənʌ́ðər, pǽrəlɛ̀l prɒ́sɛsɪŋ əláwz mʌ́ltɪpəl ɒ̀pəréjʃənz tə əkɜ́r æt ðə séjm tájm, sɪɡnɪ́fɪkəntlij ɪmprúwvɪŋ əfɪ́ʃənsij ənd rədjúwsɪŋ ɛ̀ksəkjúwʃən tájm. ðɪs tɛkníjk ɪz pərtɪ́kjələrlij vǽljəbəl fɔr kɒ̀mpjətéjʃənəlij ɪntɛ́nsɪv tǽsks lájk sàjəntɪ́fɪk sɪ̀mjəléjʃənz, déjtə ənǽlɪsɪs, ɡrǽfɪks rɛ́ndərɪŋ, ənd ɑ̀rtɪfɪ́ʃəl ɪntɛ́lɪdʒəns æ̀plɪkéjʃənz. mɒ́dərn kəmpjúwtɪŋ sɪ́stəmz, frəm mʌ́ltijkɔ̀r prɒ́sɛsərz ɪn ɛ́vrijdéj lǽptɒ̀ps tə mǽsɪv sùwpərkəmpjúwtərz, lɛ́vərɪdʒ pǽrəlɛ̀l prɒ́sɛsɪŋ tə hǽndəl ɪnkríjsɪŋɡlij kɒ́mplɛks wɜ́rklòwdz. ðə prájmɛ̀ərij tʃǽləndʒ ɪn pǽrəlɛ̀l prɒ́sɛsɪŋ ɪnvɒ́lvz əfɛ́ktɪvlij dɪvájdɪŋ tǽsks ənd mǽnɪdʒɪŋ ðə kəmjùwnɪkéjʃən bijtwíjn prɒ́sɛsərz tə ənʃʊ́r ðej wɜ́rk təɡɛ́ðər əfɪ́ʃəntlij wɪðáwt kɒ́nflɪkts."
    },
    {
        "Question": "What parallel computing platform and programming model developed by NVIDIA allows developers to dramatically speed up computing applications by harnessing the power of graphics processing units (GPUs)?",
        "RightAnswer": "CUDA",
        "WrongAnswers": [
            "OpenMP",
            "Vulkan",
            "DirectX",
            "SIMD",
            "MPI"
        ],
        "Explanation": "CUDA, which stands for Compute Unified Device Architecture, is a parallel computing platform and programming model created by NVIDIA. It enables developers to use NVIDIA GPUs for general purpose processing, a technique known as GPGPU (General-Purpose computing on Graphics Processing Units). CUDA provides developers with direct access to the GPU's virtual instruction set and memory, allowing them to write code that executes on the thousands of cores inside modern GPUs. This massively parallel architecture is particularly effective for tasks that can be broken down into many independent calculations, such as scientific simulations, deep learning, image processing, and cryptocurrency mining. By leveraging CUDA, applications can achieve significant performance improvements compared to CPU-only implementations, sometimes accelerating computations by orders of magnitude. Since its introduction in 2007, CUDA has become widely adopted in high-performance computing environments, research institutions, and industries where computational speed is critical.",
        "trans_Question": "wɒt pǽrəlɛ̀l kəmpjúwtɪŋ plǽtfɔ̀rm ənd prówɡræ̀mɪŋ mɒ́dəl dəvɛ́ləpt baj NVIDIA əláwz dəvɛ́ləpərz tə drəmǽtɪkəlij spíjd ʌp kəmpjúwtɪŋ æ̀plɪkéjʃənz baj hɑ́rnəsɪŋ ðə páwər əv ɡrǽfɪks prɒ́sɛsɪŋ júwnɪts (ɡíjpijúwz)?",
        "trans_RightAnswer": "CUDA",
        "trans_WrongAnswers": [
            "owpən",
            "vʌ́lkæn",
            "dajərɛ́ktɛks",
            "SIMD",
            "MPI"
        ],
        "trans_Explanation": "CUDA, wɪ́tʃ stǽndz fɔr kəmpjúwt júwnɪfàjd dəvájs ɑ́rkɪtɛ̀ktʃər, ɪz ə pǽrəlɛ̀l kəmpjúwtɪŋ plǽtfɔ̀rm ənd prówɡræ̀mɪŋ mɒ́dəl krijéjtɪd baj NVIDIA. ɪt ɛnéjbəlz dəvɛ́ləpərz tə juwz NVIDIA ɡíjpijúwz fɔr dʒɛ́nərəl pɜ́rpəs prɒ́sɛsɪŋ, ə tɛkníjk nówn æz GPGPU (dʒɛ́nərəl-pɜ́rpəs kəmpjúwtɪŋ ɒn ɡrǽfɪks prɒ́sɛsɪŋ júwnɪts). CUDA prəvájdz dəvɛ́ləpərz wɪð dɪərɛ́kt ǽksɛ̀s tə ðə GPU'z vɜ́rtʃuwəl ɪnstrʌ́kʃən sɛ́t ənd mɛ́mərij, əláwɪŋ ðɛm tə rájt kówd ðət ɛ́ksəkjùwts ɒn ðə θáwzəndz əv kɔ́rz ɪnsájd mɒ́dərn ɡíjpijúwz. ðɪs mǽsɪvlij pǽrəlɛ̀l ɑ́rkɪtɛ̀ktʃər ɪz pərtɪ́kjələrlij əféktɪv fɔr tǽsks ðət kən bij brówkən dawn ɪntə mɛ́nij ɪndəpɛ́ndənt kæ̀lkjəléjʃənz, sʌtʃ æz sàjəntɪ́fɪk sɪ̀mjəléjʃənz, díjp lɜ́rnɪŋ, ɪ́mɪdʒ prɒ́sɛsɪŋ, ənd krɪptówkərənsij májnɪŋ. baj lɛ́vərɪdʒɪŋ CUDA, æ̀plɪkéjʃənz kən ətʃíjv sɪɡnɪ́fɪkənt pərfɔ́rməns ɪmprúwvmənts kəmpɛ́ərd tə sìjpìjúw-ównlij ɪ̀mpləmɛntéjʃənz, sʌ́mtàjmz æksɛ́lərèjtɪŋ kɒ̀mpjuwtéjʃənz baj ɔ́rdərz əv mǽɡnɪtùwd. sɪns ɪts ɪntrədʌ́kʃən ɪn 2007, CUDA həz bəkʌ́m wájdlij ədɒ́ptɪd ɪn háj-pərfɔ́rməns kəmpjúwtɪŋ ənvájərənmənts, ríjsərtʃ ɪnstɪtúwʃənz, ənd ɪ́ndəstrijz wɛ́ər kɒ̀mpjuwtéjʃənəl spíjd ɪz krɪ́tɪkəl."
    },
    {
        "Question": "Which low-level programming language uses mnemonics to represent machine code instructions, providing a more human-readable way to write programs that directly interact with computer hardware?",
        "RightAnswer": "Assembly Language",
        "WrongAnswers": [
            "Machine Language",
            "Bytecode",
            "Microcode",
            "Hardware Description Language",
            "Firmware Language"
        ],
        "Explanation": "Assembly Language is a low-level programming language that serves as a bridge between human-readable code and machine code. Unlike high-level languages such as Python or Java, assembly language has a nearly one-to-one correspondence with the machine code instructions that the computer processor executes directly. Instead of using binary digits, assembly language uses mnemonic codes like MOV, ADD, and JMP to represent operations, along with registers and memory addresses. Programmers use assembly language when they need precise control over hardware, maximum execution speed, or minimal memory usage. While it offers granular control, assembly language is specific to a particular computer architecture, making programs less portable across different systems. Assembly code must be converted to machine code by a program called an assembler before the computer can execute it. Despite being challenging to write and maintain, assembly language remains essential in areas like device drivers, operating system kernels, and performance-critical applications.",
        "trans_Question": "wɪ́tʃ lów-lɛ́vəl prówɡræ̀mɪŋ lǽŋɡwədʒ júwsɪz nəmɒ́nɪks tə rɛ̀prəzɛ́nt məʃíjn kówd ɪnstrʌ́kʃənz, prəvájdɪŋ ə mɔr hjúwmən-ríjdəbəl wej tə rájt prówɡræ̀mz ðət dɪərɛ́klij ɪ̀ntərǽkt wɪð kəmpjúwtər hɑ́rdwɛ̀ər?",
        "trans_RightAnswer": "əsɛ́mblij lǽŋɡwədʒ",
        "trans_WrongAnswers": [
            "məʃíjn lǽŋɡwədʒ",
            "bájtkòwd",
            "májkrowkòwd",
            "hɑ́rdwɛ̀ər dəskrɪ́pʃən lǽŋɡwədʒ",
            "fɜ́rmwɛ̀ər lǽŋɡwədʒ"
        ],
        "trans_Explanation": "əsɛ́mblij lǽŋɡwədʒ ɪz ə lów-lɛ́vəl prówɡræ̀mɪŋ lǽŋɡwədʒ ðət sɜ́rvz æz ə brɪ́dʒ bijtwíjn hjúwmən-ríjdəbəl kówd ənd məʃíjn kówd. ʌ̀nlájk háj-lɛ́vəl lǽŋɡwədʒɪz sʌtʃ æz pájθɒn ɔr dʒɒ́və, əsɛ́mblij lǽŋɡwədʒ həz ə nɪ́ərlij wʌ́n-tə-wʌ́n kɔ̀rəspɒ́ndəns wɪð ðə məʃíjn kówd ɪnstrʌ́kʃənz ðət ðə kəmpjúwtər prɒ́sɛsər ɛ́ksəkjùwts dɪərɛ́klij. ɪnstɛ́d əv júwzɪŋ bájnərij dɪ́dʒɪts, əsɛ́mblij lǽŋɡwədʒ júwsɪz nəmɒ́nɪk kówdz lájk MOV, ADD, ənd JMP tə rɛ̀prəzɛ́nt ɒ̀pəréjʃənz, əlɔ́ŋ wɪð rɛ́dʒəstərz ənd mɛ́mərij ǽdrɛ́sɪz. prówɡræ̀mərz juwz əsɛ́mblij lǽŋɡwədʒ wɛ́n ðej níjd prəsájs kəntrówl ówvər hɑ́rdwɛ̀ər, mǽksɪməm ɛ̀ksəkjúwʃən spíjd, ɔr mɪ́nɪməl mɛ́mərij júwsɪdʒ. wájl ɪt ɔ́fərz ɡrǽnjələr kəntrówl, əsɛ́mblij lǽŋɡwədʒ ɪz spəsɪ́fɪk tə ə pərtɪ́kjələr kəmpjúwtər ɑ́rkɪtɛ̀ktʃər, méjkɪŋ prówɡræ̀mz lɛ́s pɔ́rtəbəl əkrɔ́s dɪ́fərənt sɪ́stəmz. əsɛ́mblij kówd mʌst bij kənvɜ́rtɪd tə məʃíjn kówd baj ə prówɡræ̀m kɔ́ld ən əsɛ́mblər bəfɔ́r ðə kəmpjúwtər kən ɛ́ksəkjùwt ɪt. dəspájt bíjɪŋ tʃǽləndʒɪŋ tə rájt ənd mejntéjn, əsɛ́mblij lǽŋɡwədʒ rəméjnz əsɛ́nʃəl ɪn ɛ́ərijəz lájk dəvájs drájvərz, ɒ́pərèjtɪŋ sɪ́stəm kɜ́rnəlz, ənd pərfɔ́rməns-krɪ́tɪkəl æ̀plɪkéjʃənz."
    },
    {
        "Question": "What is the name of the specialized software that transforms high-level programming code written by developers into machine code that can be directly executed by a computer's processor?",
        "RightAnswer": "Compiler",
        "WrongAnswers": [
            "Interpreter",
            "Assembler",
            "Debugger",
            "Runtime Environment",
            "Linker"
        ],
        "Explanation": "A compiler is a crucial tool in software development that translates human-readable source code written in programming languages like C++, Java, or Rust into machine code or object code that computers can directly execute. Unlike interpreters which translate and execute code line by line, compilers process the entire program at once, performing various optimizations along the way. The compilation process involves several stages including lexical analysis, syntax parsing, semantic analysis, code optimization, and code generation. This transformation allows programmers to write code in more intuitive, higher-level languages while still achieving the performance benefits of machine-specific instructions. Modern compilers not only translate code but also provide error checking, security features, and performance optimizations that would be difficult for programmers to implement manually.",
        "trans_Question": "wɒt ɪz ðə néjm əv ðə spɛ́ʃəlàjzd sɔ́ftwɛ̀ər ðət trænsfɔ́rmz háj-lɛ́vəl prówɡræ̀mɪŋ kówd rɪ́tən baj dəvɛ́ləpərz ɪntə məʃíjn kówd ðət kən bij dɪərɛ́klij ɛ́ksəkjùwtɪd baj ə kəmpjúwtər'z prɒ́sɛsər?",
        "trans_RightAnswer": "kəmpájlər",
        "trans_WrongAnswers": [
            "ɪntɜ́rprətər",
            "əsɛ́mblər",
            "dijbʌ́ɡər",
            "rʌ́ntàjm ənvájərənmənt",
            "lɪ́ŋkər"
        ],
        "trans_Explanation": "ə kəmpájlər ɪz ə krúwʃəl túwl ɪn sɔ́ftwɛ̀ər dəvɛ́ləpmənt ðət trǽnslèjts hjúwmən-ríjdəbəl sɔ́rs kówd rɪ́tən ɪn prówɡræ̀mɪŋ lǽŋɡwədʒɪz lájk C++, dʒɒ́və, ɔr rʌ́st ɪntə məʃíjn kówd ɔr ɒ́bdʒəkt kówd ðət kəmpjúwtərz kən dɪərɛ́klij ɛ́ksəkjùwt. ʌ̀nlájk ɪntɜ́rprətərz wɪ́tʃ trænsléjt ənd ɛ́ksəkjùwt kówd lájn baj lájn, kəmpájlərz prɒ́sɛs ðə əntájər prówɡræ̀m æt wʌ́ns, pərfɔ́rmɪŋ vɛ́ərijəs ɒ̀ptɪmɪzéjʃənz əlɔ́ŋ ðə wej. ðə kɒ̀mpɪléjʃən prɒ́sɛs ɪnvɒ́lvz sɛ́vərəl stéjdʒɪz ɪnklúwdɪŋ lɛ́ksɪkəl ənǽlɪsɪs, sɪ́ntæ̀ks pɑ́rsɪŋ, səmǽntɪk ənǽlɪsɪs, kówd ɒptɪmɪzéjʃən, ənd kówd dʒɛ̀nəréjʃən. ðɪs træ̀nsfərméjʃən əláwz prówɡræ̀mərz tə rájt kówd ɪn mɔr ɪntúwɪtɪv, hájər-lɛ́vəl lǽŋɡwədʒɪz wájl stɪ́l ətʃíjvɪŋ ðə pərfɔ́rməns bɛ́nəfɪts əv məʃíjn-spəsɪ́fɪk ɪnstrʌ́kʃənz. mɒ́dərn kəmpájlərz nɒt ównlij trænsléjt kówd bʌt ɔ́lsow prəvájd ɛ́ərər tʃɛ́kɪŋ, səkjʊ́rɪtij fíjtʃərz, ənd pərfɔ́rməns ɒ̀ptɪmɪzéjʃənz ðət wʊd bij dɪ́fɪkəlt fɔr prówɡræ̀mərz tə ɪ́mpləmənt mǽnjuwəlij."
    },
    {
        "Question": "What is the name of the program that directly executes high-level code line by line without first converting the entire program to machine language?",
        "RightAnswer": "Interpreter",
        "WrongAnswers": [
            "Compiler",
            "Assembler",
            "Linker",
            "Debugger",
            "Runtime Environment"
        ],
        "Explanation": "An Interpreter is a computer program that directly processes and executes high-level programming code without requiring it to be previously compiled into machine language. Unlike a compiler that translates the entire source code into machine code before execution, an interpreter translates and executes the program line by line, statement by statement. This allows for immediate feedback during development and easier debugging, as errors are reported as they are encountered. Interpreters are commonly used for languages like Python, JavaScript, and Ruby. While they offer flexibility and ease of development, interpreted programs typically run slower than compiled ones because translation occurs during runtime rather than beforehand. Interpreters are essential tools in modern software development, particularly for scripting languages and rapid prototyping.",
        "trans_Question": "wɒt ɪz ðə néjm əv ðə prówɡræ̀m ðət dɪərɛ́klij ɛ́ksəkjùwts háj-lɛ́vəl kówd lájn baj lájn wɪðáwt fɜ́rst kənvɜ́rtɪŋ ðə əntájər prówɡræ̀m tə məʃíjn lǽŋɡwədʒ?",
        "trans_RightAnswer": "ɪntɜ́rprətər",
        "trans_WrongAnswers": [
            "kəmpájlər",
            "əsɛ́mblər",
            "lɪ́ŋkər",
            "dijbʌ́ɡər",
            "rʌ́ntàjm ənvájərənmənt"
        ],
        "trans_Explanation": "ən ɪntɜ́rprətər ɪz ə kəmpjúwtər prówɡræ̀m ðət dɪərɛ́klij prɒ́sɛsɪz ənd ɛ́ksəkjùwts háj-lɛ́vəl prówɡræ̀mɪŋ kówd wɪðáwt rijkwájərɪŋ ɪt tə bij príjvijəslij kəmpájld ɪntə məʃíjn lǽŋɡwədʒ. ʌ̀nlájk ə kəmpájlər ðət trǽnslèjts ðə əntájər sɔ́rs kówd ɪntə məʃíjn kówd bəfɔ́r ɛ̀ksəkjúwʃən, ən ɪntɜ́rprətər trǽnslèjts ənd ɛ́ksəkjùwts ðə prówɡræ̀m lájn baj lájn, stéjtmənt baj stéjtmənt. ðɪs əláwz fɔr ɪmíjdijət fíjdbæ̀k dʊ́rɪŋ dəvɛ́ləpmənt ənd íjzijər dijbʌ́ɡɪŋ, æz ɛ́ərərz ɑr rìjpɔ́rtɪd æz ðej ɑr ənkáwntərd. ɪntɜ́rprətərz ɑr kɒ́mənlij júwzd fɔr lǽŋɡwədʒɪz lájk pájθɒn, dʒɒ́vəskrɪ̀pt, ənd rúwbij. wájl ðej ɔ́fər flɛ̀ksɪbɪ́lɪtij ənd íjz əv dəvɛ́ləpmənt, ɪntɜ́rprətɪd prówɡræ̀mz tɪ́pɪkəlij rʌ́n slówər ðʌn kəmpájld wʌ́nz bəkɒ́z trænsléjʃən əkɜ́rz dʊ́rɪŋ rʌ́ntàjm rǽðər ðʌn bəfɔ́rhæ̀nd. ɪntɜ́rprətərz ɑr əsɛ́nʃəl túwlz ɪn mɒ́dərn sɔ́ftwɛ̀ər dəvɛ́ləpmənt, pərtɪ́kjələrlij fɔr skrɪ́ptɪŋ lǽŋɡwədʒɪz ənd rǽpɪd prówtowtàjpɪŋ."
    },
    {
        "Question": "What intermediate code format is commonly used in Java, Python, and other programming languages for platform-independent execution, being compiled at runtime by a virtual machine?",
        "RightAnswer": "Bytecode",
        "WrongAnswers": [
            "Machine code",
            "Source code",
            "Pseudocode",
            "Markup language",
            "Assembly language"
        ],
        "Explanation": "Bytecode is an intermediate representation of program code that sits between human-readable source code and machine code. Unlike machine code that runs directly on hardware, bytecode is designed to be executed by a virtual machine. When you compile Java or Python code, it's translated into bytecode rather than directly into machine code. This bytecode can then run on any device with the appropriate virtual machine installed, which is what gives these languages their 'write once, run anywhere' capability. The virtual machine interprets or just-in-time compiles the bytecode into machine code specific to whatever computer it's running on. Bytecode gets its name because many of its instructions are one byte in length, though this isn't always the case. This approach offers significant advantages in portability and security while still maintaining reasonable performance compared to directly interpreted languages.",
        "trans_Question": "wɒt ɪ̀ntərmíjdijət kówd fɔ́rmæ̀t ɪz kɒ́mənlij júwzd ɪn dʒɒ́və, pájθɒn, ənd ʌ́ðər prówɡræ̀mɪŋ lǽŋɡwədʒɪz fɔr plǽtfɔ̀rm-ɪndəpɛ́ndənt ɛ̀ksəkjúwʃən, bíjɪŋ kəmpájld æt rʌ́ntàjm baj ə vɜ́rtʃuwəl məʃíjn?",
        "trans_RightAnswer": "bájtkòwd",
        "trans_WrongAnswers": [
            "məʃíjn kówd",
            "sɔ́rs kówd",
            "súwdəkowd",
            "mɑ́rkʌ̀p lǽŋɡwədʒ",
            "əsɛ́mblij lǽŋɡwədʒ"
        ],
        "trans_Explanation": "bájtkòwd ɪz ən ɪ̀ntərmíjdijət rɛ̀prəzɛntéjʃən əv prówɡræ̀m kówd ðət sɪ́ts bijtwíjn hjúwmən-ríjdəbəl sɔ́rs kówd ənd məʃíjn kówd. ʌ̀nlájk məʃíjn kówd ðət rʌ́nz dɪərɛ́klij ɒn hɑ́rdwɛ̀ər, bájtkòwd ɪz dəzájnd tə bij ɛ́ksəkjùwtɪd baj ə vɜ́rtʃuwəl məʃíjn. wɛ́n juw kəmpájl dʒɒ́və ɔr pájθɒn kówd, ɪt's trænsléjtɪd ɪntə bájtkòwd rǽðər ðʌn dɪərɛ́klij ɪntə məʃíjn kówd. ðɪs bájtkòwd kən ðɛn rʌ́n ɒn ɛ́nij dəvájs wɪð ðə əprówprijèjt vɜ́rtʃuwəl məʃíjn ɪnstɔ́ld, wɪ́tʃ ɪz wɒt ɡɪ́vz ðijz lǽŋɡwədʒɪz ðɛər 'rájt wʌ́ns, rʌ́n ɛ́nijwɛ̀ər' kèjpəbɪ́lɪtij. ðə vɜ́rtʃuwəl məʃíjn ɪntɜ́rprəts ɔr dʒəst-ɪn-tájm kəmpájlz ðə bájtkòwd ɪntə məʃíjn kówd spəsɪ́fɪk tə wʌ̀tɛ́vər kəmpjúwtər ɪt's rʌ́nɪŋ ɒn. bájtkòwd ɡɛ́ts ɪts néjm bəkɒ́z mɛ́nij əv ɪts ɪnstrʌ́kʃənz ɑr wʌ́n bájt ɪn lɛ́ŋθ, ðów ðɪs ɪzənt ɔ́lwejz ðə kéjs. ðɪs əprówtʃ ɔ́fərz sɪɡnɪ́fɪkənt ədvǽntɪdʒɪz ɪn pɔ̀rtəbɪ́lɪtij ənd səkjʊ́rɪtij wájl stɪ́l mejntéjnɪŋ ríjzənəbəl pərfɔ́rməns kəmpɛ́ərd tə dɪərɛ́klij ɪntɜ́rprətɪd lǽŋɡwədʒɪz."
    },
    {
        "Question": "Which optimization technique dynamically translates bytecode or intermediate code into native machine code during program execution rather than before execution?",
        "RightAnswer": "Just-In-Time Compilation",
        "WrongAnswers": [
            "Ahead-Of-Time Compilation",
            "Lazy Evaluation",
            "Dynamic Linking",
            "Incremental Compilation",
            "Runtime Interpretation"
        ],
        "Explanation": "Just-In-Time Compilation, often abbreviated as JIT compilation, is a performance-enhancing technique that bridges the gap between interpreted and compiled programming languages. Instead of compiling an entire program before execution (as in traditional compilation) or interpreting each line of code during runtime (as in pure interpretation), JIT compilation takes a middle approach. It translates portions of bytecode or intermediate code into native machine code at runtime, right before that code is executed—hence the name 'just in time.' This approach offers several advantages: it allows for platform independence (like interpretation) while achieving speeds closer to compiled code, it can optimize code based on actual runtime behavior rather than static analysis, and it can recompile frequently used code paths with more aggressive optimizations. JIT compilation is a key technology in modern language implementations including Java Virtual Machine, Microsoft's .NET framework, modern JavaScript engines like V8, and many other programming environments.",
        "trans_Question": "wɪ́tʃ ɒptɪmɪzéjʃən tɛkníjk dajnǽmɪklìj trǽnslèjts bájtkòwd ɔr ɪ̀ntərmíjdijət kówd ɪntə néjtɪv məʃíjn kówd dʊ́rɪŋ prówɡræ̀m ɛ̀ksəkjúwʃən rǽðər ðʌn bəfɔ́r ɛ̀ksəkjúwʃən?",
        "trans_RightAnswer": "dʒəst-ɪn-tájm kɒ̀mpɪléjʃən",
        "trans_WrongAnswers": [
            "əhɛ́d-əv-tájm kɒ̀mpɪléjʃən",
            "léjzij əvæ̀ljuwéjʃən",
            "dajnǽmɪk lɪ́ŋkɪŋ",
            "ɪnkrəmɛ́ntəl kɒ̀mpɪléjʃən",
            "rʌ́ntàjm ɪntɜ̀rprətéjʃən"
        ],
        "trans_Explanation": "dʒəst-ɪn-tájm kɒ̀mpɪléjʃən, ɔ́fən əbríjvijèjtɪd æz JIT kɒ̀mpɪléjʃən, ɪz ə pərfɔ́rməns-ɛnhǽnsɪŋ tɛkníjk ðət brɪ́dʒɪz ðə ɡǽp bijtwíjn ɪntɜ́rprətɪd ənd kəmpájld prówɡræ̀mɪŋ lǽŋɡwədʒɪz. ɪnstɛ́d əv kəmpájlɪŋ ən əntájər prówɡræ̀m bəfɔ́r ɛ̀ksəkjúwʃən (æz ɪn trədɪ́ʃənəl kɒ̀mpɪléjʃən) ɔr ɪntərprɛ́tɪŋ ijtʃ lájn əv kówd dʊ́rɪŋ rʌ́ntàjm (æz ɪn pjʊ́r ɪntɜ̀rprətéjʃən), JIT kɒ̀mpɪléjʃən téjks ə mɪ́dəl əprówtʃ. ɪt trǽnslèjts pɔ́rʃənz əv bájtkòwd ɔr ɪ̀ntərmíjdijət kówd ɪntə néjtɪv məʃíjn kówd æt rʌ́ntàjm, rájt bəfɔ́r ðət kówd ɪz ɛ́ksəkjùwtɪd—hɛ́ns ðə néjm 'dʒəst ɪn tájm.' ðɪs əprówtʃ ɔ́fərz sɛ́vərəl ədvǽntɪdʒɪz: ɪt əláwz fɔr plǽtfɔ̀rm ɪndəpɛ́ndəns (lájk ɪntɜ̀rprətéjʃən) wájl ətʃíjvɪŋ spíjdz klówsər tə kəmpájld kówd, ɪt kən ɒ́ptɪmàjz kówd béjst ɒn ǽktʃəl rʌ́ntàjm bəhéjvjər rǽðər ðʌn stǽtɪk ənǽlɪsɪs, ənd ɪt kən rìjkəmpájl fríjkwəntlij júwzd kówd pǽðz wɪð mɔr əɡrɛ́sɪv ɒ̀ptɪmɪzéjʃənz. JIT kɒ̀mpɪléjʃən ɪz ə kíj tɛknɒ́lədʒij ɪn mɒ́dərn lǽŋɡwədʒ ɪ̀mpləmɛntéjʃənz ɪnklúwdɪŋ dʒɒ́və vɜ́rtʃuwəl məʃíjn, májkròwsɔ́ft's .NET fréjmwɜ̀rk, mɒ́dərn dʒɒ́vəskrɪ̀pt ɛ́ndʒɪnz lájk V8, ənd mɛ́nij ʌ́ðər prówɡræ̀mɪŋ ənvájərənmənts."
    },
    {
        "Question": "In programming languages like Java and Python, what is the automated memory management process that identifies and reclaims memory occupied by objects no longer in use?",
        "RightAnswer": "Garbage Collection",
        "WrongAnswers": [
            "Memory Sweeping",
            "Object Finalization",
            "Resource Harvesting",
            "Automatic Deallocation",
            "Heap Cleaning"
        ],
        "Explanation": "Garbage Collection is an automatic memory management feature in many programming languages that relieves developers from manually deallocating memory. It works by identifying objects in memory that are no longer referenced by the program, considering them 'garbage,' and reclaiming that memory for future use. This prevents memory leaks and dangling pointer errors that commonly plague languages requiring manual memory management like C and C++. Different garbage collection algorithms exist, including mark-and-sweep, reference counting, and generational collection, each with trade-offs regarding efficiency and performance impact. Languages like Java, Python, JavaScript, and C# implement garbage collection to make programming safer and more productive, though it can introduce performance overhead and pauses in program execution during collection cycles.",
        "trans_Question": "ɪn prówɡræ̀mɪŋ lǽŋɡwədʒɪz lájk dʒɒ́və ənd pájθɒn, wɒt ɪz ðə ɔ́təmèjtɪd mɛ́mərij mǽnədʒmənt prɒ́sɛs ðət ajdɛ́ntɪfàjz ənd rɪkléjmz mɛ́mərij ɒ́kjəpàjd baj ɒ́bdʒɛkts now lɔ́ŋɡər ɪn juwz?",
        "trans_RightAnswer": "ɡɑ́rbɪdʒ kəlɛ́kʃən",
        "trans_WrongAnswers": [
            "mɛ́mərij swíjpɪŋ",
            "ɒ́bdʒəkt fàjnəlajzéjʃən",
            "ríjsɔrs hɑ́rvəstɪŋ",
            "ɔ̀təmǽtɪk dɪæ̀ləkéjʃən",
            "híjp klíjnɪŋ"
        ],
        "trans_Explanation": "ɡɑ́rbɪdʒ kəlɛ́kʃən ɪz ən ɔ̀təmǽtɪk mɛ́mərij mǽnədʒmənt fíjtʃər ɪn mɛ́nij prówɡræ̀mɪŋ lǽŋɡwədʒɪz ðət rəlíjvz dəvɛ́ləpərz frəm mǽnjuwəlij dijǽləkejtɪŋ mɛ́mərij. ɪt wɜ́rks baj ajdɛ́ntɪfàjɪŋ ɒ́bdʒɛkts ɪn mɛ́mərij ðət ɑr now lɔ́ŋɡər rɛ́fərənst baj ðə prówɡræ̀m, kənsɪ́dərɪŋ ðɛm 'ɡɑ́rbɪdʒ,' ənd rijkléjmɪŋ ðət mɛ́mərij fɔr fjúwtʃər juwz. ðɪs prəvɛ́nts mɛ́mərij líjks ənd dǽŋɡəlɪŋ pɔ́jntər ɛ́ərərz ðət kɒ́mənlij pléjɡ lǽŋɡwədʒɪz rijkwájərɪŋ mǽnjuwəl mɛ́mərij mǽnədʒmənt lájk C ənd C++. dɪ́fərənt ɡɑ́rbɪdʒ kəlɛ́kʃən ǽlɡərɪ̀ðəmz əɡzɪ́st, ɪnklúwdɪŋ mɑ́rk-ənd-swíjp, rɛ́fərəns káwntɪŋ, ənd dʒɛ̀nəréjʃənəl kəlɛ́kʃən, ijtʃ wɪð tréjd-ɔ́fs rəɡɑ́rdɪŋ əfɪ́ʃənsij ənd pərfɔ́rməns ɪ́mpækt. lǽŋɡwədʒɪz lájk dʒɒ́və, pájθɒn, dʒɒ́vəskrɪ̀pt, ənd C# ɪ́mpləmənt ɡɑ́rbɪdʒ kəlɛ́kʃən tə méjk prówɡræ̀mɪŋ séjfər ənd mɔr prədʌ́ktɪv, ðów ɪt kən ɪntrədúws pərfɔ́rməns ówvərhɛ́d ənd pɔ́zɪz ɪn prówɡræ̀m ɛ̀ksəkjúwʃən dʊ́rɪŋ kəlɛ́kʃən sájkəlz."
    },
    {
        "Question": "What is the process of assigning portions of a computer's main memory to programs, data, and other entities so they can be utilized effectively by the system?",
        "RightAnswer": "Memory Allocation",
        "WrongAnswers": [
            "Resource Scheduling",
            "Data Fragmentation",
            "Cache Coherence",
            "Virtual Threading",
            "Address Mapping"
        ],
        "Explanation": "Memory Allocation is the fundamental process in computing where the system assigns specific portions of memory to programs, variables, and data structures. When your program runs, it needs space to store instructions and data, and memory allocation is how the computer provides this space. This can happen in different ways: statically at compile time, automatically on the stack during function calls, or dynamically at runtime when requested by the program. Dynamic memory allocation is particularly important as it allows programs to request memory as needed and return it when finished, enabling efficient use of resources. Understanding memory allocation helps programmers prevent issues like memory leaks, where allocated memory is never released, or fragmentation, where free memory becomes divided into small, unusable chunks. Whether you're coding in C with explicit malloc and free functions, or using higher-level languages with automatic garbage collection, memory allocation remains a core concept that affects program performance and reliability.",
        "trans_Question": "wɒt ɪz ðə prɒ́sɛs əv əsájnɪŋ pɔ́rʃənz əv ə kəmpjúwtər'z méjn mɛ́mərij tə prówɡræ̀mz, déjtə, ənd ʌ́ðər ɛ́ntɪtijz sow ðej kən bij júwtɪlàjzd əfɛ́ktɪvlij baj ðə sɪ́stəm?",
        "trans_RightAnswer": "mɛ́mərij æ̀ləkéjʃən",
        "trans_WrongAnswers": [
            "ríjsɔrs skɛ́dʒuwlɪŋ",
            "déjtə fræ̀ɡməntéjʃən",
            "kǽʃ kowhɪ́ərəns",
            "vɜ́rtʃuwəl θrɛ́dɪŋ",
            "æ̀drɛ́s mǽpɪŋ"
        ],
        "trans_Explanation": "mɛ́mərij æ̀ləkéjʃən ɪz ðə fʌ̀ndəmɛ́ntəl prɒ́sɛs ɪn kəmpjúwtɪŋ wɛ́ər ðə sɪ́stəm əsájnz spəsɪ́fɪk pɔ́rʃənz əv mɛ́mərij tə prówɡræ̀mz, vɛ́ərijəbəlz, ənd déjtə strʌ́ktʃərz. wɛ́n jɔr prówɡræ̀m rʌ́nz, ɪt níjdz spéjs tə stɔ́r ɪnstrʌ́kʃənz ənd déjtə, ənd mɛ́mərij æ̀ləkéjʃən ɪz háw ðə kəmpjúwtər prəvájdz ðɪs spéjs. ðɪs kən hǽpən ɪn dɪ́fərənt wéjz: stætɪkəlij æt kəmpájl tájm, ɔ̀təmǽtɪklij ɒn ðə stǽk dʊ́rɪŋ fʌ́ŋkʃən kɔ́lz, ɔr dajnǽmɪklìj æt rʌ́ntàjm wɛ́n rəkwɛ́stɪd baj ðə prówɡræ̀m. dajnǽmɪk mɛ́mərij æ̀ləkéjʃən ɪz pərtɪ́kjələrlij ɪmpɔ́rtənt æz ɪt əláwz prówɡræ̀mz tə rəkwɛ́st mɛ́mərij æz níjdɪd ənd rətɜ́rn ɪt wɛ́n fɪ́nɪʃt, ɛnéjbəlɪŋ əfɪ́ʃənt juwz əv ríjsɔrsɪz. ʌ̀ndərstǽndɪŋ mɛ́mərij æ̀ləkéjʃən hɛ́lps prówɡræ̀mərz prəvɛ́nt ɪ́ʃuwz lájk mɛ́mərij líjks, wɛ́ər ǽləkèjtɪd mɛ́mərij ɪz nɛ́vər rəlíjst, ɔr fræ̀ɡməntéjʃən, wɛ́ər fríj mɛ́mərij bəkʌ́mz dɪvájdɪd ɪntə smɔ́l, ʌ̀njúwzəbəl tʃʌ́ŋks. wɛ́ðər júwr kówdɪŋ ɪn C wɪð əksplɪ́sɪt mǽlək ənd fríj fʌ́ŋkʃənz, ɔr júwzɪŋ hájər-lɛ́vəl lǽŋɡwədʒɪz wɪð ɔ̀təmǽtɪk ɡɑ́rbɪdʒ kəlɛ́kʃən, mɛ́mərij æ̀ləkéjʃən rəméjnz ə kɔ́r kɒ́nsɛpt ðət əfɛ́kts prówɡræ̀m pərfɔ́rməns ənd rəlàjəbɪ́lɪtij."
    },
    {
        "Question": "Which memory structure in computing follows a Last-In-First-Out (LIFO) principle and is primarily used for managing function calls and local variables?",
        "RightAnswer": "Stack Memory",
        "WrongAnswers": [
            "Heap Memory",
            "Cache Memory",
            "Virtual Memory",
            "Register Memory",
            "Queue Memory"
        ],
        "Explanation": "Stack Memory is a special region of computer memory that operates on the Last-In-First-Out (LIFO) principle, similar to a stack of plates where you can only take from the top. In programming, the stack is used to store local variables, function parameters, return addresses, and to keep track of the sequence of function calls. When a function is called, a new frame is created on the stack to hold its variables and when the function completes, its frame is removed. Stack memory allocation and deallocation are handled automatically by the compiler, making it efficient but limited in size. This is in contrast to Heap Memory, which is more flexible but requires manual management. The stack's structured nature provides crucial support for program execution, helping maintain the flow and context of operations in the program.",
        "trans_Question": "wɪ́tʃ mɛ́mərij strʌ́ktʃər ɪn kəmpjúwtɪŋ fɒ́lowz ə lǽst-ɪn-fɜ́rst-awt (LIFO) prɪ́nsɪpəl ənd ɪz prajmɛ́ərɪlij júwzd fɔr mǽnɪdʒɪŋ fʌ́ŋkʃən kɔ́lz ənd lówkəl vɛ́ərijəbəlz?",
        "trans_RightAnswer": "stǽk mɛ́mərij",
        "trans_WrongAnswers": [
            "híjp mɛ́mərij",
            "kǽʃ mɛ́mərij",
            "vɜ́rtʃuwəl mɛ́mərij",
            "rɛ́dʒɪstər mɛ́mərij",
            "kjúw mɛ́mərij"
        ],
        "trans_Explanation": "stǽk mɛ́mərij ɪz ə spɛ́ʃəl ríjdʒən əv kəmpjúwtər mɛ́mərij ðət ɒ́pərèjts ɒn ðə lǽst-ɪn-fɜ́rst-awt (LIFO) prɪ́nsɪpəl, sɪ́mɪlər tə ə stǽk əv pléjts wɛ́ər juw kən ównlij téjk frəm ðə tɒ́p. ɪn prówɡræ̀mɪŋ, ðə stǽk ɪz júwzd tə stɔ́r lówkəl vɛ́ərijəbəlz, fʌ́ŋkʃən pərǽmətərz, rətɜ́rn ǽdrɛ́sɪz, ənd tə kíjp trǽk əv ðə síjkwəns əv fʌ́ŋkʃən kɔ́lz. wɛ́n ə fʌ́ŋkʃən ɪz kɔ́ld, ə núw fréjm ɪz krijéjtɪd ɒn ðə stǽk tə hówld ɪts vɛ́ərijəbəlz ənd wɛ́n ðə fʌ́ŋkʃən kəmplíjts, ɪts fréjm ɪz rijmúwvd. stǽk mɛ́mərij æ̀ləkéjʃən ənd dɪæ̀ləkéjʃən ɑr hǽndəld ɔ̀təmǽtɪklij baj ðə kəmpájlər, méjkɪŋ ɪt əfɪ́ʃənt bʌt lɪ́mɪtɪd ɪn sájz. ðɪs ɪz ɪn kɒ́ntræst tə híjp mɛ́mərij, wɪ́tʃ ɪz mɔr flɛ́ksɪbəl bʌt rəkwájərz mǽnjuwəl mǽnədʒmənt. ðə stǽk'z strʌ́ktʃərd néjtʃər prəvájdz krúwʃəl səpɔ́rt fɔr prówɡræ̀m ɛ̀ksəkjúwʃən, hɛ́lpɪŋ mejntéjn ðə flów ənd kɒ́ntɛkst əv ɒ̀pəréjʃənz ɪn ðə prówɡræ̀m."
    },
    {
        "Question": "In a programming environment, what term describes the area of memory where dynamically allocated objects are stored during program execution?",
        "RightAnswer": "Heap Memory",
        "WrongAnswers": [
            "Stack Memory",
            "Cache Memory",
            "Virtual Memory",
            "Register Memory",
            "ROM Storage"
        ],
        "Explanation": "Heap Memory is a region of a computer's memory that is not managed automatically by the operating system in a structured way, but instead allows programmers to explicitly allocate and deallocate blocks of memory as needed at runtime. Unlike Stack Memory, which follows a strict last-in-first-out order and is used for local variables and function calls, Heap Memory provides a more flexible storage area where objects can persist beyond the scope of a single function and exist until explicitly destroyed. This makes Heap Memory essential for data structures whose size cannot be determined at compile time, or for objects that need to exist throughout different parts of a program's execution. However, this flexibility comes with responsibility, as improper management of Heap Memory can lead to problems like memory leaks or fragmentation. Languages like C and C++ require manual heap management through functions like malloc and free, while languages like Java and Python handle heap allocations through garbage collection mechanisms that automatically reclaim memory no longer in use.",
        "trans_Question": "ɪn ə prówɡræ̀mɪŋ ənvájərənmənt, wɒt tɜ́rm dəskrájbz ðə ɛ́ərijə əv mɛ́mərij wɛ́ər dajnǽmɪklìj ǽləkèjtɪd ɒ́bdʒɛkts ɑr stɔ́rd dʊ́rɪŋ prówɡræ̀m ɛ̀ksəkjúwʃən?",
        "trans_RightAnswer": "híjp mɛ́mərij",
        "trans_WrongAnswers": [
            "stǽk mɛ́mərij",
            "kǽʃ mɛ́mərij",
            "vɜ́rtʃuwəl mɛ́mərij",
            "rɛ́dʒɪstər mɛ́mərij",
            "ROM stɔ́rɪdʒ"
        ],
        "trans_Explanation": "híjp mɛ́mərij ɪz ə ríjdʒən əv ə kəmpjúwtər'z mɛ́mərij ðət ɪz nɒt mǽnɪdʒd ɔ̀təmǽtɪklij baj ðə ɒ́pərèjtɪŋ sɪ́stəm ɪn ə strʌ́ktʃərd wej, bʌt ɪnstɛ́d əláwz prówɡræ̀mərz tə əksplɪ́sɪtlij ǽləkèjt ənd ədɛ́ləkejt blɒ́ks əv mɛ́mərij æz níjdɪd æt rʌ́ntàjm. ʌ̀nlájk stǽk mɛ́mərij, wɪ́tʃ fɒ́lowz ə strɪ́kt lǽst-ɪn-fɜ́rst-awt ɔ́rdər ənd ɪz júwzd fɔr lówkəl vɛ́ərijəbəlz ənd fʌ́ŋkʃən kɔ́lz, híjp mɛ́mərij prəvájdz ə mɔr flɛ́ksɪbəl stɔ́rɪdʒ ɛ́ərijə wɛ́ər ɒ́bdʒɛkts kən pərsɪ́st bìjɔ́nd ðə skówp əv ə sɪ́ŋɡəl fʌ́ŋkʃən ənd əɡzɪ́st əntɪ́l əksplɪ́sɪtlij dəstrɔ́jd. ðɪs méjks híjp mɛ́mərij əsɛ́nʃəl fɔr déjtə strʌ́ktʃərz húwz sájz kǽnɒt bij dətɜ́rmɪnd æt kəmpájl tájm, ɔr fɔr ɒ́bdʒɛkts ðət níjd tə əɡzɪ́st θruwáwt dɪ́fərənt pɑ́rts əv ə prówɡræ̀m'z ɛ̀ksəkjúwʃən. hàwɛ́vər, ðɪs flɛ̀ksɪbɪ́lɪtij kʌ́mz wɪð rəspɒ̀nsɪbɪ́lɪtij, æz ɪ̀mprɒ́pər mǽnədʒmənt əv híjp mɛ́mərij kən líjd tə prɒ́bləmz lájk mɛ́mərij líjks ɔr fræ̀ɡməntéjʃən. lǽŋɡwədʒɪz lájk C ənd C++ rəkwájər mǽnjuwəl híjp mǽnədʒmənt θrúw fʌ́ŋkʃənz lájk mǽlək ənd fríj, wájl lǽŋɡwədʒɪz lájk dʒɒ́və ənd pájθɒn hǽndəl híjp æ̀ləkéjʃənz θrúw ɡɑ́rbɪdʒ kəlɛ́kʃən mɛ́kənɪzəmz ðət ɔ̀təmǽtɪklij rijkléjm mɛ́mərij now lɔ́ŋɡər ɪn juwz."
    },
    {
        "Question": "What technology enables a computer to run programs that require more RAM than is physically available by temporarily storing portions of data on the hard drive?",
        "RightAnswer": "Virtual Memory",
        "WrongAnswers": [
            "Cache Memory",
            "Swap Intelligence",
            "Memory Paging",
            "RAM Extension",
            "Dynamic Memory Allocation"
        ],
        "Explanation": "Virtual Memory is a memory management technique that creates the illusion of having more RAM than is physically installed in a computer. It works by using a portion of the hard drive as an extension of RAM, allowing the operating system to run programs that require more memory than is physically available. When RAM becomes full, less frequently used data is temporarily moved to this dedicated space on the hard drive (often called a page file or swap space). The operating system keeps track of these memory locations using a mapping system, seamlessly retrieving data when needed and giving programs the impression they have continuous access to sufficient memory. While virtual memory enables running larger applications, accessing data from the hard drive is significantly slower than from RAM, which can affect system performance when heavily relied upon. This technology has been fundamental to modern computing, allowing complex applications to run on systems with limited physical memory resources.",
        "trans_Question": "wɒt tɛknɒ́lədʒij ɛnéjbəlz ə kəmpjúwtər tə rʌ́n prówɡræ̀mz ðət rəkwájər mɔr RAM ðʌn ɪz fɪ́zɪkəlij əvéjləbəl baj tɛ̀mpərɛ́ərɪlij stɔ́rɪŋ pɔ́rʃənz əv déjtə ɒn ðə hɑ́rd drájv?",
        "trans_RightAnswer": "vɜ́rtʃuwəl mɛ́mərij",
        "trans_WrongAnswers": [
            "kǽʃ mɛ́mərij",
            "swɒ́p ɪntɛ́lɪdʒəns",
            "mɛ́mərij péjdʒɪŋ",
            "RAM əkstɛ́nʃən",
            "dajnǽmɪk mɛ́mərij æ̀ləkéjʃən"
        ],
        "trans_Explanation": "vɜ́rtʃuwəl mɛ́mərij ɪz ə mɛ́mərij mǽnədʒmənt tɛkníjk ðət krijéjts ðə ɪ̀lúwʒən əv hǽvɪŋ mɔr RAM ðʌn ɪz fɪ́zɪkəlij ɪnstɔ́ld ɪn ə kəmpjúwtər. ɪt wɜ́rks baj júwzɪŋ ə pɔ́rʃən əv ðə hɑ́rd drájv æz ən əkstɛ́nʃən əv RAM, əláwɪŋ ðə ɒ́pərèjtɪŋ sɪ́stəm tə rʌ́n prówɡræ̀mz ðət rəkwájər mɔr mɛ́mərij ðʌn ɪz fɪ́zɪkəlij əvéjləbəl. wɛ́n RAM bəkʌ́mz fʊ́l, lɛ́s fríjkwəntlij júwzd déjtə ɪz tɛ̀mpərɛ́ərɪlij múwvd tə ðɪs dɛ́dɪkejtɪd spéjs ɒn ðə hɑ́rd drájv (ɔ́fən kɔ́ld ə péjdʒ fájl ɔr swɒ́p spéjs). ðə ɒ́pərèjtɪŋ sɪ́stəm kíjps trǽk əv ðijz mɛ́mərij lowkéjʃənz júwzɪŋ ə mǽpɪŋ sɪ́stəm, síjmləslij rətríjvɪŋ déjtə wɛ́n níjdɪd ənd ɡɪ́vɪŋ prówɡræ̀mz ðə ɪ̀mprɛ́ʃən ðej həv kəntɪ́njuwəs ǽksɛ̀s tə səfɪ́ʃənt mɛ́mərij. wájl vɜ́rtʃuwəl mɛ́mərij ɛnéjbəlz rʌ́nɪŋ lɑ́rdʒər æ̀plɪkéjʃənz, ǽksɛ̀sɪŋ déjtə frəm ðə hɑ́rd drájv ɪz sɪɡnɪ́fɪkəntlij slówər ðʌn frəm RAM, wɪ́tʃ kən əfɛ́kt sɪ́stəm pərfɔ́rməns wɛ́n hɛ́vɪlij rəlájd əpɒ́n. ðɪs tɛknɒ́lədʒij həz bɪn fʌ̀ndəmɛ́ntəl tə mɒ́dərn kəmpjúwtɪŋ, əláwɪŋ kɒ́mplɛks æ̀plɪkéjʃənz tə rʌ́n ɒn sɪ́stəmz wɪð lɪ́mɪtɪd fɪ́zɪkəl mɛ́mərij ríjsɔrsɪz."
    },
    {
        "Question": "What is the memory management technique that divides both physical and virtual memory into fixed-size blocks to efficiently handle address translation and memory allocation?",
        "RightAnswer": "Paging",
        "WrongAnswers": [
            "Segmentation",
            "Swapping",
            "Caching",
            "Virtualization",
            "Memory Mapping"
        ],
        "Explanation": "Paging is a memory management scheme used in operating systems that allows physical memory to be organized into fixed-size blocks called 'pages', while virtual memory is divided into blocks of the same size called 'page frames'. This technique enables the operating system to store and retrieve data efficiently by mapping virtual addresses to physical addresses through a page table. When a program needs more memory than is physically available, paging allows the operating system to temporarily transfer less-used pages to secondary storage (like a hard drive) in a process called 'page swapping'. This creates the illusion of having more memory than physically exists. Paging is crucial for multitasking environments as it allows multiple programs to run simultaneously by giving each program its own virtual address space, preventing programs from interfering with each other's memory. Modern operating systems like Windows, macOS, and Linux all implement paging as a fundamental component of their memory management systems.",
        "trans_Question": "wɒt ɪz ðə mɛ́mərij mǽnədʒmənt tɛkníjk ðət dɪvájdz bówθ fɪ́zɪkəl ənd vɜ́rtʃuwəl mɛ́mərij ɪntə fɪ́kst-sájz blɒ́ks tə əfɪ́ʃəntlij hǽndəl æ̀drɛ́s trænsléjʃən ənd mɛ́mərij æ̀ləkéjʃən?",
        "trans_RightAnswer": "péjdʒɪŋ",
        "trans_WrongAnswers": [
            "sɛ̀ɡməntéjʃən",
            "swɒ́pɪŋ",
            "kǽʃɪŋ",
            "vɜ̀rtʃuwəlɪzéjʃən",
            "mɛ́mərij mǽpɪŋ"
        ],
        "trans_Explanation": "péjdʒɪŋ ɪz ə mɛ́mərij mǽnədʒmənt skíjm júwzd ɪn ɒ́pərèjtɪŋ sɪ́stəmz ðət əláwz fɪ́zɪkəl mɛ́mərij tə bij ɔ́rɡənàjzd ɪntə fɪ́kst-sájz blɒ́ks kɔ́ld 'péjdʒɪz', wájl vɜ́rtʃuwəl mɛ́mərij ɪz dɪvájdɪd ɪntə blɒ́ks əv ðə séjm sájz kɔ́ld 'péjdʒ fréjmz'. ðɪs tɛkníjk ɛnéjbəlz ðə ɒ́pərèjtɪŋ sɪ́stəm tə stɔ́r ənd rətríjv déjtə əfɪ́ʃəntlij baj mǽpɪŋ vɜ́rtʃuwəl ǽdrɛ́sɪz tə fɪ́zɪkəl ǽdrɛ́sɪz θrúw ə péjdʒ téjbəl. wɛ́n ə prówɡræ̀m níjdz mɔr mɛ́mərij ðʌn ɪz fɪ́zɪkəlij əvéjləbəl, péjdʒɪŋ əláwz ðə ɒ́pərèjtɪŋ sɪ́stəm tə tɛ̀mpərɛ́ərɪlij trǽnsfər lɛ́s-júwzd péjdʒɪz tə sɛ́kəndɛ̀ərij stɔ́rɪdʒ (lájk ə hɑ́rd drájv) ɪn ə prɒ́sɛs kɔ́ld 'péjdʒ swɒ́pɪŋ'. ðɪs krijéjts ðə ɪ̀lúwʒən əv hǽvɪŋ mɔr mɛ́mərij ðʌn fɪ́zɪkəlij əɡzɪ́sts. péjdʒɪŋ ɪz krúwʃəl fɔr mʌ́ltijtæ̀skɪŋ ənvájərənmənts æz ɪt əláwz mʌ́ltɪpəl prówɡræ̀mz tə rʌ́n sàjməltéjnijəslij baj ɡɪ́vɪŋ ijtʃ prówɡræ̀m ɪts ówn vɜ́rtʃuwəl æ̀drɛ́s spéjs, prəvɛ́ntɪŋ prówɡræ̀mz frəm ɪ̀ntəfɪ́ərɪŋ wɪð ijtʃ ʌ́ðər'z mɛ́mərij. mɒ́dərn ɒ́pərèjtɪŋ sɪ́stəmz lájk wɪ́ndowz, mækówɛs, ənd lɪ́nəks ɔl ɪ́mpləmənt péjdʒɪŋ æz ə fʌ̀ndəmɛ́ntəl kəmpównənt əv ðɛər mɛ́mərij mǽnədʒmənt sɪ́stəmz."
    },
    {
        "Question": "In computer systems, what is the process of dividing memory into multiple segments, each with specific access rights and protections, to facilitate better memory management and process isolation?",
        "RightAnswer": "Segmentation",
        "WrongAnswers": [
            "Pagination",
            "Virtualization",
            "Partitioning",
            "Fragmentation",
            "Encapsulation"
        ],
        "Explanation": "Segmentation is a memory management technique that divides a computer's memory into segments, where each segment represents a specific type of data or code. Unlike continuous memory allocation, segmentation allows the operating system to assign different access permissions to different segments, such as read-only for code segments or read-write for data segments. This approach enhances security by preventing programs from accessing memory they shouldn't, improves memory utilization by allowing segments to be placed independently in physical memory, and supports sharing of code segments among multiple processes. While modern systems often combine segmentation with paging for greater flexibility, the fundamental concept remains important in understanding how computers organize and protect memory spaces in multitasking environments.",
        "trans_Question": "ɪn kəmpjúwtər sɪ́stəmz, wɒt ɪz ðə prɒ́sɛs əv dɪvájdɪŋ mɛ́mərij ɪntə mʌ́ltɪpəl sɛ́ɡmənts, ijtʃ wɪð spəsɪ́fɪk ǽksɛ̀s rájts ənd prətɛ́kʃənz, tə fəsɪ́lətèjt bɛ́tər mɛ́mərij mǽnədʒmənt ənd prɒ́sɛs àjsəléjʃən?",
        "trans_RightAnswer": "sɛ̀ɡməntéjʃən",
        "trans_WrongAnswers": [
            "pæ̀dʒənéjʃən",
            "vɜ̀rtʃuwəlɪzéjʃən",
            "pɑrtɪ́ʃənɪŋ",
            "fræ̀ɡməntéjʃən",
            "ɛnkǽpsəlèjʃən"
        ],
        "trans_Explanation": "sɛ̀ɡməntéjʃən ɪz ə mɛ́mərij mǽnədʒmənt tɛkníjk ðət dɪvájdz ə kəmpjúwtər'z mɛ́mərij ɪntə sɛ́ɡmənts, wɛ́ər ijtʃ sɛ́gmənt rɛ̀prəzɛ́nts ə spəsɪ́fɪk tájp əv déjtə ɔr kówd. ʌ̀nlájk kəntɪ́njuwəs mɛ́mərij æ̀ləkéjʃən, sɛ̀ɡməntéjʃən əláwz ðə ɒ́pərèjtɪŋ sɪ́stəm tə əsájn dɪ́fərənt ǽksɛ̀s pərmɪ́ʃənz tə dɪ́fərənt sɛ́ɡmənts, sʌtʃ æz rɛ́d-ównlij fɔr kówd sɛ́ɡmənts ɔr rɛ́d-rájt fɔr déjtə sɛ́ɡmənts. ðɪs əprówtʃ ənhǽnsɪz səkjʊ́rɪtij baj prəvɛ́ntɪŋ prówɡræ̀mz frəm ǽksɛ̀sɪŋ mɛ́mərij ðej ʃʊ́dənt, ɪmprúwvz mɛ́mərij jùwtɪlɪzéjʃən baj əláwɪŋ sɛ́ɡmənts tə bij pléjst ɪndəpɛ́ndəntlij ɪn fɪ́zɪkəl mɛ́mərij, ənd səpɔ́rts ʃɛ́ərɪŋ əv kówd sɛ́ɡmənts əmʌ́ŋ mʌ́ltɪpəl prɒ́sɛsɪz. wájl mɒ́dərn sɪ́stəmz ɔ́fən kɒ́mbajn sɛ̀ɡməntéjʃən wɪð péjdʒɪŋ fɔr ɡréjtər flɛ̀ksɪbɪ́lɪtij, ðə fʌ̀ndəmɛ́ntəl kɒ́nsɛpt rəméjnz ɪmpɔ́rtənt ɪn ʌ̀ndərstǽndɪŋ háw kəmpjúwtərz ɔ́rɡənàjz ənd prətɛ́kt mɛ́mərij spéjsɪz ɪn mʌ́ltijtæ̀skɪŋ ənvájərənmənts."
    },
    {
        "Question": "What is the organized structure that manages how data is stored, accessed, and retrieved on a computer's storage devices?",
        "RightAnswer": "File System",
        "WrongAnswers": [
            "Memory Manager",
            "Data Registry",
            "Storage Protocol",
            "Resource Allocator",
            "Directory Interface"
        ],
        "Explanation": "A File System is a critical component of computer operating systems that organizes and manages how data is stored and retrieved. Like a sophisticated library system for your computer, it creates a logical method to organize files, providing names, locations, and attributes for all stored data. File systems handle crucial tasks such as tracking available storage space, maintaining file metadata (creation dates, permissions, sizes), establishing hierarchical directory structures, and ensuring data integrity. Examples include NTFS used by Windows, ext4 common in Linux, and APFS for Apple devices. Without a file system, your computer would have no organized way to store, find, or manage any of your documents, applications, or system files, essentially turning your hard drive into an unusable pool of random data.",
        "trans_Question": "wɒt ɪz ðə ɔ́rɡənàjzd strʌ́ktʃər ðət mǽnɪdʒɪz háw déjtə ɪz stɔ́rd, ǽksɛ̀st, ənd rətríjvd ɒn ə kəmpjúwtər'z stɔ́rɪdʒ dəvájsɪz?",
        "trans_RightAnswer": "fájl sɪ́stəm",
        "trans_WrongAnswers": [
            "mɛ́mərij mǽnədʒər",
            "déjtə rɛ́dʒɪstrij",
            "stɔ́rɪdʒ prówtəkɒ̀l",
            "ríjsɔrs ǽləkèjtər",
            "dɪərɛ́ktərij ɪ́ntərfèjs"
        ],
        "trans_Explanation": "ə fájl sɪ́stəm ɪz ə krɪ́tɪkəl kəmpównənt əv kəmpjúwtər ɒ́pərèjtɪŋ sɪ́stəmz ðət ɔ́rɡənàjzɪz ənd mǽnɪdʒɪz háw déjtə ɪz stɔ́rd ənd rətríjvd. lájk ə səfɪ́stɪkèjtɪd lájbrɛərìj sɪ́stəm fɔr jɔr kəmpjúwtər, ɪt krijéjts ə lɒ́dʒɪkəl mɛ́θəd tə ɔ́rɡənàjz fájlz, prəvájdɪŋ néjmz, lowkéjʃənz, ənd ǽtrəbjùwts fɔr ɔl stɔ́rd déjtə. fájl sɪ́stəmz hǽndəl krúwʃəl tǽsks sʌtʃ æz trǽkɪŋ əvéjləbəl stɔ́rɪdʒ spéjs, mejntéjnɪŋ fájl mɛ̀tədéjtə (krijéjʃən déjts, pərmɪ́ʃənz, sájzɪz), əstǽblɪʃɪŋ hàjərɑ́rkɪkəl dɪərɛ́ktərij strʌ́ktʃərz, ənd ɛnʃʊ́rɪŋ déjtə ɪntɛ́ɡrɪtij. əɡzǽmpəlz ɪnklúwd NTFS júwzd baj wɪ́ndowz, EXT4 kɒ́mən ɪn lɪ́nəks, ənd APFS fɔr ǽpəl dəvájsɪz. wɪðáwt ə fájl sɪ́stəm, jɔr kəmpjúwtər wʊd həv now ɔ́rɡənàjzd wej tə stɔ́r, fájnd, ɔr mǽnɪdʒ ɛ́nij əv jɔr dɒ́kjəmənts, æ̀plɪkéjʃənz, ɔr sɪ́stəm fájlz, əsɛ́nʃəlij tɜ́rnɪŋ jɔr hɑ́rd drájv ɪntə ən ʌ̀njúwzəbəl púwl əv rǽndəm déjtə."
    },
    {
        "Question": "What is the term for an organized collection of structured information or data, typically stored electronically in a computer system, that allows for efficient retrieval, manipulation, and management of data?",
        "RightAnswer": "Database",
        "WrongAnswers": [
            "Algorithm",
            "Compiler",
            "Firewall",
            "Kernel",
            "Cache Memory"
        ],
        "Explanation": "A database is an organized collection of structured information or data, typically stored electronically in a computer system. Databases are designed to efficiently store, retrieve, manipulate, and manage large amounts of data. They provide a systematic way to organize information, making it easily accessible and modifiable. Modern databases use various models like relational (using tables with rows and columns), document-oriented, or graph-based structures to organize data. Database Management Systems (DBMS) like MySQL, PostgreSQL, or MongoDB provide interfaces for users to interact with databases through queries. Databases are fundamental to nearly all modern applications, from social media platforms to banking systems to online shopping, enabling them to maintain persistent data across sessions and users.",
        "trans_Question": "wɒt ɪz ðə tɜ́rm fɔr ən ɔ́rɡənàjzd kəlɛ́kʃən əv strʌ́ktʃərd ɪnfərméjʃən ɔr déjtə, tɪ́pɪkəlij stɔ́rd ələktrɒ́nɪkəlìj ɪn ə kəmpjúwtər sɪ́stəm, ðət əláwz fɔr əfɪ́ʃənt rətríjvəl, mənɪ̀pjəléjʃən, ənd mǽnədʒmənt əv déjtə?",
        "trans_RightAnswer": "déjtəbèjs",
        "trans_WrongAnswers": [
            "ǽlɡərɪ̀ðəm",
            "kəmpájlər",
            "fájərwɒl",
            "kɜ́rnəl",
            "kǽʃ mɛ́mərij"
        ],
        "trans_Explanation": "ə déjtəbèjs ɪz ən ɔ́rɡənàjzd kəlɛ́kʃən əv strʌ́ktʃərd ɪnfərméjʃən ɔr déjtə, tɪ́pɪkəlij stɔ́rd ələktrɒ́nɪkəlìj ɪn ə kəmpjúwtər sɪ́stəm. déjtəbèjsɪz ɑr dəzájnd tə əfɪ́ʃəntlij stɔ́r, rətríjv, mənɪ́pjəlèjt, ənd mǽnɪdʒ lɑ́rdʒ əmáwnts əv déjtə. ðej prəvájd ə sɪ̀stəmǽtɪk wej tə ɔ́rɡənàjz ɪnfərméjʃən, méjkɪŋ ɪt íjzəlij æksɛ́sɪbəl ənd mɒ́dəfajəbəl. mɒ́dərn déjtəbèjsɪz juwz vɛ́ərijəs mɒ́dəlz lájk rəléjʃənəl (júwzɪŋ téjbəlz wɪð rówz ənd kɒ́ləmz), dɒ́kjəmɛnt-ɔ́rijɛ̀ntɪd, ɔr ɡrǽf-béjst strʌ́ktʃərz tə ɔ́rɡənàjz déjtə. déjtəbèjs mǽnədʒmənt sɪ́stəmz (DBMS) lájk màjɛskjúwɛl, pɔstɡrɛ́skjùwl, ɔr mɒ́ŋɡow prəvájd ɪ́ntərfèjsɪz fɔr júwzərz tə ɪ̀ntərǽkt wɪð déjtəbèjsɪz θrúw kwɛ́ərijz. déjtəbèjsɪz ɑr fʌ̀ndəmɛ́ntəl tə nɪ́ərlij ɔl mɒ́dərn æ̀plɪkéjʃənz, frəm sówʃəl míjdijə plǽtfɔ̀rmz tə bǽŋkɪŋ sɪ́stəmz tə ɔ́nlàjn ʃɒ́pɪŋ, ɛnéjbəlɪŋ ðɛm tə mejntéjn pərsɪ́stənt déjtə əkrɔ́s sɛ́ʃənz ənd júwzərz."
    },
    {
        "Question": "Which language is specifically designed for managing and querying relational databases, allowing users to insert, update, retrieve, and delete data with commands like SELECT and JOIN?",
        "RightAnswer": "SQL",
        "WrongAnswers": [
            "Python",
            "HTML",
            "Java",
            "C++",
            "JavaScript"
        ],
        "Explanation": "SQL, which stands for Structured Query Language, is a specialized programming language designed for managing and manipulating relational databases. Unlike general-purpose programming languages, SQL focuses specifically on data operations. It allows users to define data structures, perform complex queries across multiple tables, and maintain data integrity through constraints. SQL uses a declarative syntax where users specify what data they want rather than how to retrieve it, making it accessible even to non-programmers. Common SQL operations include selecting data with filtering conditions, joining related tables, aggregating results, and modifying database contents. Nearly all major database systems including MySQL, PostgreSQL, Oracle, and Microsoft SQL Server use SQL as their primary interface, making it an essential skill for data analysts, software developers, and database administrators.",
        "trans_Question": "wɪ́tʃ lǽŋɡwədʒ ɪz spəsɪ́fɪklij dəzájnd fɔr mǽnɪdʒɪŋ ənd kwɛ́ərijɪŋ rəléjʃənəl déjtəbèjsɪz, əláwɪŋ júwzərz tə ɪnsɜ́rt, əpdéjt, rətríjv, ənd dəlíjt déjtə wɪð kəmǽndz lájk SELECT ənd JOIN?",
        "trans_RightAnswer": "SQL",
        "trans_WrongAnswers": [
            "pájθɒn",
            "HTML",
            "dʒɒ́və",
            "C++",
            "dʒɒ́vəskrɪ̀pt"
        ],
        "trans_Explanation": "SQL, wɪ́tʃ stǽndz fɔr strʌ́ktʃərd kwɛ́ərij lǽŋɡwədʒ, ɪz ə spɛ́ʃəlàjzd prówɡræ̀mɪŋ lǽŋɡwədʒ dəzájnd fɔr mǽnɪdʒɪŋ ənd mənɪ́pjəlèjtɪŋ rəléjʃənəl déjtəbèjsɪz. ʌ̀nlájk dʒɛ́nərəl-pɜ́rpəs prówɡræ̀mɪŋ lǽŋɡwədʒɪz, SQL fówkəsɪz spəsɪ́fɪklij ɒn déjtə ɒ̀pəréjʃənz. ɪt əláwz júwzərz tə dəfájn déjtə strʌ́ktʃərz, pərfɔ́rm kɒ́mplɛks kwɛ́ərijz əkrɔ́s mʌ́ltɪpəl téjbəlz, ənd mejntéjn déjtə ɪntɛ́ɡrɪtij θrúw kənstréjnts. SQL júwsɪz ə dəklǽrətɪv sɪ́ntæ̀ks wɛ́ər júwzərz spɛ́sɪfàj wɒt déjtə ðej wɒ́nt rǽðər ðʌn háw tə rətríjv ɪt, méjkɪŋ ɪt æksɛ́sɪbəl íjvən tə nɒn-prówɡræ̀mərz. kɒ́mən SQL ɒ̀pəréjʃənz ɪnklúwd səlɛ́ktɪŋ déjtə wɪð fɪ́ltərɪŋ kəndɪ́ʃənz, dʒɔ́jnɪŋ rəléjtɪd téjbəlz, ǽɡrəɡejtɪŋ rəzʌ́lts, ənd mɒ́dɪfàjɪŋ déjtəbèjs kɒ́ntɛnts. nɪ́ərlij ɔl méjdʒər déjtəbèjs sɪ́stəmz ɪnklúwdɪŋ màjɛskjúwɛl, pɔstɡrɛ́skjùwl, ɔ́rəkl, ənd májkròwsɔ́ft SQL sɜ́rvər juwz SQL æz ðɛər prájmɛ̀ərij ɪ́ntərfèjs, méjkɪŋ ɪt ən əsɛ́nʃəl skɪ́l fɔr déjtə ǽnəlɪsts, sɔ́ftwɛ̀ər dəvɛ́ləpərz, ənd déjtəbèjs ædmɪ́nɪstrèjtərz."
    },
    {
        "Question": "Which database technology is designed specifically to handle non-relational data models and is often used for big data and real-time web applications?",
        "RightAnswer": "NoSQL",
        "WrongAnswers": [
            "SQL+",
            "NewDB",
            "FlexStore",
            "NonRelational Query Language",
            "DataMesh"
        ],
        "Explanation": "NoSQL refers to a category of database management systems that diverge from the traditional relational database model. Unlike SQL databases which organize data in tables with predefined schemas, NoSQL databases are designed to handle unstructured or semi-structured data in more flexible ways. They typically scale horizontally rather than vertically, making them well-suited for distributed systems and big data applications. NoSQL encompasses various database types including document stores like MongoDB, key-value stores like Redis, column-family stores like Cassandra, and graph databases like Neo4j. These databases sacrifice some of the ACID properties of traditional databases in favor of performance, scalability, and flexibility, following what's known as the BASE model (Basically Available, Soft state, Eventually consistent). NoSQL solutions are particularly valuable in scenarios involving large volumes of rapidly changing data, complex data structures, or when high-throughput and low-latency are essential requirements.",
        "trans_Question": "wɪ́tʃ déjtəbèjs tɛknɒ́lədʒij ɪz dəzájnd spəsɪ́fɪklij tə hǽndəl nɒn-rəléjʃənəl déjtə mɒ́dəlz ənd ɪz ɔ́fən júwzd fɔr bɪ́ɡ déjtə ənd ríjəl-tájm wɛ́b æ̀plɪkéjʃənz?",
        "trans_RightAnswer": "now-sql",
        "trans_WrongAnswers": [
            "SQL+",
            "newDB",
            "flɛ́ksstɔr",
            "nɒ̀nrɪléjʃənəl kwɛ́ərij lǽŋɡwədʒ",
            "déjtəmɛ̀ʃ"
        ],
        "trans_Explanation": "now-sql rəfɜ́rz tə ə kǽtəɡɔ̀rij əv déjtəbèjs mǽnədʒmənt sɪ́stəmz ðət dajvɜ́rdʒ frəm ðə trədɪ́ʃənəl rəléjʃənəl déjtəbèjs mɒ́dəl. ʌ̀nlájk SQL déjtəbèjsɪz wɪ́tʃ ɔ́rɡənàjz déjtə ɪn téjbəlz wɪð prìjdəfájnd skíjməz, now-sql déjtəbèjsɪz ɑr dəzájnd tə hǽndəl ʌ̀nstrʌ́kʃərd ɔr sɛ́maj-strʌ́ktʃərd déjtə ɪn mɔr flɛ́ksɪbəl wéjz. ðej tɪ́pɪkəlij skéjl hɔ̀rɪzɒ́ntəlij rǽðər ðʌn vɜ́rtɪklij, méjkɪŋ ðɛm wɛ́l-súwtɪd fɔr dɪstrɪ́bjətɪd sɪ́stəmz ənd bɪ́ɡ déjtə æ̀plɪkéjʃənz. now-sql ɛnkʌ́mpəsɪz vɛ́ərijəs déjtəbèjs tájps ɪnklúwdɪŋ dɒ́kjəmɛnt stɔ́rz lájk mɒ́ŋɡow, kíj-vǽljuw stɔ́rz lájk rɛ́dɪs, kɒ́ləm-fǽmɪlij stɔ́rz lájk kəsǽndrə, ənd ɡrǽf déjtəbèjsɪz lájk neo4j. ðijz déjtəbèjsɪz sǽkrɪfàjs sʌm əv ðə ACID prɒ́pərtijz əv trədɪ́ʃənəl déjtəbèjsɪz ɪn féjvər əv pərfɔ́rməns, skéjləbɪ́lɪtij, ənd flɛ̀ksɪbɪ́lɪtij, fɒ́lowɪŋ wɒt's nówn æz ðə BASE mɒ́dəl (béjsɪklij əvéjləbəl, sɒ́ft stéjt, əvɛ́ntʃuwəlij kənsɪ́stənt). now-sql səlúwʃənz ɑr pərtɪ́kjələrlij vǽljəbəl ɪn sənɛ́ərijowz ɪnvɒ́lvɪŋ lɑ́rdʒ vɒ́ljuwmz əv rǽpɪdlij tʃéjndʒɪŋ déjtə, kɒ́mplɛks déjtə strʌ́ktʃərz, ɔr wɛ́n háj-θrúwpʊ̀t ənd lów-léjtənsij ɑr əsɛ́nʃəl rəkwájərmənts."
    },
    {
        "Question": "Which database model organizes data into tables with rows and columns, where relationships between data entities are established through keys?",
        "RightAnswer": "Relational Database",
        "WrongAnswers": [
            "Document-Oriented Database",
            "Graph Database",
            "Hierarchical Database",
            "Object Database",
            "Key-Value Store"
        ],
        "Explanation": "A Relational Database is a type of database that stores and organizes data in a structured format using tables composed of rows and columns. It is based on the relational model proposed by E.F. Codd in 1970. In this model, each table represents an entity, rows represent individual records, and columns represent attributes of those entities. The 'relational' aspect comes from the ability to establish relationships between tables using keys, particularly primary keys (unique identifiers for each record) and foreign keys (references to primary keys in other tables). This structure allows for data integrity, reduces redundancy, and enables complex queries through Structured Query Language (SQL). Relational databases are widely used in applications ranging from banking systems to e-commerce platforms due to their reliability, consistency, and ability to handle complex data relationships. Common examples include MySQL, PostgreSQL, Oracle, and Microsoft SQL Server.",
        "trans_Question": "wɪ́tʃ déjtəbèjs mɒ́dəl ɔ́rɡənàjzɪz déjtə ɪntə téjbəlz wɪð rówz ənd kɒ́ləmz, wɛ́ər rəléjʃənʃɪ̀ps bijtwíjn déjtə ɛ́ntɪtijz ɑr əstǽblɪʃt θrúw kíjz?",
        "trans_RightAnswer": "rəléjʃənəl déjtəbèjs",
        "trans_WrongAnswers": [
            "dɒ́kjəmɛnt-ɔ́rijɛ̀ntɪd déjtəbèjs",
            "ɡrǽf déjtəbèjs",
            "hàjərɑ́rkɪkəl déjtəbèjs",
            "ɒ́bdʒəkt déjtəbèjs",
            "kíj-vǽljuw stɔ́r"
        ],
        "trans_Explanation": "ə rəléjʃənəl déjtəbèjs ɪz ə tájp əv déjtəbèjs ðət stɔ́rz ənd ɔ́rɡənàjzɪz déjtə ɪn ə strʌ́ktʃərd fɔ́rmæ̀t júwzɪŋ téjbəlz kəmpówzd əv rówz ənd kɒ́ləmz. ɪt ɪz béjst ɒn ðə rəléjʃənəl mɒ́dəl prəpówzd baj E.F. kɒ́d ɪn 1970. ɪn ðɪs mɒ́dəl, ijtʃ téjbəl rɛ̀prəzɛ́nts ən ɛ́ntɪtij, rówz rɛ̀prəzɛ́nt ɪndɪvɪ́dʒəwəl rɛ́kərdz, ənd kɒ́ləmz rɛ̀prəzɛ́nt ǽtrəbjùwts əv ðowz ɛ́ntɪtijz. ðə 'rəléjʃənəl' ǽspɛkt kʌ́mz frəm ðə əbɪ́lɪtij tə əstǽblɪʃ rəléjʃənʃɪ̀ps bijtwíjn téjbəlz júwzɪŋ kíjz, pərtɪ́kjələrlij prájmɛ̀ərij kíjz (juwnɪ́k ajdɛ́ntɪfàjərz fɔr ijtʃ rɛ́kɔrd) ənd fɑ́rən kíjz (rɛ́fərənsɪz tə prájmɛ̀ərij kíjz ɪn ʌ́ðər téjbəlz). ðɪs strʌ́ktʃər əláwz fɔr déjtə ɪntɛ́ɡrɪtij, rədjúwsɪz rədʌ́ndənsij, ənd ɛnéjbəlz kɒ́mplɛks kwɛ́ərijz θrúw strʌ́ktʃərd kwɛ́ərij lǽŋɡwədʒ (SQL). rəléjʃənəl déjtəbèjsɪz ɑr wájdlij júwzd ɪn æ̀plɪkéjʃənz réjndʒɪŋ frəm bǽŋkɪŋ sɪ́stəmz tə e-kɒ́mərs plǽtfɔ̀rmz djúw tə ðɛər rəlàjəbɪ́lɪtij, kənsɪ́stənsij, ənd əbɪ́lɪtij tə hǽndəl kɒ́mplɛks déjtə rəléjʃənʃɪ̀ps. kɒ́mən əɡzǽmpəlz ɪnklúwd màjɛskjúwɛl, pɔstɡrɛ́skjùwl, ɔ́rəkl, ənd májkròwsɔ́ft SQL sɜ́rvər."
    },
    {
        "Question": "What technique allows developers to interact with relational databases using object-oriented programming concepts, effectively bridging the gap between incompatible programming paradigms?",
        "RightAnswer": "Object-Relational Mapping",
        "WrongAnswers": [
            "Database Schema Translation",
            "Query Language Integration",
            "Structured Data Modeling",
            "Entity Relationship Conversion",
            "Imperative Database Access"
        ],
        "Explanation": "Object-Relational Mapping, often abbreviated as ORM, is a programming technique that enables developers to work with data from relational databases using object-oriented programming languages. It essentially creates a virtual object database that can be used within the programming language. This solves a fundamental mismatch problem: relational databases organize data in tables, rows, and columns, while object-oriented languages represent data as interconnected objects. ORMs like Hibernate, Entity Framework, or SQLAlchemy automatically handle the conversion between these two worlds, allowing developers to write database operations using familiar object-oriented syntax rather than SQL queries. This provides advantages such as reduced code verbosity, increased development speed, and better maintainability. By abstracting away the database-specific code, ORMs also make applications more portable across different database systems.",
        "trans_Question": "wɒt tɛkníjk əláwz dəvɛ́ləpərz tə ɪ̀ntərǽkt wɪð rəléjʃənəl déjtəbèjsɪz júwzɪŋ ɒ́bdʒəkt-ɔ́rijɛ̀ntɪd prówɡræ̀mɪŋ kɒ́nsɛpts, əfɛ́ktɪvlij brɪ́dʒɪŋ ðə ɡǽp bijtwíjn ɪ̀nkəmpǽtɪbəl prówɡræ̀mɪŋ pǽrədàjmz?",
        "trans_RightAnswer": "ɒ́bdʒəkt-rəléjʃənəl mǽpɪŋ",
        "trans_WrongAnswers": [
            "déjtəbèjs skíjmə trænsléjʃən",
            "kwɛ́ərij lǽŋɡwədʒ ɪntəɡrejʃən",
            "strʌ́ktʃərd déjtə mɒ́dəlɪ̀ŋ",
            "ɛ́ntɪtij rəléjʃənʃɪ̀p kənvɜ́rʒən",
            "ɪ̀mpɛ́ərətɪv déjtəbèjs ǽksɛ̀s"
        ],
        "trans_Explanation": "ɒ́bdʒəkt-rəléjʃənəl mǽpɪŋ, ɔ́fən əbríjvijèjtɪd æz ORM, ɪz ə prówɡræ̀mɪŋ tɛkníjk ðət ɛnéjbəlz dəvɛ́ləpərz tə wɜ́rk wɪð déjtə frəm rəléjʃənəl déjtəbèjsɪz júwzɪŋ ɒ́bdʒəkt-ɔ́rijɛ̀ntɪd prówɡræ̀mɪŋ lǽŋɡwədʒɪz. ɪt əsɛ́nʃəlij krijéjts ə vɜ́rtʃuwəl ɒ́bdʒəkt déjtəbèjs ðət kən bij júwzd wɪðɪ́n ðə prówɡræ̀mɪŋ lǽŋɡwədʒ. ðɪs sɒ́lvz ə fʌ̀ndəmɛ́ntəl mɪ́smæ̀tʃ prɒ́bləm: rəléjʃənəl déjtəbèjsɪz ɔ́rɡənàjz déjtə ɪn téjbəlz, rówz, ənd kɒ́ləmz, wájl ɒ́bdʒəkt-ɔ́rijɛ̀ntɪd lǽŋɡwədʒɪz rɛ̀prəzɛ́nt déjtə æz ɪ̀ntərkənɛ́ktɪd ɒ́bdʒɛkts. ɔrmz lájk hájbərnèjt, ɛ́ntɪtij fréjmwɜ̀rk, ɔr ɛ̀skjuwɛ́l ɔ̀təmǽtɪklij hǽndəl ðə kənvɜ́rʒən bijtwíjn ðijz túw wɜ́rldz, əláwɪŋ dəvɛ́ləpərz tə rájt déjtəbèjs ɒ̀pəréjʃənz júwzɪŋ fəmɪ́ljər ɒ́bdʒəkt-ɔ́rijɛ̀ntɪd sɪ́ntæ̀ks rǽðər ðʌn SQL kwɛ́ərijz. ðɪs prəvájdz ədvǽntɪdʒɪz sʌtʃ æz rədjúwst kówd vərbɒ́sɪtij, ɪnkríjst dəvɛ́ləpmənt spíjd, ənd bɛ́tər mejntéjnəbɪ́lɪtij. baj ǽbstræktɪŋ əwéj ðə déjtəbèjs-spəsɪ́fɪk kówd, ɔrmz ɔ́lsow méjk æ̀plɪkéjʃənz mɔr pɔ́rtəbəl əkrɔ́s dɪ́fərənt déjtəbèjs sɪ́stəmz."
    },
    {
        "Question": "In database management systems, what term describes the four key properties that guarantee reliable transaction processing even during system failures?",
        "RightAnswer": "ACID Properties",
        "WrongAnswers": [
            "BASE Guidelines",
            "CRUD Operations",
            "CAP Theorem",
            "SOLID Principles",
            "REST Architecture"
        ],
        "Explanation": "ACID Properties represent fundamental guarantees for database transactions that ensure data integrity. The acronym stands for Atomicity, Consistency, Isolation, and Durability. Atomicity means a transaction is treated as a single, indivisible unit that either completes entirely or not at all. Consistency ensures that a transaction brings the database from one valid state to another, maintaining all predefined rules. Isolation keeps concurrent transactions separate from each other until they are complete, preventing interference. Durability guarantees that once a transaction is committed, it remains so even if system failures occur afterward. These properties are particularly crucial in financial systems, inventory management, and any application where data integrity cannot be compromised. While modern distributed systems sometimes relax these properties for performance reasons, understanding ACID remains essential for anyone working with databases and transaction processing.",
        "trans_Question": "ɪn déjtəbèjs mǽnədʒmənt sɪ́stəmz, wɒt tɜ́rm dəskrájbz ðə fɔ́r kíj prɒ́pərtijz ðət ɡɛ̀ərəntíj rəlájəbəl trænzǽkʃən prɒ́sɛsɪŋ íjvən dʊ́rɪŋ sɪ́stəm féjljərz?",
        "trans_RightAnswer": "ACID prɒ́pərtijz",
        "trans_WrongAnswers": [
            "BASE ɡájdlàjnz",
            "CRUD ɒ̀pəréjʃənz",
            "CAP θɪ́ərəm",
            "SOLID prɪ́nsɪpəlz",
            "REST ɑ́rkɪtɛ̀ktʃər"
        ],
        "trans_Explanation": "ACID prɒ́pərtijz rɛ̀prəzɛ́nt fʌ̀ndəmɛ́ntəl ɡɛ̀ərəntíjz fɔr déjtəbèjs trænzǽkʃənz ðət ənʃʊ́r déjtə ɪntɛ́ɡrɪtij. ðə ǽkrənɪm stǽndz fɔr ətɒ́mɪsɪtij, kənsɪ́stənsij, àjsəléjʃən, ənd dərəbɪ́lɪtij. ətɒ́mɪsɪtij míjnz ə trænzǽkʃən ɪz tríjtɪd æz ə sɪ́ŋɡəl, ɪndɪvɪ́sɪbəl júwnɪt ðət ájðər kəmplíjts əntájərlij ɔr nɒt æt ɔl. kənsɪ́stənsij ənʃʊ́rz ðət ə trænzǽkʃən brɪ́ŋz ðə déjtəbèjs frəm wʌ́n vǽlɪd stéjt tə ənʌ́ðər, mejntéjnɪŋ ɔl prìjdəfájnd rúwlz. àjsəléjʃən kíjps kənkɜ́rənt trænzǽkʃənz sɛ́pərət frəm ijtʃ ʌ́ðər əntɪ́l ðej ɑr kəmplíjt, prəvɛ́ntɪŋ ɪ̀ntərfɪ́ərəns. dərəbɪ́lɪtij ɡɛ̀ərəntíjz ðət wʌ́ns ə trænzǽkʃən ɪz kəmɪ́tɪd, ɪt rəméjnz sow íjvən ɪf sɪ́stəm féjljərz əkɜ́r ǽftərwərd. ðijz prɒ́pərtijz ɑr pərtɪ́kjələrlij krúwʃəl ɪn fàjnǽnʃəl sɪ́stəmz, ɪnvəntɔ́rij mǽnədʒmənt, ənd ɛ́nij æ̀plɪkéjʃən wɛ́ər déjtə ɪntɛ́ɡrɪtij kǽnɒt bij kɒ́mprəmajzd. wájl mɒ́dərn dɪstrɪ́bjətɪd sɪ́stəmz sʌ́mtàjmz rijlǽks ðijz prɒ́pərtijz fɔr pərfɔ́rməns ríjzənz, ʌ̀ndərstǽndɪŋ ACID rəméjnz əsɛ́nʃəl fɔr ɛ́nijwən wɜ́rkɪŋ wɪð déjtəbèjsɪz ənd trænzǽkʃən prɒ́sɛsɪŋ."
    },
    {
        "Question": "What is the term for a centralized repository that stores and manages integrated data from multiple sources to support business intelligence and decision-making processes?",
        "RightAnswer": "Data Warehouse",
        "WrongAnswers": [
            "Data Lake",
            "Database Cluster",
            "Information Silo",
            "Memory Cache",
            "Query Optimizer"
        ],
        "Explanation": "A Data Warehouse is a specialized system designed to support business intelligence activities by collecting, integrating, and storing data from various sources in a consistent format optimized for analytical queries and reporting. Unlike traditional operational databases that focus on day-to-day transactions, a Data Warehouse is specifically structured to analyze historical data across the organization. It typically follows a dimensional model with fact and dimension tables, enabling complex queries across multiple business domains. Data Warehouses implement ETL (Extract, Transform, Load) processes to cleanse and organize data before storage, ensuring data quality and consistency. They are crucial for organizations seeking to derive insights from their historical data, support strategic decision-making, and identify trends that might not be visible when looking at isolated data sources. Modern Data Warehouses often support features like data mining, real-time analytics, and integration with business intelligence tools to provide comprehensive analytical capabilities.",
        "trans_Question": "wɒt ɪz ðə tɜ́rm fɔr ə sɛ́ntrəlàjzd rijpɒ́zɪtɔ̀rij ðət stɔ́rz ənd mǽnɪdʒɪz ɪ́ntəɡrejtɪd déjtə frəm mʌ́ltɪpəl sɔ́rsɪz tə səpɔ́rt bɪ́znəs ɪntɛ́lɪdʒəns ənd dəsɪ́ʒən-méjkɪŋ prɒ́sɛsɪz?",
        "trans_RightAnswer": "déjtə wɛ́ərhàws",
        "trans_WrongAnswers": [
            "déjtə léjk",
            "déjtəbèjs klʌ́stər",
            "ɪnfərméjʃən sájlow",
            "mɛ́mərij kǽʃ",
            "kwɛ́ərij ɒ́ptəmajzər"
        ],
        "trans_Explanation": "ə déjtə wɛ́ərhàws ɪz ə spɛ́ʃəlàjzd sɪ́stəm dəzájnd tə səpɔ́rt bɪ́znəs ɪntɛ́lɪdʒəns æktɪ́vɪtijz baj kəlɛ́ktɪŋ, ɪ́ntəɡrejtɪŋ, ənd stɔ́rɪŋ déjtə frəm vɛ́ərijəs sɔ́rsɪz ɪn ə kənsɪ́stənt fɔ́rmæ̀t ɒ́ptɪmàjzd fɔr æ̀nəlɪ́tɪkəl kwɛ́ərijz ənd rijpɔ́rtɪŋ. ʌ̀nlájk trədɪ́ʃənəl ɒ̀pəréjʃənəl déjtəbèjsɪz ðət fówkəs ɒn déj-tə-déj trænzǽkʃənz, ə déjtə wɛ́ərhàws ɪz spəsɪ́fɪklij strʌ́ktʃərd tə ǽnəlàjz hɪstɔ́rɪkəl déjtə əkrɔ́s ðə ɔ̀rɡənɪzéjʃən. ɪt tɪ́pɪkəlij fɒ́lowz ə dajmɛ́nʃənəl mɒ́dəl wɪð fǽkt ənd dajmɛ́nʃən téjbəlz, ɛnéjbəlɪŋ kɒ́mplɛks kwɛ́ərijz əkrɔ́s mʌ́ltɪpəl bɪ́znəs dowméjnz. déjtə wɛ́ərhàwsɪz ɪ́mpləmənt ETL (ɛ́kstrəkt, trǽnsfɔrm, lówd) prɒ́sɛsɪz tə klɛ́nz ənd ɔ́rɡənàjz déjtə bəfɔ́r stɔ́rɪdʒ, ɛnʃʊ́rɪŋ déjtə kwɑ́lɪtij ənd kənsɪ́stənsij. ðej ɑr krúwʃəl fɔr ɔ̀rɡənɪzéjʃənz síjkɪŋ tə dərájv ɪ́nsàjts frəm ðɛər hɪstɔ́rɪkəl déjtə, səpɔ́rt strətíjdʒɪk dəsɪ́ʒən-méjkɪŋ, ənd ajdɛ́ntɪfàj trɛ́ndz ðət majt nɒt bij vɪ́zɪbəl wɛ́n lʊ́kɪŋ æt ájsəlèjtɪd déjtə sɔ́rsɪz. mɒ́dərn déjtə wɛ́ərhàwsɪz ɔ́fən səpɔ́rt fíjtʃərz lájk déjtə májnɪŋ, ríjəl-tájm æ̀nəlɪ́tɪks, ənd ɪntəɡrejʃən wɪð bɪ́znəs ɪntɛ́lɪdʒəns túwlz tə prəvájd kɒ̀mprəhɛ́nsɪv æ̀nəlɪ́tɪkəl kèjpəbɪ́lɪtijz."
    },
    {
        "Question": "Which architecture allows organizations to store raw, unprocessed data from multiple sources in its native format until it's needed for analysis?",
        "RightAnswer": "Data Lake",
        "WrongAnswers": [
            "Data Warehouse",
            "Database Cluster",
            "Object Repository",
            "File Archive System",
            "Memory Cache Network"
        ],
        "Explanation": "A Data Lake is a storage repository that holds a vast amount of raw data in its native format until it is needed for processing. Unlike traditional data warehouses that store data in hierarchical files or folders, Data Lakes use a flat architecture and can include structured data from relational databases, semi-structured data like CSV or JSON files, unstructured data such as emails and documents, and even binary data like images and videos. The key advantage of a Data Lake is its flexibility: data can be stored without having to be transformed or processed first, allowing organizations to collect data now and determine its use later. Data Lakes are particularly valuable for big data analytics, machine learning applications, and when businesses need to preserve the original form of information for future analysis that might not be anticipated at collection time. However, without proper governance, Data Lakes can become disorganized 'data swamps' that are difficult to navigate and extract value from.",
        "trans_Question": "wɪ́tʃ ɑ́rkɪtɛ̀ktʃər əláwz ɔ̀rɡənɪzéjʃənz tə stɔ́r rɔ́, ʌ̀nprɔ́sɛ̀st déjtə frəm mʌ́ltɪpəl sɔ́rsɪz ɪn ɪts néjtɪv fɔ́rmæ̀t əntɪ́l ɪt's níjdɪd fɔr ənǽlɪsɪs?",
        "trans_RightAnswer": "déjtə léjk",
        "trans_WrongAnswers": [
            "déjtə wɛ́ərhàws",
            "déjtəbèjs klʌ́stər",
            "ɒ́bdʒəkt rijpɒ́zɪtɔ̀rij",
            "fájl ɑ́rkàjv sɪ́stəm",
            "mɛ́mərij kǽʃ nɛ́twɜ̀rk"
        ],
        "trans_Explanation": "ə déjtə léjk ɪz ə stɔ́rɪdʒ rijpɒ́zɪtɔ̀rij ðət hówldz ə vǽst əmáwnt əv rɔ́ déjtə ɪn ɪts néjtɪv fɔ́rmæ̀t əntɪ́l ɪt ɪz níjdɪd fɔr prɒ́sɛsɪŋ. ʌ̀nlájk trədɪ́ʃənəl déjtə wɛ́ərhàwsɪz ðət stɔ́r déjtə ɪn hàjərɑ́rkɪkəl fájlz ɔr fówldərz, déjtə léjks juwz ə flǽt ɑ́rkɪtɛ̀ktʃər ənd kən ɪnklúwd strʌ́ktʃərd déjtə frəm rəléjʃənəl déjtəbèjsɪz, sɛ́maj-strʌ́ktʃərd déjtə lájk CSV ɔr JSON fájlz, ʌ̀nstrʌ́kʃərd déjtə sʌtʃ æz íjmejlz ənd dɒ́kjəmənts, ənd íjvən bájnərij déjtə lájk ɪ́mɪdʒɪz ənd vɪ́dijowz. ðə kíj ədvǽntɪdʒ əv ə déjtə léjk ɪz ɪts flɛ̀ksɪbɪ́lɪtij: déjtə kən bij stɔ́rd wɪðáwt hǽvɪŋ tə bij trænsfɔ́rmd ɔr prɒ́sɛst fɜ́rst, əláwɪŋ ɔ̀rɡənɪzéjʃənz tə kəlɛ́kt déjtə náw ənd dətɜ́rmɪn ɪts juwz léjtər. déjtə léjks ɑr pərtɪ́kjələrlij vǽljəbəl fɔr bɪ́ɡ déjtə æ̀nəlɪ́tɪks, məʃíjn lɜ́rnɪŋ æ̀plɪkéjʃənz, ənd wɛ́n bɪ́znəsɪz níjd tə prəzɜ́rv ðə ərɪ́dʒɪnəl fɔ́rm əv ɪnfərméjʃən fɔr fjúwtʃər ənǽlɪsɪs ðət majt nɒt bij æntɪ́sɪpèjtɪd æt kəlɛ́kʃən tájm. hàwɛ́vər, wɪðáwt prɒ́pər ɡʌ́vərnəns, déjtə léjks kən bəkʌ́m dɪsɔ́rɡənàjzd 'déjtə swɒ́mps' ðət ɑr dɪ́fɪkəlt tə nǽvɪɡejt ənd ɛ́kstrəkt vǽljuw frəm."
    },
    {
        "Question": "In a data warehouse implementation project, which process is responsible for retrieving data from multiple sources, standardizing it, and moving it into a central repository?",
        "RightAnswer": "ETL (Extract, Transform, Load)",
        "WrongAnswers": [
            "API (Application Programming Interface)",
            "CRUD (Create, Read, Update, Delete)",
            "DNS (Domain Name System)",
            "ORM (Object-Relational Mapping)",
            "SOAP (Simple Object Access Protocol)"
        ],
        "Explanation": "ETL stands for Extract, Transform, Load, which is a three-step process used in data integration and warehousing. First, during the Extract phase, data is collected from various sources such as databases, applications, files, or external systems. Next, the Transform phase involves cleaning, standardizing, and converting the data into a consistent format—this might include filtering out irrelevant information, handling missing values, or applying business rules. Finally, the Load phase moves this processed data into a destination system, typically a data warehouse or data lake, where it can be analyzed and used for business intelligence. ETL processes form the backbone of modern data analytics ecosystems, enabling organizations to consolidate disparate data sources into meaningful, actionable information for decision-making.",
        "trans_Question": "ɪn ə déjtə wɛ́ərhàws ɪ̀mpləmɛntéjʃən prɒ́dʒɛkt, wɪ́tʃ prɒ́sɛs ɪz rəspɒ́nsɪbəl fɔr rətríjvɪŋ déjtə frəm mʌ́ltɪpəl sɔ́rsɪz, stǽndərdàjzɪŋ ɪt, ənd múwvɪŋ ɪt ɪntə ə sɛ́ntrəl rijpɒ́zɪtɔ̀rij?",
        "trans_RightAnswer": "ETL (ɛ́kstrəkt, trǽnsfɔrm, lówd)",
        "trans_WrongAnswers": [
            "API (æ̀plɪkéjʃən prówɡræ̀mɪŋ ɪ́ntərfèjs)",
            "CRUD (krijéjt, rɛ́d, əpdéjt, dəlíjt)",
            "DNS (dowméjn néjm sɪ́stəm)",
            "ORM (ɒ́bdʒəkt-rəléjʃənəl mǽpɪŋ)",
            "SOAP (sɪ́mpəl ɒ́bdʒəkt ǽksɛ̀s prówtəkɒ̀l)"
        ],
        "trans_Explanation": "ETL stǽndz fɔr ɛ́kstrəkt, trǽnsfɔrm, lówd, wɪ́tʃ ɪz ə θríj-stɛ́p prɒ́sɛs júwzd ɪn déjtə ɪntəɡrejʃən ənd wɛ́ərhàwzɪŋ. fɜ́rst, dʊ́rɪŋ ðə ɛ́kstrəkt féjz, déjtə ɪz kəlɛ́ktɪd frəm vɛ́ərijəs sɔ́rsɪz sʌtʃ æz déjtəbèjsɪz, æ̀plɪkéjʃənz, fájlz, ɔr əkstɜ́rnəl sɪ́stəmz. nɛ́kst, ðə trǽnsfɔrm féjz ɪnvɒ́lvz klíjnɪŋ, stǽndərdàjzɪŋ, ənd kənvɜ́rtɪŋ ðə déjtə ɪntə ə kənsɪ́stənt fɔ́rmæ̀t—ðɪs majt ɪnklúwd fɪ́ltərɪŋ awt ɪ̀ərɛ́ləvənt ɪnfərméjʃən, hǽndəlɪŋ mɪ́sɪŋ vǽljuwz, ɔr əplájɪŋ bɪ́znəs rúwlz. fájnəlij, ðə lówd féjz múwvz ðɪs prɒ́sɛst déjtə ɪntə ə dɛ̀stɪnéjʃən sɪ́stəm, tɪ́pɪkəlij ə déjtə wɛ́ərhàws ɔr déjtə léjk, wɛ́ər ɪt kən bij ǽnəlàjzd ənd júwzd fɔr bɪ́znəs ɪntɛ́lɪdʒəns. ETL prɒ́sɛsɪz fɔ́rm ðə bǽkbòwn əv mɒ́dərn déjtə æ̀nəlɪ́tɪks íjkowsɪ̀stəmz, ɛnéjbəlɪŋ ɔ̀rɡənɪzéjʃənz tə kənsɒ́lɪdèjt dɪ́spərət déjtə sɔ́rsɪz ɪntə míjnɪŋfəl, ǽkʃənəbəl ɪnfərméjʃən fɔr dəsɪ́ʒən-méjkɪŋ."
    },
    {
        "Question": "What is the process of creating an abstract representation of a system that describes how data is stored, connected, and accessed within a database?",
        "RightAnswer": "Data Modeling",
        "WrongAnswers": [
            "Algorithm Design",
            "Data Mining",
            "Network Topology",
            "Compiler Construction",
            "Memory Allocation"
        ],
        "Explanation": "Data Modeling is the process of creating conceptual representations of data objects, their relationships, and the rules governing how data is structured and manipulated within information systems. It serves as a blueprint for database design, helping developers visualize complex data requirements before implementation. Data models typically exist at different levels of abstraction: conceptual models focus on high-level business concepts, logical models address data relationships independent of specific database technologies, and physical models detail how data will be implemented in a particular database system. Effective data modeling ensures data integrity, reduces redundancy, improves system performance, and facilitates communication between technical and non-technical stakeholders about data requirements. In modern computing, data modeling remains essential whether working with traditional relational databases, NoSQL systems, or big data architectures.",
        "trans_Question": "wɒt ɪz ðə prɒ́sɛs əv krijéjtɪŋ ən ǽbstræ̀kt rɛ̀prəzɛntéjʃən əv ə sɪ́stəm ðət dəskrájbz háw déjtə ɪz stɔ́rd, kənɛ́ktɪd, ənd ǽksɛ̀st wɪðɪ́n ə déjtəbèjs?",
        "trans_RightAnswer": "déjtə mɒ́dəlɪ̀ŋ",
        "trans_WrongAnswers": [
            "ǽlɡərɪ̀ðəm dəzájn",
            "déjtə májnɪŋ",
            "nɛ́twɜ̀rk təpɔ́lədʒij",
            "kəmpájlər kənstrʌ́kʃən",
            "mɛ́mərij æ̀ləkéjʃən"
        ],
        "trans_Explanation": "déjtə mɒ́dəlɪ̀ŋ ɪz ðə prɒ́sɛs əv krijéjtɪŋ kənsɛ́ptʃuwəl rɛ̀prəzəntéjʃənz əv déjtə ɒ́bdʒɛkts, ðɛər rəléjʃənʃɪ̀ps, ənd ðə rúwlz ɡʌ́vərnɪŋ háw déjtə ɪz strʌ́ktʃərd ənd mənɪ́pjəlèjtɪd wɪðɪ́n ɪnfərméjʃən sɪ́stəmz. ɪt sɜ́rvz æz ə blúwprɪ̀nt fɔr déjtəbèjs dəzájn, hɛ́lpɪŋ dəvɛ́ləpərz vɪ́ʒwəlàjz kɒ́mplɛks déjtə rəkwájərmənts bəfɔ́r ɪ̀mpləmɛntéjʃən. déjtə mɒ́dəlz tɪ́pɪkəlij əɡzɪ́st æt dɪ́fərənt lɛ́vəlz əv æbstrǽkʃən: kənsɛ́ptʃuwəl mɒ́dəlz fówkəs ɒn háj-lɛ́vəl bɪ́znəs kɒ́nsɛpts, lɒ́dʒɪkəl mɒ́dəlz æ̀drɛ́s déjtə rəléjʃənʃɪ̀ps ɪndəpɛ́ndənt əv spəsɪ́fɪk déjtəbèjs tɛknɒ́lədʒijz, ənd fɪ́zɪkəl mɒ́dəlz díjtejl háw déjtə wɪl bij ɪ́mpləmɛ̀ntɪd ɪn ə pərtɪ́kjələr déjtəbèjs sɪ́stəm. əféktɪv déjtə mɒ́dəlɪ̀ŋ ənʃʊ́rz déjtə ɪntɛ́ɡrɪtij, rədjúwsɪz rədʌ́ndənsij, ɪmprúwvz sɪ́stəm pərfɔ́rməns, ənd fəsɪ́lətèjts kəmjùwnɪkéjʃən bijtwíjn tɛ́knɪkəl ənd nɒn-tɛ́knɪkəl stéjkhòwldərz əbawt déjtə rəkwájərmənts. ɪn mɒ́dərn kəmpjúwtɪŋ, déjtə mɒ́dəlɪ̀ŋ rəméjnz əsɛ́nʃəl wɛ́ðər wɜ́rkɪŋ wɪð trədɪ́ʃənəl rəléjʃənəl déjtəbèjsɪz, now-sql sɪ́stəmz, ɔr bɪ́ɡ déjtə ɑ́rkɪtɛ̀ktʃərz."
    },
    {
        "Question": "In database design, what term describes the formal structure that defines the organization, constraints, and relationships of data within a database?",
        "RightAnswer": "Schema",
        "WrongAnswers": [
            "Query",
            "Instance",
            "Protocol",
            "Partition",
            "Middleware"
        ],
        "Explanation": "A schema in computer science refers to a blueprint or structural framework that defines how data is organized within a database or information system. It specifies the logical structure of data, including tables, fields, relationships, constraints, and data types. Think of a schema as an architect's blueprint, but for data organization instead of buildings. Schemas are crucial because they enforce data integrity, provide a common vocabulary for developers and users, and establish rules for how information can be stored, accessed, and manipulated. Database schemas can exist at different levels of abstraction, from conceptual schemas that outline general data relationships to physical schemas that detail how data is actually stored in memory. Schemas also play important roles in XML documents, programming languages, and data exchange formats, where they define the expected structure of information.",
        "trans_Question": "ɪn déjtəbèjs dəzájn, wɒt tɜ́rm dəskrájbz ðə fɔ́rməl strʌ́ktʃər ðət dəfájnz ðə ɔ̀rɡənɪzéjʃən, kənstréjnts, ənd rəléjʃənʃɪ̀ps əv déjtə wɪðɪ́n ə déjtəbèjs?",
        "trans_RightAnswer": "skíjmə",
        "trans_WrongAnswers": [
            "kwɛ́ərij",
            "ɪ́nstəns",
            "prówtəkɒ̀l",
            "pɑrtɪ́ʃən",
            "mɪ́dəlwɛər"
        ],
        "trans_Explanation": "ə skíjmə ɪn kəmpjúwtər sájəns rəfɜ́rz tə ə blúwprɪ̀nt ɔr strʌ́ktʃərəl fréjmwɜ̀rk ðət dəfájnz háw déjtə ɪz ɔ́rɡənàjzd wɪðɪ́n ə déjtəbèjs ɔr ɪnfərméjʃən sɪ́stəm. ɪt spɛ́sɪfàjz ðə lɒ́dʒɪkəl strʌ́ktʃər əv déjtə, ɪnklúwdɪŋ téjbəlz, fíjldz, rəléjʃənʃɪ̀ps, kənstréjnts, ənd déjtə tájps. θɪ́ŋk əv ə skíjmə æz ən ɑ́rkɪtɛ̀kt's blúwprɪ̀nt, bʌt fɔr déjtə ɔ̀rɡənɪzéjʃən ɪnstɛ́d əv bɪ́ldɪŋz. skíjməz ɑr krúwʃəl bəkɒ́z ðej ɛnfɔ́rs déjtə ɪntɛ́ɡrɪtij, prəvájd ə kɒ́mən vowkǽbjəlɛ̀ərij fɔr dəvɛ́ləpərz ənd júwzərz, ənd əstǽblɪʃ rúwlz fɔr háw ɪnfərméjʃən kən bij stɔ́rd, ǽksɛ̀st, ənd mənɪ́pjəlèjtɪd. déjtəbèjs skíjməz kən əɡzɪ́st æt dɪ́fərənt lɛ́vəlz əv æbstrǽkʃən, frəm kənsɛ́ptʃuwəl skíjməz ðət áwtlàjn dʒɛ́nərəl déjtə rəléjʃənʃɪ̀ps tə fɪ́zɪkəl skíjməz ðət díjtejl háw déjtə ɪz ǽktʃùwəlij stɔ́rd ɪn mɛ́mərij. skíjməz ɔ́lsow pléj ɪmpɔ́rtənt rówlz ɪn XML dɒ́kjəmənts, prówɡræ̀mɪŋ lǽŋɡwədʒɪz, ənd déjtə əkstʃéjndʒ fɔ́rmæ̀ts, wɛ́ər ðej dəfájn ðə əkspɛ́ktɪd strʌ́ktʃər əv ɪnfərméjʃən."
    },
    {
        "Question": "In database management systems, what is the process of analyzing query execution plans and selecting the most efficient way to execute a given SQL statement?",
        "RightAnswer": "Query Optimization",
        "WrongAnswers": [
            "Data Normalization",
            "Index Partitioning",
            "Cache Coherence",
            "Transaction Isolation",
            "Schema Integration"
        ],
        "Explanation": "Query Optimization is the process where a database system attempts to find the most efficient way to execute a SQL query. When a query is submitted, the database engine evaluates multiple possible execution strategies and selects the one estimated to have the lowest cost in terms of CPU time, memory usage, and disk I/O operations. This involves analyzing factors such as available indexes, table sizes, data distribution statistics, and join methods. A good query optimizer can dramatically improve performance, turning queries that might take hours into ones that complete in seconds. Query optimization combines aspects of cost estimation, algorithm selection, and sometimes even query rewriting to transform user requests into the fastest possible database operations. It represents one of the most sophisticated aspects of database management systems, as it requires balancing immediate execution costs against long-term performance considerations.",
        "trans_Question": "ɪn déjtəbèjs mǽnədʒmənt sɪ́stəmz, wɒt ɪz ðə prɒ́sɛs əv ǽnəlàjzɪŋ kwɛ́ərij ɛ̀ksəkjúwʃən plǽnz ənd səlɛ́ktɪŋ ðə mówst əfɪ́ʃənt wej tə ɛ́ksəkjùwt ə ɡɪ́vən SQL stéjtmənt?",
        "trans_RightAnswer": "kwɛ́ərij ɒptɪmɪzéjʃən",
        "trans_WrongAnswers": [
            "déjtə nɔ̀rməlɪzéjʃən",
            "ɪ́ndɛks pɑrtɪ́ʃənɪŋ",
            "kǽʃ kowhɪ́ərəns",
            "trænzǽkʃən àjsəléjʃən",
            "skíjmə ɪntəɡrejʃən"
        ],
        "trans_Explanation": "kwɛ́ərij ɒptɪmɪzéjʃən ɪz ðə prɒ́sɛs wɛ́ər ə déjtəbèjs sɪ́stəm ətɛ́mpts tə fájnd ðə mówst əfɪ́ʃənt wej tə ɛ́ksəkjùwt ə SQL kwɛ́ərij. wɛ́n ə kwɛ́ərij ɪz səbmɪ́tɪd, ðə déjtəbèjs ɛ́ndʒɪn əvǽljuwèjts mʌ́ltɪpəl pɒ́sɪbəl ɛ̀ksəkjúwʃən strǽtədʒijz ənd səlɛ́kts ðə wʌ́n ɛ́stɪmèjtɪd tə həv ðə lówəst kɒ́st ɪn tɜ́rmz əv CPU tájm, mɛ́mərij júwsɪdʒ, ənd dɪ́sk I/O ɒ̀pəréjʃənz. ðɪs ɪnvɒ́lvz ǽnəlàjzɪŋ fǽktərz sʌtʃ æz əvéjləbəl ɪ́ndɛksɪz, téjbəl sájzɪz, déjtə dɪ̀strəbjúwʃən stətɪ́stɪks, ənd dʒɔ́jn mɛ́θədz. ə ɡʊ́d kwɛ́ərij ɒ́ptəmajzər kən drəmǽtɪkəlij ɪmprúwv pərfɔ́rməns, tɜ́rnɪŋ kwɛ́ərijz ðət majt téjk áwərz ɪntə wʌ́nz ðət kəmplíjt ɪn sɛ́kəndz. kwɛ́ərij ɒptɪmɪzéjʃən kəmbájnz ǽspɛkts əv kɒ́st ɛ̀stɪméjʃən, ǽlɡərɪ̀ðəm səlɛ́kʃən, ənd sʌ́mtàjmz íjvən kwɛ́ərij rijərájtɪŋ tə trǽnsfɔrm júwzər rəkwɛ́s ɪntə ðə fǽstəst pɒ́sɪbəl déjtəbèjs ɒ̀pəréjʃənz. ɪt rɛ̀prəzɛ́nts wʌ́n əv ðə mówst səfɪ́stɪkèjtɪd ǽspɛkts əv déjtəbèjs mǽnədʒmənt sɪ́stəmz, æz ɪt rəkwájərz bǽlənsɪŋ ɪmíjdijət ɛ̀ksəkjúwʃən kɒ́sts əɡéjnst lɔ́ŋ-tɜ́rm pərfɔ́rməns kənsɪ̀dəréjʃənz."
    },
    {
        "Question": "What is the process of creating data structures that enable quick retrieval of records from a database based on specific search criteria?",
        "RightAnswer": "Indexing",
        "WrongAnswers": [
            "Hashing",
            "Normalization",
            "Serialization",
            "Query optimization",
            "Data partitioning"
        ],
        "Explanation": "Indexing in computer science refers to the technique of creating special data structures that allow efficient and fast retrieval of records from databases or other data storage systems. Much like how a book index helps you quickly find topics without reading every page, database indexing creates organized references to data based on key values. When properly implemented, indexing dramatically improves search performance by reducing the number of disk accesses needed to locate specific records. However, there is a trade-off: while indexes speed up data retrieval operations, they require additional storage space and can slow down data modification operations since indexes must be updated whenever the data changes. Database administrators carefully choose which columns to index based on common query patterns to optimize overall system performance.",
        "trans_Question": "wɒt ɪz ðə prɒ́sɛs əv krijéjtɪŋ déjtə strʌ́ktʃərz ðət ɛnéjbəl kwɪ́k rətríjvəl əv rɛ́kərdz frəm ə déjtəbèjs béjst ɒn spəsɪ́fɪk sɜ́rtʃ krajtɪ́ərijə?",
        "trans_RightAnswer": "ɪ́ndɛksɪŋ",
        "trans_WrongAnswers": [
            "hǽʃɪŋ",
            "nɔ̀rməlɪzéjʃən",
            "sɪ̀ərìjəlɪzéjʃən",
            "kwɛ́ərij ɒptɪmɪzéjʃən",
            "déjtə pɑrtɪ́ʃənɪŋ"
        ],
        "trans_Explanation": "ɪ́ndɛksɪŋ ɪn kəmpjúwtər sájəns rəfɜ́rz tə ðə tɛkníjk əv krijéjtɪŋ spɛ́ʃəl déjtə strʌ́ktʃərz ðət əláw əfɪ́ʃənt ənd fǽst rətríjvəl əv rɛ́kərdz frəm déjtəbèjsɪz ɔr ʌ́ðər déjtə stɔ́rɪdʒ sɪ́stəmz. mʌtʃ lájk háw ə bʊ́k ɪ́ndɛks hɛ́lps juw kwɪ́klij fájnd tɒ́pɪks wɪðáwt ríjdɪŋ ɛvərij péjdʒ, déjtəbèjs ɪ́ndɛksɪŋ krijéjts ɔ́rɡənàjzd rɛ́fərənsɪz tə déjtə béjst ɒn kíj vǽljuwz. wɛ́n prɒ́pərlij ɪ́mpləmɛ̀ntɪd, ɪ́ndɛksɪŋ drəmǽtɪkəlij ɪmprúwvz sɜ́rtʃ pərfɔ́rməns baj rədjúwsɪŋ ðə nʌ́mbər əv dɪ́sk ǽksɛ̀sɪz níjdɪd tə lówkèjt spəsɪ́fɪk rɛ́kərdz. hàwɛ́vər, ðɛər ɪz ə tréjd-ɔ́f: wájl ɪ́ndɛksɪz spíjd ʌp déjtə rətríjvəl ɒ̀pəréjʃənz, ðej rəkwájər ədɪ́ʃənəl stɔ́rɪdʒ spéjs ənd kən slów dawn déjtə mɒ̀dɪfɪkéjʃən ɒ̀pəréjʃənz sɪns ɪ́ndɛksɪz mʌst bij ʌ́pdèjtɪd wɛnɛ́vər ðə déjtə tʃéjndʒɪz. déjtəbèjs ædmɪ́nɪstrèjtərz kɛ́ərfəlij tʃúwz wɪ́tʃ kɒ́ləmz tə ɪ́ndɛks béjst ɒn kɒ́mən kwɛ́ərij pǽtərnz tə ɒ́ptɪmàjz ówvərɔ̀l sɪ́stəm pərfɔ́rməns."
    },
    {
        "Question": "What is the term for the mechanisms used to ensure that multiple database transactions can run concurrently without interfering with each other's operations?",
        "RightAnswer": "Concurrency Control",
        "WrongAnswers": [
            "Transaction Isolation",
            "Parallel Processing Management",
            "Resource Synchronization",
            "Deadlock Prevention",
            "Sequential Access Protocol"
        ],
        "Explanation": "Concurrency Control refers to the set of techniques and mechanisms used in database systems and other computing environments to manage simultaneous access to shared resources. When multiple users or processes attempt to read or modify data at the same time, concurrency control ensures that the final state of the data remains consistent and accurate. It prevents problems such as lost updates (where one transaction's changes overwrite another's), dirty reads (where a transaction reads data that hasn't been committed yet), and other anomalies. Common concurrency control methods include locking (where resources are temporarily reserved for exclusive use), timestamp ordering (which establishes a sequence for operations), and optimistic methods (which check for conflicts only at commit time). Without proper concurrency control, databases and distributed systems would struggle to maintain data integrity in multi-user environments.",
        "trans_Question": "wɒt ɪz ðə tɜ́rm fɔr ðə mɛ́kənɪzəmz júwzd tə ənʃʊ́r ðət mʌ́ltɪpəl déjtəbèjs trænzǽkʃənz kən rʌ́n kənkɜ́rəntlij wɪðáwt ɪ̀ntəfɪ́ərɪŋ wɪð ijtʃ ʌ́ðər'z ɒ̀pəréjʃənz?",
        "trans_RightAnswer": "kənkɜ́rənsij kəntrówl",
        "trans_WrongAnswers": [
            "trænzǽkʃən àjsəléjʃən",
            "pǽrəlɛ̀l prɒ́sɛsɪŋ mǽnədʒmənt",
            "ríjsɔrs sɪ̀ŋkrənɪzéjʃən",
            "dɛ́dlɒ̀k prəvɛ́nʃən",
            "səkwɛ́nʃəl ǽksɛ̀s prówtəkɒ̀l"
        ],
        "trans_Explanation": "kənkɜ́rənsij kəntrówl rəfɜ́rz tə ðə sɛ́t əv tɛkníjks ənd mɛ́kənɪzəmz júwzd ɪn déjtəbèjs sɪ́stəmz ənd ʌ́ðər kəmpjúwtɪŋ ənvájərənmənts tə mǽnɪdʒ sàjməltéjnijəs ǽksɛ̀s tə ʃɛ́ərd ríjsɔrsɪz. wɛ́n mʌ́ltɪpəl júwzərz ɔr prɒ́sɛsɪz ətɛ́mpt tə rɛ́d ɔr mɒ́dɪfàj déjtə æt ðə séjm tájm, kənkɜ́rənsij kəntrówl ənʃʊ́rz ðət ðə fájnəl stéjt əv ðə déjtə rəméjnz kənsɪ́stənt ənd ǽkjərət. ɪt prəvɛ́nts prɒ́bləmz sʌtʃ æz lɔ́st ʌ́pdèjts (wɛ́ər wʌ́n trænzǽkʃən'z tʃéjndʒɪz òwvərrájt ənʌ́ðər'z), dɜ́rtij ríjdz (wɛ́ər ə trænzǽkʃən ríjdz déjtə ðət hǽzənt bɪn kəmɪ́tɪd jɛt), ənd ʌ́ðər ənɒ́məlijz. kɒ́mən kənkɜ́rənsij kəntrówl mɛ́θədz ɪnklúwd lɒ́kɪŋ (wɛ́ər ríjsɔrsɪz ɑr tɛ̀mpərɛ́ərɪlij rijzɜ́rvd fɔr əksklúwsɪv juwz), tájmstæ̀mp ɔ́rdərɪŋ (wɪ́tʃ əstǽblɪʃɪz ə síjkwəns fɔr ɒ̀pəréjʃənz), ənd ɒ̀ptɪmɪ́stɪk mɛ́θədz (wɪ́tʃ tʃɛ́k fɔr kɒ́nflɪkts ównlij æt kəmɪ́t tájm). wɪðáwt prɒ́pər kənkɜ́rənsij kəntrówl, déjtəbèjsɪz ənd dɪstrɪ́bjətɪd sɪ́stəmz wʊd strʌ́ɡəl tə mejntéjn déjtə ɪntɛ́ɡrɪtij ɪn mʌ́ltij-júwzər ənvájərənmənts."
    },
    {
        "Question": "In database systems, what term describes a sequence of operations that must either all succeed or all fail, never leaving the database in a partially completed state?",
        "RightAnswer": "Transaction",
        "WrongAnswers": [
            "Thread",
            "Query",
            "Checkpoint",
            "Pipeline",
            "Handshake"
        ],
        "Explanation": "A Transaction in computer science is a logical unit of work that contains one or more database operations, such as inserts, updates, or deletions. What makes transactions special is their ACID properties: Atomicity ensures all operations complete or none do; Consistency ensures the database remains in a valid state; Isolation prevents operations from interfering with each other; and Durability guarantees completed transactions persist even during system failures. Transactions are fundamental in banking, e-commerce, and any system where data integrity is critical. They create a safety net that prevents partial updates from corrupting data when something goes wrong, much like how a legal contract ensures all parties fulfill their obligations or the agreement becomes void.",
        "trans_Question": "ɪn déjtəbèjs sɪ́stəmz, wɒt tɜ́rm dəskrájbz ə síjkwəns əv ɒ̀pəréjʃənz ðət mʌst ájðər ɔl səksíjd ɔr ɔl féjl, nɛ́vər líjvɪŋ ðə déjtəbèjs ɪn ə pɑ́rʃəlij kəmplíjtɪd stéjt?",
        "trans_RightAnswer": "trænzǽkʃən",
        "trans_WrongAnswers": [
            "θrɛ́d",
            "kwɛ́ərij",
            "tʃɛ́kpɔ̀jnt",
            "pájplàjn",
            "hǽndʃèjk"
        ],
        "trans_Explanation": "ə trænzǽkʃən ɪn kəmpjúwtər sájəns ɪz ə lɒ́dʒɪkəl júwnɪt əv wɜ́rk ðət kəntéjnz wʌ́n ɔr mɔr déjtəbèjs ɒ̀pəréjʃənz, sʌtʃ æz ɪnsɜ́rts, ʌ́pdèjts, ɔr dəlíjʃənz. wɒt méjks trænzǽkʃənz spɛ́ʃəl ɪz ðɛər ACID prɒ́pərtijz: ətɒ́mɪsɪtij ənʃʊ́rz ɔl ɒ̀pəréjʃənz kəmplíjt ɔr nən dúw; kənsɪ́stənsij ənʃʊ́rz ðə déjtəbèjs rəméjnz ɪn ə vǽlɪd stéjt; àjsəléjʃən prəvɛ́nts ɒ̀pəréjʃənz frəm ɪ̀ntəfɪ́ərɪŋ wɪð ijtʃ ʌ́ðər; ənd dərəbɪ́lɪtij ɡɛ̀ərəntíjz kəmplíjtɪd trænzǽkʃənz pərsɪ́st íjvən dʊ́rɪŋ sɪ́stəm féjljərz. trænzǽkʃənz ɑr fʌ̀ndəmɛ́ntəl ɪn bǽŋkɪŋ, e-kɒ́mərs, ənd ɛ́nij sɪ́stəm wɛ́ər déjtə ɪntɛ́ɡrɪtij ɪz krɪ́tɪkəl. ðej krijéjt ə séjftij nɛ́t ðət prəvɛ́nts pɑ́rʃəl ʌ́pdèjts frəm kərʌ́ptɪŋ déjtə wɛ́n sʌ́mθɪŋ ɡówz rɔ́ŋ, mʌtʃ lájk háw ə líjɡəl kɒ́ntrækt ənʃʊ́rz ɔl pɑ́rtijz fʊlfɪ́l ðɛər ɒ̀bləɡéjʃənz ɔr ðə əɡríjmənt bəkʌ́mz vɔ́jd."
    },
    {
        "Question": "In operating systems, what is the term for the strategy that ensures certain necessary conditions for a deadlock can never occur by restricting how processes request and hold resources?",
        "RightAnswer": "Deadlock Prevention",
        "WrongAnswers": [
            "Resource Enumeration",
            "Process Sequencing",
            "Circular Wait Detection",
            "System Checkpoint Recovery",
            "Thread Synchronization Protocol"
        ],
        "Explanation": "Deadlock Prevention refers to a set of methods used in operating systems to guarantee that deadlocks cannot occur by eliminating one or more of the necessary conditions for deadlock. Unlike deadlock detection or recovery techniques that deal with deadlocks after they happen, prevention strategies work proactively by imposing restrictions on how processes can request resources. These strategies might include forcing processes to request all needed resources at once, establishing a global ordering of resources that all processes must follow when requesting them, or using resource preemption techniques. While these approaches effectively prevent deadlocks, they often come with tradeoffs such as reduced system utilization and throughput, as they impose constraints that might force processes to wait unnecessarily. Deadlock prevention is particularly important in critical systems where deadlocks cannot be tolerated, such as real-time systems or those controlling physical equipment.",
        "trans_Question": "ɪn ɒ́pərèjtɪŋ sɪ́stəmz, wɒt ɪz ðə tɜ́rm fɔr ðə strǽtədʒij ðət ənʃʊ́rz sɜ́rtən nɛ́səsɛ̀ərij kəndɪ́ʃənz fɔr ə dɛ́dlɒ̀k kən nɛ́vər əkɜ́r baj rəstrɪ́ktɪŋ háw prɒ́sɛsɪz rəkwɛ́st ənd hówld ríjsɔrsɪz?",
        "trans_RightAnswer": "dɛ́dlɒ̀k prəvɛ́nʃən",
        "trans_WrongAnswers": [
            "ríjsɔrs ənjùwməréjʃən",
            "prɒ́sɛs síjkwənsɪŋ",
            "sɜ́rkjələr wéjt dətɛ́kʃən",
            "sɪ́stəm tʃɛ́kpɔ̀jnt rəkʌ́vərij",
            "θrɛ́d sɪ̀ŋkrənɪzéjʃən prówtəkɒ̀l"
        ],
        "trans_Explanation": "dɛ́dlɒ̀k prəvɛ́nʃən rəfɜ́rz tə ə sɛ́t əv mɛ́θədz júwzd ɪn ɒ́pərèjtɪŋ sɪ́stəmz tə ɡɛ̀ərəntíj ðət dɛ́dlɒ̀ks kǽnɒt əkɜ́r baj əlɪ́mɪnèjtɪŋ wʌ́n ɔr mɔr əv ðə nɛ́səsɛ̀ərij kəndɪ́ʃənz fɔr dɛ́dlɒ̀k. ʌ̀nlájk dɛ́dlɒ̀k dətɛ́kʃən ɔr rəkʌ́vərij tɛkníjks ðət díjl wɪð dɛ́dlɒ̀ks ǽftər ðej hǽpən, prəvɛ́nʃən strǽtədʒijz wɜ́rk pròwǽktɪvlìj baj ɪ̀mpówzɪŋ rəstrɪ́kʃənz ɒn háw prɒ́sɛsɪz kən rəkwɛ́st ríjsɔrsɪz. ðijz strǽtədʒijz majt ɪnklúwd fɔ́rsɪŋ prɒ́sɛsɪz tə rəkwɛ́st ɔl níjdɪd ríjsɔrsɪz æt wʌ́ns, əstǽblɪʃɪŋ ə ɡlówbəl ɔ́rdərɪŋ əv ríjsɔrsɪz ðət ɔl prɒ́sɛsɪz mʌst fɒ́low wɛ́n rəkwɛ́stɪŋ ðɛm, ɔr júwzɪŋ ríjsɔrs prìjɛ́mpʃən tɛkníjks. wájl ðijz əprówtʃɪz əfɛ́ktɪvlij prəvɛ́nt dɛ́dlɒ̀ks, ðej ɔ́fən kʌ́m wɪð tréjdɔ̀fs sʌtʃ æz rədjúwst sɪ́stəm jùwtɪlɪzéjʃən ənd θrúwpʊ̀t, æz ðej ɪ̀mpówz kənstréjnts ðət majt fɔ́rs prɒ́sɛsɪz tə wéjt ʌ̀nnɛ́səsɛ̀ərɪlij. dɛ́dlɒ̀k prəvɛ́nʃən ɪz pərtɪ́kjələrlij ɪmpɔ́rtənt ɪn krɪ́tɪkəl sɪ́stəmz wɛ́ər dɛ́dlɒ̀ks kǽnɒt bij tɒ́lərèjtɪd, sʌtʃ æz ríjəl-tájm sɪ́stəmz ɔr ðowz kəntrówlɪŋ fɪ́zɪkəl əkwɪ́pmənt."
    },
    {
        "Question": "What is the mechanism used in database systems to prevent multiple users from making conflicting changes to the same data simultaneously?",
        "RightAnswer": "Locking",
        "WrongAnswers": [
            "Caching",
            "Indexing",
            "Partitioning",
            "Normalization",
            "Hashing"
        ],
        "Explanation": "Locking is a crucial concurrency control mechanism in computer science that prevents multiple processes or users from simultaneously accessing or modifying the same resource in ways that might lead to inconsistent states. When a process needs to access a resource, it acquires a lock on it, which temporarily restricts other processes from making conflicting operations. Different types of locks exist, such as exclusive locks (preventing any other access) and shared locks (allowing concurrent reading but not writing). Locking helps maintain data integrity in multi-user environments like databases, operating systems, and distributed applications. However, poorly implemented locking strategies can lead to performance bottlenecks or deadlocks, where processes indefinitely wait for each other to release resources. Modern systems often employ sophisticated locking protocols to balance data consistency with performance requirements.",
        "trans_Question": "wɒt ɪz ðə mɛ́kənɪzəm júwzd ɪn déjtəbèjs sɪ́stəmz tə prəvɛ́nt mʌ́ltɪpəl júwzərz frəm méjkɪŋ kənflɪ́ktɪŋ tʃéjndʒɪz tə ðə séjm déjtə sàjməltéjnijəslij?",
        "trans_RightAnswer": "lɒ́kɪŋ",
        "trans_WrongAnswers": [
            "kǽʃɪŋ",
            "ɪ́ndɛksɪŋ",
            "pɑrtɪ́ʃənɪŋ",
            "nɔ̀rməlɪzéjʃən",
            "hǽʃɪŋ"
        ],
        "trans_Explanation": "lɒ́kɪŋ ɪz ə krúwʃəl kənkɜ́rənsij kəntrówl mɛ́kənɪzəm ɪn kəmpjúwtər sájəns ðət prəvɛ́nts mʌ́ltɪpəl prɒ́sɛsɪz ɔr júwzərz frəm sàjməltéjnijəslij ǽksɛ̀sɪŋ ɔr mɒ́dɪfàjɪŋ ðə séjm ríjsɔrs ɪn wéjz ðət majt líjd tə ɪ̀nkənsɪ́stənt stéjts. wɛ́n ə prɒ́sɛs níjdz tə ǽksɛ̀s ə ríjsɔrs, ɪt əkwájərz ə lɒ́k ɒn ɪt, wɪ́tʃ tɛ̀mpərɛ́ərɪlij rəstrɪ́kts ʌ́ðər prɒ́sɛsɪz frəm méjkɪŋ kənflɪ́ktɪŋ ɒ̀pəréjʃənz. dɪ́fərənt tájps əv lɒ́ks əɡzɪ́st, sʌtʃ æz əksklúwsɪv lɒ́ks (prəvɛ́ntɪŋ ɛ́nij ʌ́ðər ǽksɛ̀s) ənd ʃɛ́ərd lɒ́ks (əláwɪŋ kənkɜ́rənt ríjdɪŋ bʌt nɒt rájtɪŋ). lɒ́kɪŋ hɛ́lps mejntéjn déjtə ɪntɛ́ɡrɪtij ɪn mʌ́ltij-júwzər ənvájərənmənts lájk déjtəbèjsɪz, ɒ́pərèjtɪŋ sɪ́stəmz, ənd dɪstrɪ́bjətɪd æ̀plɪkéjʃənz. hàwɛ́vər, pɔ́rlij ɪ́mpləmɛ̀ntɪd lɒ́kɪŋ strǽtədʒijz kən líjd tə pərfɔ́rməns bɒ́təlnɛ̀ks ɔr dɛ́dlɒ̀ks, wɛ́ər prɒ́sɛsɪz ɪ̀ndɛ́fɪnɪtlij wéjt fɔr ijtʃ ʌ́ðər tə rəlíjs ríjsɔrsɪz. mɒ́dərn sɪ́stəmz ɔ́fən ɛmplɔ́j səfɪ́stɪkèjtɪd lɒ́kɪŋ prówtəkɔ̀lz tə bǽləns déjtə kənsɪ́stənsij wɪð pərfɔ́rməns rəkwájərmənts."
    },
    {
        "Question": "What is the term for ensuring data remains accurate, consistent, and reliable throughout its entire lifecycle in a database or information system?",
        "RightAnswer": "Data Integrity",
        "WrongAnswers": [
            "Data Normalization",
            "Data Persistence",
            "Data Encapsulation",
            "Data Coherence",
            "Data Validation"
        ],
        "Explanation": "Data Integrity refers to the overall completeness, accuracy, and consistency of data throughout its lifecycle. In computer science, it encompasses the processes, standards, and measures that ensure information remains unaltered and reliable when stored, retrieved, processed, or transferred. Data integrity is maintained through various techniques including validation checks, error detection methods, transaction controls, and access restrictions. When data has integrity, it means users can trust its authenticity, it adheres to the defined business rules, and it remains protected from unauthorized modifications, corruption, or deletion. Data integrity is fundamental to effective decision-making, regulatory compliance, and system reliability across databases, file systems, and distributed computing environments.",
        "trans_Question": "wɒt ɪz ðə tɜ́rm fɔr ɛnʃʊ́rɪŋ déjtə rəméjnz ǽkjərət, kənsɪ́stənt, ənd rəlájəbəl θruwáwt ɪts əntájər lájfsàjkəl ɪn ə déjtəbèjs ɔr ɪnfərméjʃən sɪ́stəm?",
        "trans_RightAnswer": "déjtə ɪntɛ́ɡrɪtij",
        "trans_WrongAnswers": [
            "déjtə nɔ̀rməlɪzéjʃən",
            "déjtə pərsɪ́stəns",
            "déjtə ɛnkǽpsəlèjʃən",
            "déjtə kowhɪ́ərəns",
            "déjtə væ̀lɪdéjʃən"
        ],
        "trans_Explanation": "déjtə ɪntɛ́ɡrɪtij rəfɜ́rz tə ðə ówvərɔ̀l kəmplíjtnəs, ǽkjərəsij, ənd kənsɪ́stənsij əv déjtə θruwáwt ɪts lájfsàjkəl. ɪn kəmpjúwtər sájəns, ɪt ɛnkʌ́mpəsɪz ðə prɒ́sɛsɪz, stǽndərdz, ənd mɛ́ʒərz ðət ənʃʊ́r ɪnfərméjʃən rəméjnz ənɔ́ltərd ənd rəlájəbəl wɛ́n stɔ́rd, rətríjvd, prɒ́sɛst, ɔr trǽnsfərd. déjtə ɪntɛ́ɡrɪtij ɪz mejntéjnd θrúw vɛ́ərijəs tɛkníjks ɪnklúwdɪŋ væ̀lɪdéjʃən tʃɛ́ks, ɛ́ərər dətɛ́kʃən mɛ́θədz, trænzǽkʃən kəntrówlz, ənd ǽksɛ̀s rəstrɪ́kʃənz. wɛ́n déjtə həz ɪntɛ́ɡrɪtij, ɪt míjnz júwzərz kən trʌ́st ɪts ɔ̀θəntɪ́sɪtij, ɪt ədhɪ́ərz tə ðə dəfájnd bɪ́znəs rúwlz, ənd ɪt rəméjnz prətɛ́ktɪd frəm ənɔ́θəràjzd mɒ̀dɪfɪkéjʃənz, kərʌ́pʃən, ɔr dəlíjʃən. déjtə ɪntɛ́ɡrɪtij ɪz fʌ̀ndəmɛ́ntəl tə əféktɪv dəsɪ́ʒən-méjkɪŋ, rɛ́ɡjələtɔrij kəmplájəns, ənd sɪ́stəm rəlàjəbɪ́lɪtij əkrɔ́s déjtəbèjsɪz, fájl sɪ́stəmz, ənd dɪstrɪ́bjətɪd kəmpjúwtɪŋ ənvájərənmənts."
    },
    {
        "Question": "In a multinational e-commerce platform, data needs to be stored across several geographical locations to ensure quick access for users worldwide and resilience against regional failures. What is the type of database system that would best support this architecture?",
        "RightAnswer": "Distributed Database",
        "WrongAnswers": [
            "Monolithic Database",
            "Centralized Database",
            "Sequential Database",
            "Hierarchical Storage Model",
            "Single-instance Repository"
        ],
        "Explanation": "A Distributed Database is a database system where data is stored across multiple computers, often in different physical locations, but managed as a single logical database. Unlike centralized databases where all data resides on one server, distributed databases spread data across a network of connected machines. This approach offers several advantages: improved performance through local access to data, enhanced reliability since the system can continue operating even if some nodes fail, better scalability as new nodes can be added to handle increased load, and reduced network traffic by positioning data closer to where it's frequently accessed. Distributed databases use specialized techniques for maintaining data consistency, managing transactions across multiple locations, and coordinating operations between different nodes. Examples include Google's Spanner, Amazon's DynamoDB, and Apache Cassandra. This architecture is particularly valuable for global applications that require high availability, fault tolerance, and the ability to serve users across different geographical regions with minimal latency.",
        "trans_Question": "ɪn ə mʌ̀ltijnǽʃənəl e-kɒ́mərs plǽtfɔ̀rm, déjtə níjdz tə bij stɔ́rd əkrɔ́s sɛ́vərəl dʒìjəɡrǽfɪkəl lowkéjʃənz tə ənʃʊ́r kwɪ́k ǽksɛ̀s fɔr júwzərz wɜ́rldwájd ənd rəzɪ́lijəns əɡéjnst ríjdʒənəl féjljərz. wɒt ɪz ðə tájp əv déjtəbèjs sɪ́stəm ðət wʊd bɛ́st səpɔ́rt ðɪs ɑ́rkɪtɛ̀ktʃər?",
        "trans_RightAnswer": "dɪstrɪ́bjətɪd déjtəbèjs",
        "trans_WrongAnswers": [
            "mɒ̀nəlɪ́θɪk déjtəbèjs",
            "sɛ́ntrəlàjzd déjtəbèjs",
            "səkwɛ́nʃəl déjtəbèjs",
            "hàjərɑ́rkɪkəl stɔ́rɪdʒ mɒ́dəl",
            "sɪ́ŋɡəl-ɪ́nstəns rijpɒ́zɪtɔ̀rij"
        ],
        "trans_Explanation": "ə dɪstrɪ́bjətɪd déjtəbèjs ɪz ə déjtəbèjs sɪ́stəm wɛ́ər déjtə ɪz stɔ́rd əkrɔ́s mʌ́ltɪpəl kəmpjúwtərz, ɔ́fən ɪn dɪ́fərənt fɪ́zɪkəl lowkéjʃənz, bʌt mǽnɪdʒd æz ə sɪ́ŋɡəl lɒ́dʒɪkəl déjtəbèjs. ʌ̀nlájk sɛ́ntrəlàjzd déjtəbèjsɪz wɛ́ər ɔl déjtə rijzájdz ɒn wʌ́n sɜ́rvər, dɪstrɪ́bjətɪd déjtəbèjsɪz sprɛ́d déjtə əkrɔ́s ə nɛ́twɜ̀rk əv kənɛ́ktɪd məʃíjnz. ðɪs əprówtʃ ɔ́fərz sɛ́vərəl ədvǽntɪdʒɪz: ɪmprúwvd pərfɔ́rməns θrúw lówkəl ǽksɛ̀s tə déjtə, ənhǽnst rəlàjəbɪ́lɪtij sɪns ðə sɪ́stəm kən kəntɪ́njuw ɒ́pərèjtɪŋ íjvən ɪf sʌm nówdz féjl, bɛ́tər skéjləbɪ́lɪtij æz núw nówdz kən bij ǽdɪd tə hǽndəl ɪnkríjst lówd, ənd rədjúwst nɛ́twɜ̀rk trǽfɪk baj pəzɪ́ʃənɪŋ déjtə klówsər tə wɛ́ər ɪt's fríjkwəntlij ǽksɛ̀st. dɪstrɪ́bjətɪd déjtəbèjsɪz juwz spɛ́ʃəlàjzd tɛkníjks fɔr mejntéjnɪŋ déjtə kənsɪ́stənsij, mǽnɪdʒɪŋ trænzǽkʃənz əkrɔ́s mʌ́ltɪpəl lowkéjʃənz, ənd kowɔ́rdɪnèjtɪŋ ɒ̀pəréjʃənz bijtwíjn dɪ́fərənt nówdz. əɡzǽmpəlz ɪnklúwd ɡúwɡəl'z spǽnər, əmǽzɒn'z dàjnəmówdijbìj, ənd əpǽtʃij kəsǽndrə. ðɪs ɑ́rkɪtɛ̀ktʃər ɪz pərtɪ́kjələrlij vǽljəbəl fɔr ɡlówbəl æ̀plɪkéjʃənz ðət rəkwájər háj əvèjləbɪ́lɪtij, fɔ́lt tɒ́lərəns, ənd ðə əbɪ́lɪtij tə sɜ́rv júwzərz əkrɔ́s dɪ́fərənt dʒìjəɡrǽfɪkəl ríjdʒənz wɪð mɪ́nɪməl léjtənsij."
    },
    {
        "Question": "What term describes the set of techniques, technologies, and tools that transform raw data into meaningful insights to support business decision-making and strategic planning?",
        "RightAnswer": "Business Intelligence",
        "WrongAnswers": [
            "Data Mining",
            "Enterprise Resource Planning",
            "Machine Learning",
            "Knowledge Management",
            "Predictive Analytics"
        ],
        "Explanation": "Business Intelligence refers to the comprehensive technologies, applications, and practices for collecting, integrating, analyzing, and presenting business information to help organizations make better data-driven decisions. It encompasses a variety of tools including dashboards, reports, data visualization, online analytical processing (OLAP), and data warehousing solutions that transform raw data into actionable insights. Business Intelligence differs from related fields by focusing specifically on structured data analysis for operational and strategic business purposes, enabling stakeholders to identify trends, spot anomalies, and discover opportunities that might otherwise remain hidden in vast amounts of organizational data. Modern BI systems emphasize self-service capabilities, allowing non-technical users to create reports and visualizations without requiring extensive IT support, democratizing access to data-driven decision making across all levels of an organization.",
        "trans_Question": "wɒt tɜ́rm dəskrájbz ðə sɛ́t əv tɛkníjks, tɛknɒ́lədʒijz, ənd túwlz ðət trǽnsfɔrm rɔ́ déjtə ɪntə míjnɪŋfəl ɪ́nsàjts tə səpɔ́rt bɪ́znəs dəsɪ́ʒən-méjkɪŋ ənd strətíjdʒɪk plǽnɪŋ?",
        "trans_RightAnswer": "bɪ́znəs ɪntɛ́lɪdʒəns",
        "trans_WrongAnswers": [
            "déjtə májnɪŋ",
            "ɛ́ntərpràjz ríjsɔrs plǽnɪŋ",
            "məʃíjn lɜ́rnɪŋ",
            "nɒ́lɪdʒ mǽnədʒmənt",
            "prədɪ́ktɪv æ̀nəlɪ́tɪks"
        ],
        "trans_Explanation": "bɪ́znəs ɪntɛ́lɪdʒəns rəfɜ́rz tə ðə kɒ̀mprəhɛ́nsɪv tɛknɒ́lədʒijz, æ̀plɪkéjʃənz, ənd prǽktɪsɪz fɔr kəlɛ́ktɪŋ, ɪ́ntəɡrejtɪŋ, ǽnəlàjzɪŋ, ənd prəzɛ́ntɪŋ bɪ́znəs ɪnfərméjʃən tə hɛ́lp ɔ̀rɡənɪzéjʃənz méjk bɛ́tər déjtə-drɪ́vən dəsɪ́ʒənz. ɪt ɛnkʌ́mpəsɪz ə vərájətij əv túwlz ɪnklúwdɪŋ dǽʃbɔ̀rdz, rijpɔ́rts, déjtə vɪ̀ʒwəlɪzéjʃən, ɔ́nlàjn æ̀nəlɪ́tɪkəl prɒ́sɛsɪŋ (OLAP), ənd déjtə wɛ́ərhàwzɪŋ səlúwʃənz ðət trǽnsfɔrm rɔ́ déjtə ɪntə ǽkʃənəbəl ɪ́nsàjts. bɪ́znəs ɪntɛ́lɪdʒəns dɪ́fərz frəm rəléjtɪd fíjldz baj fówkəsɪŋ spəsɪ́fɪklij ɒn strʌ́ktʃərd déjtə ənǽlɪsɪs fɔr ɒ̀pəréjʃənəl ənd strətíjdʒɪk bɪ́znəs pɜ́rpəsɪz, ɛnéjbəlɪŋ stéjkhòwldərz tə ajdɛ́ntɪfàj trɛ́ndz, spɒ́t ənɒ́məlijz, ənd dɪskʌ́vər ɒ̀pərtúwnɪtijz ðət majt ʌ́ðərwàjz rəméjn hɪ́dən ɪn vǽst əmáwnts əv ɔ̀rɡənɪzéjʃənəl déjtə. mɒ́dərn BI sɪ́stəmz ɛ́mfəsajz sɛ́lf-sɜ́rvɪs kèjpəbɪ́lɪtijz, əláwɪŋ nɒn-tɛ́knɪkəl júwzərz tə krijéjt rijpɔ́rts ənd vɪ̀ʒwəlɪzéjʃənz wɪðáwt rijkwájərɪŋ əkstɛ́nsɪv IT səpɔ́rt, dəmɒ́krətàjzɪŋ ǽksɛ̀s tə déjtə-drɪ́vən dəsɪ́ʒən méjkɪŋ əkrɔ́s ɔl lɛ́vəlz əv ən ɔ̀rɡənɪzéjʃən."
    },
    {
        "Question": "Which type of database represents data as nodes and relationships between them, ideal for analyzing networks and interconnected information?",
        "RightAnswer": "Graph Database",
        "WrongAnswers": [
            "Relational Database",
            "Document Database",
            "Key-Value Store",
            "Time Series Database",
            "Columnar Database"
        ],
        "Explanation": "A Graph Database is a specialized database system designed to store and process data in terms of entities (nodes) and their connections (edges or relationships). Unlike traditional relational databases that use tables, graph databases emphasize the relationships between data points. This makes them exceptionally powerful for applications where understanding connections is crucial, such as social networks, recommendation engines, fraud detection, and knowledge graphs. Graph databases excel at answering complex queries about data relationships that would be computationally expensive in other database types. For instance, finding 'friends of friends' or identifying the shortest path between two entities becomes much more efficient. Popular graph database systems include Neo4j, Amazon Neptune, and JanusGraph. Their structure closely mirrors how we naturally think about interconnected information, making them intuitive for modeling complex domains where relationships matter as much as the data itself.",
        "trans_Question": "wɪ́tʃ tájp əv déjtəbèjs rɛ̀prəzɛ́nts déjtə æz nówdz ənd rəléjʃənʃɪ̀ps bijtwíjn ðɛm, ajdíjəl fɔr ǽnəlàjzɪŋ nɛ́twɜ̀rks ənd ɪ̀ntərkənɛ́ktɪd ɪnfərméjʃən?",
        "trans_RightAnswer": "ɡrǽf déjtəbèjs",
        "trans_WrongAnswers": [
            "rəléjʃənəl déjtəbèjs",
            "dɒ́kjəmɛnt déjtəbèjs",
            "kíj-vǽljuw stɔ́r",
            "tájm sɪ́ərijz déjtəbèjs",
            "kɒ́ləmnər déjtəbèjs"
        ],
        "trans_Explanation": "ə ɡrǽf déjtəbèjs ɪz ə spɛ́ʃəlàjzd déjtəbèjs sɪ́stəm dəzájnd tə stɔ́r ənd prɒ́sɛs déjtə ɪn tɜ́rmz əv ɛ́ntɪtijz (nówdz) ənd ðɛər kənɛ́kʃənz (ɛ́dʒɪz ɔr rəléjʃənʃɪ̀ps). ʌ̀nlájk trədɪ́ʃənəl rəléjʃənəl déjtəbèjsɪz ðət juwz téjbəlz, ɡrǽf déjtəbèjsɪz ɛ́mfəsajz ðə rəléjʃənʃɪ̀ps bijtwíjn déjtə pɔ́jnts. ðɪs méjks ðɛm əksɛ́pʃənəlij páwərfəl fɔr æ̀plɪkéjʃənz wɛ́ər ʌ̀ndərstǽndɪŋ kənɛ́kʃənz ɪz krúwʃəl, sʌtʃ æz sówʃəl nɛ́twɜ̀rks, rɛ̀kəməndéjʃən ɛ́ndʒɪnz, frɔ́d dətɛ́kʃən, ənd nɒ́lɪdʒ ɡrǽfs. ɡrǽf déjtəbèjsɪz əksɛ́l æt ǽnsərɪŋ kɒ́mplɛks kwɛ́ərijz əbawt déjtə rəléjʃənʃɪ̀ps ðət wʊd bij kɒ̀mpjətéjʃənəlij əkspɛ́nsɪv ɪn ʌ́ðər déjtəbèjs tájps. fɔr ɪ́nstəns, fájndɪŋ 'frɛ́ndz əv frɛ́ndz' ɔr ajdɛ́ntɪfàjɪŋ ðə ʃɔ́rtəst pǽθ bijtwíjn túw ɛ́ntɪtijz bəkʌ́mz mʌtʃ mɔr əfɪ́ʃənt. pɒ́pjələr ɡrǽf déjtəbèjs sɪ́stəmz ɪnklúwd neo4j, əmǽzɒn nɛ́ptuwn, ənd dʒéjnəsɡræ̀f. ðɛər strʌ́ktʃər klówslij mɪ́ərərz háw wij nǽtʃərəlij θɪ́ŋk əbawt ɪ̀ntərkənɛ́ktɪd ɪnfərméjʃən, méjkɪŋ ðɛm ɪntúwɪtɪv fɔr mɒ́dəlɪ̀ŋ kɒ́mplɛks dowméjnz wɛ́ər rəléjʃənʃɪ̀ps mǽtər æz mʌtʃ æz ðə déjtə ɪtsɛ́lf."
    },
    {
        "Question": "What is the systematic process of evaluating a software product to identify defects, verify functionality, and ensure it meets requirements before release?",
        "RightAnswer": "Software Testing",
        "WrongAnswers": [
            "Code Compilation",
            "System Deployment",
            "Program Optimization",
            "Data Mining",
            "Interface Design"
        ],
        "Explanation": "Software Testing is the methodical investigation of a software application to evaluate its quality and performance. It involves executing programs with the intent of finding bugs, verifying that the software behaves as expected, and validating that it meets specified requirements. Software Testing encompasses various techniques including unit testing, integration testing, system testing, and acceptance testing, each focusing on different aspects of the software. The primary goal is to identify discrepancies between actual and expected behaviors, ensure reliability, and ultimately deliver a high-quality product to end users. Testing can be manual or automated and is a critical part of the software development lifecycle that helps minimize risks associated with software failures in production environments.",
        "trans_Question": "wɒt ɪz ðə sɪ̀stəmǽtɪk prɒ́sɛs əv əvǽljuwèjtɪŋ ə sɔ́ftwɛ̀ər prɒ́dəkt tə ajdɛ́ntɪfàj díjfɛkts, vɛ́ərɪfaj fʌ̀ŋkʃənǽlɪtij, ənd ənʃʊ́r ɪt míjts rəkwájərmənts bəfɔ́r rəlíjs?",
        "trans_RightAnswer": "sɔ́ftwɛ̀ər tɛ́stɪŋ",
        "trans_WrongAnswers": [
            "kówd kɒ̀mpɪléjʃən",
            "sɪ́stəm dəplɔ́jmənt",
            "prówɡræ̀m ɒptɪmɪzéjʃən",
            "déjtə májnɪŋ",
            "ɪ́ntərfèjs dəzájn"
        ],
        "trans_Explanation": "sɔ́ftwɛ̀ər tɛ́stɪŋ ɪz ðə məθɒ́dɪkəl ɪnvɛ̀stɪɡéjʃən əv ə sɔ́ftwɛ̀ər æ̀plɪkéjʃən tə əvǽljuwèjt ɪts kwɑ́lɪtij ənd pərfɔ́rməns. ɪt ɪnvɒ́lvz ɛ́ksəkjùwtɪŋ prówɡræ̀mz wɪð ðə ɪntɛ́nt əv fájndɪŋ bʌ́ɡz, vɛ́ərɪfajɪŋ ðət ðə sɔ́ftwɛ̀ər bəhéjvz æz əkspɛ́ktɪd, ənd vǽlɪdèjtɪŋ ðət ɪt míjts spɛ́sɪfàjd rəkwájərmənts. sɔ́ftwɛ̀ər tɛ́stɪŋ ɛnkʌ́mpəsɪz vɛ́ərijəs tɛkníjks ɪnklúwdɪŋ júwnɪt tɛ́stɪŋ, ɪntəɡrejʃən tɛ́stɪŋ, sɪ́stəm tɛ́stɪŋ, ənd æksɛ́ptəns tɛ́stɪŋ, ijtʃ fówkəsɪŋ ɒn dɪ́fərənt ǽspɛkts əv ðə sɔ́ftwɛ̀ər. ðə prájmɛ̀ərij ɡówl ɪz tə ajdɛ́ntɪfàj dɪskrɛ́pənsijz bijtwíjn ǽktʃəl ənd əkspɛ́ktɪd bəhéjvjərz, ənʃʊ́r rəlàjəbɪ́lɪtij, ənd ʌ́ltɪmətlij dəlɪ́vər ə háj-kwɑ́lɪtij prɒ́dəkt tə ɛ́nd júwzərz. tɛ́stɪŋ kən bij mǽnjuwəl ɔr ɔ́təmèjtɪd ənd ɪz ə krɪ́tɪkəl pɑ́rt əv ðə sɔ́ftwɛ̀ər dəvɛ́ləpmənt lájfsàjkəl ðət hɛ́lps mɪ́nɪmàjz rɪ́sks əsówsijèjtɪd wɪð sɔ́ftwɛ̀ər féjljərz ɪn prədʌ́kʃən ənvájərənmənts."
    },
    {
        "Question": "Which software development practice involves testing individual components or functions in isolation to verify their correctness before integration?",
        "RightAnswer": "Unit Testing",
        "WrongAnswers": [
            "Load Testing",
            "Regression Testing",
            "Integration Testing",
            "System Testing",
            "Acceptance Testing"
        ],
        "Explanation": "Unit Testing is a software development approach where individual components, functions, or modules of code are tested in isolation to verify they work as expected. Instead of testing the entire application at once, developers write specific test cases for each small 'unit' of code to confirm it produces the correct outputs for given inputs. This practice helps identify bugs early in the development process, makes code more reliable, and provides documentation on how components should function. Unit tests typically follow a pattern of setup, execution, and verification, and are often automated so they can be run frequently as code changes. By confirming each piece works correctly on its own, developers build a foundation of reliable components before combining them into larger systems.",
        "trans_Question": "wɪ́tʃ sɔ́ftwɛ̀ər dəvɛ́ləpmənt prǽktɪs ɪnvɒ́lvz tɛ́stɪŋ ɪndɪvɪ́dʒəwəl kəmpównənts ɔr fʌ́ŋkʃənz ɪn àjsəléjʃən tə vɛ́ərɪfaj ðɛər kərɛ́ktnəs bəfɔ́r ɪntəɡrejʃən?",
        "trans_RightAnswer": "júwnɪt tɛ́stɪŋ",
        "trans_WrongAnswers": [
            "lówd tɛ́stɪŋ",
            "rəɡrɛ́ʃən tɛ́stɪŋ",
            "ɪntəɡrejʃən tɛ́stɪŋ",
            "sɪ́stəm tɛ́stɪŋ",
            "æksɛ́ptəns tɛ́stɪŋ"
        ],
        "trans_Explanation": "júwnɪt tɛ́stɪŋ ɪz ə sɔ́ftwɛ̀ər dəvɛ́ləpmənt əprówtʃ wɛ́ər ɪndɪvɪ́dʒəwəl kəmpównənts, fʌ́ŋkʃənz, ɔr mɒ́dʒuwlz əv kówd ɑr tɛ́stɪd ɪn àjsəléjʃən tə vɛ́ərɪfaj ðej wɜ́rk æz əkspɛ́ktɪd. ɪnstɛ́d əv tɛ́stɪŋ ðə əntájər æ̀plɪkéjʃən æt wʌ́ns, dəvɛ́ləpərz rájt spəsɪ́fɪk tɛ́st kéjsɪz fɔr ijtʃ smɔ́l 'júwnɪt' əv kówd tə kənfɜ́rm ɪt prədúwsɪz ðə kərɛ́kt áwtpʊ̀ts fɔr ɡɪ́vən ɪ́npʊ̀ts. ðɪs prǽktɪs hɛ́lps ajdɛ́ntɪfàj bʌ́ɡz ɜ́rlij ɪn ðə dəvɛ́ləpmənt prɒ́sɛs, méjks kówd mɔr rəlájəbəl, ənd prəvájdz dɒ̀kjəmɛntéjʃən ɒn háw kəmpównənts ʃʊd fʌ́ŋkʃən. júwnɪt tɛ́sts tɪ́pɪkəlij fɒ́low ə pǽtərn əv sɛ́tʌ̀p, ɛ̀ksəkjúwʃən, ənd vɛ̀ərɪfɪkéjʃən, ənd ɑr ɔ́fən ɔ́təmèjtɪd sow ðej kən bij rʌ́n fríjkwəntlij æz kówd tʃéjndʒɪz. baj kənfɜ́rmɪŋ ijtʃ píjs wɜ́rks kərɛ́ktlij ɒn ɪts ówn, dəvɛ́ləpərz bɪ́ld ə fawndéjʃən əv rəlájəbəl kəmpównənts bəfɔ́r kəmbájnɪŋ ðɛm ɪntə lɑ́rdʒər sɪ́stəmz."
    },
    {
        "Question": "Which software testing approach specifically focuses on verifying that different components or modules work together correctly when combined?",
        "RightAnswer": "Integration Testing",
        "WrongAnswers": [
            "Unit Testing",
            "System Testing",
            "Regression Testing",
            "Acceptance Testing",
            "Stress Testing"
        ],
        "Explanation": "Integration Testing is a critical phase in software development where multiple individual components or modules are combined and tested as a group. Unlike unit testing, which examines isolated components, integration testing specifically evaluates the interfaces and interactions between integrated units to ensure they work together as expected. This type of testing reveals issues that might not be apparent when components are tested in isolation, such as data transfer problems, communication failures between modules, or incompatibilities between integrated parts. Integration testing can be performed incrementally (integrating components one by one) or non-incrementally (combining all components at once). It serves as a bridge between unit testing and system testing, helping development teams identify interface defects early before they become more complex and costly to fix in later stages of development.",
        "trans_Question": "wɪ́tʃ sɔ́ftwɛ̀ər tɛ́stɪŋ əprówtʃ spəsɪ́fɪklij fówkəsɪz ɒn vɛ́ərɪfajɪŋ ðət dɪ́fərənt kəmpównənts ɔr mɒ́dʒuwlz wɜ́rk təɡɛ́ðər kərɛ́ktlij wɛ́n kəmbájnd?",
        "trans_RightAnswer": "ɪntəɡrejʃən tɛ́stɪŋ",
        "trans_WrongAnswers": [
            "júwnɪt tɛ́stɪŋ",
            "sɪ́stəm tɛ́stɪŋ",
            "rəɡrɛ́ʃən tɛ́stɪŋ",
            "æksɛ́ptəns tɛ́stɪŋ",
            "strɛ́s tɛ́stɪŋ"
        ],
        "trans_Explanation": "ɪntəɡrejʃən tɛ́stɪŋ ɪz ə krɪ́tɪkəl féjz ɪn sɔ́ftwɛ̀ər dəvɛ́ləpmənt wɛ́ər mʌ́ltɪpəl ɪndɪvɪ́dʒəwəl kəmpównənts ɔr mɒ́dʒuwlz ɑr kəmbájnd ənd tɛ́stɪd æz ə ɡrúwp. ʌ̀nlájk júwnɪt tɛ́stɪŋ, wɪ́tʃ əɡzǽmɪnz ájsəlèjtɪd kəmpównənts, ɪntəɡrejʃən tɛ́stɪŋ spəsɪ́fɪklij əvǽljuwèjts ðə ɪ́ntərfèjsɪz ənd ɪ̀ntərǽkʃənz bijtwíjn ɪ́ntəɡrejtɪd júwnɪts tə ənʃʊ́r ðej wɜ́rk təɡɛ́ðər æz əkspɛ́ktɪd. ðɪs tájp əv tɛ́stɪŋ rəvíjlz ɪ́ʃuwz ðət majt nɒt bij əpǽrənt wɛ́n kəmpównənts ɑr tɛ́stɪd ɪn àjsəléjʃən, sʌtʃ æz déjtə trǽnsfər prɒ́bləmz, kəmjùwnɪkéjʃən féjljərz bijtwíjn mɒ́dʒuwlz, ɔr ɪ̀nkɒ̀mpətɪbɪ́lɪtijz bijtwíjn ɪ́ntəɡrejtɪd pɑ́rts. ɪntəɡrejʃən tɛ́stɪŋ kən bij pərfɔ́rmd ɪnkrəmɛ́ntəlìj (ɪ́ntəɡrejtɪŋ kəmpównənts wʌ́n baj wʌ́n) ɔr nɒn-ɪnkrəmɛ́ntəlìj (kəmbájnɪŋ ɔl kəmpównənts æt wʌ́ns). ɪt sɜ́rvz æz ə brɪ́dʒ bijtwíjn júwnɪt tɛ́stɪŋ ənd sɪ́stəm tɛ́stɪŋ, hɛ́lpɪŋ dəvɛ́ləpmənt tíjmz ajdɛ́ntɪfàj ɪ́ntərfèjs díjfɛkts ɜ́rlij bəfɔ́r ðej bəkʌ́m mɔr kɒ́mplɛks ənd kɒ́stlij tə fɪ́ks ɪn léjtər stéjdʒɪz əv dəvɛ́ləpmənt."
    },
    {
        "Question": "Which testing activity involves evaluating the complete integrated software system against specified requirements?",
        "RightAnswer": "System Testing",
        "WrongAnswers": [
            "Unit Testing",
            "Integration Testing",
            "Acceptance Testing",
            "Regression Testing",
            "Smoke Testing"
        ],
        "Explanation": "System Testing is a comprehensive testing phase that evaluates the behavior of the entire software system as a whole. It focuses on validating that the complete integrated software meets the specified requirements and functions correctly in its intended environment. Unlike unit testing which examines individual components, or integration testing which verifies interfaces between components, system testing examines the end-to-end functionality from the user's perspective. It verifies that all system components work together properly and that the system complies with all functional, performance, and security requirements. System testing is typically performed in an environment that closely resembles the production environment to ensure the software works as expected under real-world conditions. This critical phase helps identify issues that might not be apparent when testing isolated components, such as performance bottlenecks, data integrity problems, or unexpected interactions between subsystems.",
        "trans_Question": "wɪ́tʃ tɛ́stɪŋ æktɪ́vɪtij ɪnvɒ́lvz əvǽljuwèjtɪŋ ðə kəmplíjt ɪ́ntəɡrejtɪd sɔ́ftwɛ̀ər sɪ́stəm əɡéjnst spɛ́sɪfàjd rəkwájərmənts?",
        "trans_RightAnswer": "sɪ́stəm tɛ́stɪŋ",
        "trans_WrongAnswers": [
            "júwnɪt tɛ́stɪŋ",
            "ɪntəɡrejʃən tɛ́stɪŋ",
            "æksɛ́ptəns tɛ́stɪŋ",
            "rəɡrɛ́ʃən tɛ́stɪŋ",
            "smówk tɛ́stɪŋ"
        ],
        "trans_Explanation": "sɪ́stəm tɛ́stɪŋ ɪz ə kɒ̀mprəhɛ́nsɪv tɛ́stɪŋ féjz ðət əvǽljuwèjts ðə bəhéjvjər əv ðə əntájər sɔ́ftwɛ̀ər sɪ́stəm æz ə hówl. ɪt fówkəsɪz ɒn vǽlɪdèjtɪŋ ðət ðə kəmplíjt ɪ́ntəɡrejtɪd sɔ́ftwɛ̀ər míjts ðə spɛ́sɪfàjd rəkwájərmənts ənd fʌ́ŋkʃənz kərɛ́ktlij ɪn ɪts ɪntɛ́ndɪd ənvájərənmənt. ʌ̀nlájk júwnɪt tɛ́stɪŋ wɪ́tʃ əɡzǽmɪnz ɪndɪvɪ́dʒəwəl kəmpównənts, ɔr ɪntəɡrejʃən tɛ́stɪŋ wɪ́tʃ vɛ́ərɪfajz ɪ́ntərfèjsɪz bijtwíjn kəmpównənts, sɪ́stəm tɛ́stɪŋ əɡzǽmɪnz ðə ɛ́nd-tə-ɛ́nd fʌ̀ŋkʃənǽlɪtij frəm ðə júwzər'z pərspɛ́ktɪv. ɪt vɛ́ərɪfajz ðət ɔl sɪ́stəm kəmpównənts wɜ́rk təɡɛ́ðər prɒ́pərlij ənd ðət ðə sɪ́stəm kəmplájz wɪð ɔl fʌ́ŋkʃənəl, pərfɔ́rməns, ənd səkjʊ́rɪtij rəkwájərmənts. sɪ́stəm tɛ́stɪŋ ɪz tɪ́pɪkəlij pərfɔ́rmd ɪn ən ənvájərənmənt ðət klówslij rijzɛ́mbəlz ðə prədʌ́kʃən ənvájərənmənt tə ənʃʊ́r ðə sɔ́ftwɛ̀ər wɜ́rks æz əkspɛ́ktɪd ʌ́ndər ríjəl-wɜ́rld kəndɪ́ʃənz. ðɪs krɪ́tɪkəl féjz hɛ́lps ajdɛ́ntɪfàj ɪ́ʃuwz ðət majt nɒt bij əpǽrənt wɛ́n tɛ́stɪŋ ájsəlèjtɪd kəmpównənts, sʌtʃ æz pərfɔ́rməns bɒ́təlnɛ̀ks, déjtə ɪntɛ́ɡrɪtij prɒ́bləmz, ɔr ʌ̀nəkspɛ́ktɪd ɪ̀ntərǽkʃənz bijtwíjn sʌ́bsɪ̀stəmz."
    },
    {
        "Question": "In a software development project, which testing phase specifically focuses on determining whether a system satisfies the business requirements and is acceptable for delivery to end users?",
        "RightAnswer": "Acceptance Testing",
        "WrongAnswers": [
            "Unit Testing",
            "Integration Testing",
            "Regression Testing",
            "Stress Testing",
            "Static Code Analysis"
        ],
        "Explanation": "Acceptance Testing is the final testing phase in software development that determines if a system meets the business requirements and is ready for delivery to end users. Unlike technical tests that focus on code quality or component interactions, acceptance testing evaluates the system from the user's perspective. It verifies that the software works as expected in real-world scenarios and satisfies the acceptance criteria defined by stakeholders. Acceptance testing typically includes validating user stories, confirming business processes work correctly, and ensuring the system accomplishes what users need it to do. This testing can be performed by clients, end users, or designated testers, and often includes both functional testing of requirements and non-functional aspects like usability and reliability. The primary goal is to build confidence that the software will serve its intended purpose effectively when deployed in its target environment.",
        "trans_Question": "ɪn ə sɔ́ftwɛ̀ər dəvɛ́ləpmənt prɒ́dʒɛkt, wɪ́tʃ tɛ́stɪŋ féjz spəsɪ́fɪklij fówkəsɪz ɒn dətɜ́rmɪnɪŋ wɛ́ðər ə sɪ́stəm sǽtɪsfàjz ðə bɪ́znəs rəkwájərmənts ənd ɪz æksɛ́ptəbəl fɔr dəlɪ́vərij tə ɛ́nd júwzərz?",
        "trans_RightAnswer": "æksɛ́ptəns tɛ́stɪŋ",
        "trans_WrongAnswers": [
            "júwnɪt tɛ́stɪŋ",
            "ɪntəɡrejʃən tɛ́stɪŋ",
            "rəɡrɛ́ʃən tɛ́stɪŋ",
            "strɛ́s tɛ́stɪŋ",
            "stǽtɪk kówd ənǽlɪsɪs"
        ],
        "trans_Explanation": "æksɛ́ptəns tɛ́stɪŋ ɪz ðə fájnəl tɛ́stɪŋ féjz ɪn sɔ́ftwɛ̀ər dəvɛ́ləpmənt ðət dətɜ́rmɪnz ɪf ə sɪ́stəm míjts ðə bɪ́znəs rəkwájərmənts ənd ɪz rɛ́dij fɔr dəlɪ́vərij tə ɛ́nd júwzərz. ʌ̀nlájk tɛ́knɪkəl tɛ́sts ðət fówkəs ɒn kówd kwɑ́lɪtij ɔr kəmpównənt ɪ̀ntərǽkʃənz, æksɛ́ptəns tɛ́stɪŋ əvǽljuwèjts ðə sɪ́stəm frəm ðə júwzər'z pərspɛ́ktɪv. ɪt vɛ́ərɪfajz ðət ðə sɔ́ftwɛ̀ər wɜ́rks æz əkspɛ́ktɪd ɪn ríjəl-wɜ́rld sənɛ́ərijowz ənd sǽtɪsfàjz ðə æksɛ́ptəns krajtɪ́ərijə dəfájnd baj stéjkhòwldərz. æksɛ́ptəns tɛ́stɪŋ tɪ́pɪkəlij ɪnklúwdz vǽlɪdèjtɪŋ júwzər stɔ́rijz, kənfɜ́rmɪŋ bɪ́znəs prɒ́sɛsɪz wɜ́rk kərɛ́ktlij, ənd ɛnʃʊ́rɪŋ ðə sɪ́stəm əkɒ́mplɪʃɪz wɒt júwzərz níjd ɪt tə dúw. ðɪs tɛ́stɪŋ kən bij pərfɔ́rmd baj klájənts, ɛ́nd júwzərz, ɔr dɛ́zɪɡnèjtɪd tɛ́stɪz, ənd ɔ́fən ɪnklúwdz bówθ fʌ́ŋkʃənəl tɛ́stɪŋ əv rəkwájərmənts ənd nɒn-fʌ́ŋkʃənəl ǽspɛkts lájk jùwzəbɪ́lɪtij ənd rəlàjəbɪ́lɪtij. ðə prájmɛ̀ərij ɡówl ɪz tə bɪ́ld kɒ́nfɪdəns ðət ðə sɔ́ftwɛ̀ər wɪl sɜ́rv ɪts ɪntɛ́ndɪd pɜ́rpəs əfɛ́ktɪvlij wɛ́n dəplɔ́jd ɪn ɪts tɑ́rɡət ənvájərənmənt."
    },
    {
        "Question": "After fixing a bug in one part of your application, what type of testing is specifically designed to verify that the fix hasn't broken functionality in other parts of the software?",
        "RightAnswer": "Regression Testing",
        "WrongAnswers": [
            "Stress Testing",
            "Unit Testing",
            "Acceptance Testing",
            "Smoke Testing",
            "Penetration Testing"
        ],
        "Explanation": "Regression Testing is a critical quality assurance practice in software development that focuses on verifying that recent code changes haven't adversely affected existing functionality. The term 'regression' refers to the idea that software can 'regress' or move backward in quality when changes are made. After developers fix bugs or add new features, regression tests run a selection of existing test cases to ensure everything that worked before still works properly. This is crucial because software systems are complex and interconnected—changes in one area can unexpectedly impact others. Regression testing can be manual but is often automated to efficiently verify system stability after each modification. It serves as a safety net that catches unforeseen side effects of changes, helping maintain software reliability throughout its development lifecycle.",
        "trans_Question": "ǽftər fɪ́ksɪŋ ə bʌ́ɡ ɪn wʌ́n pɑ́rt əv jɔr æ̀plɪkéjʃən, wɒt tájp əv tɛ́stɪŋ ɪz spəsɪ́fɪklij dəzájnd tə vɛ́ərɪfaj ðət ðə fɪ́ks hǽzənt brówkən fʌ̀ŋkʃənǽlɪtij ɪn ʌ́ðər pɑ́rts əv ðə sɔ́ftwɛ̀ər?",
        "trans_RightAnswer": "rəɡrɛ́ʃən tɛ́stɪŋ",
        "trans_WrongAnswers": [
            "strɛ́s tɛ́stɪŋ",
            "júwnɪt tɛ́stɪŋ",
            "æksɛ́ptəns tɛ́stɪŋ",
            "smówk tɛ́stɪŋ",
            "pɛ̀nətréjʃən tɛ́stɪŋ"
        ],
        "trans_Explanation": "rəɡrɛ́ʃən tɛ́stɪŋ ɪz ə krɪ́tɪkəl kwɑ́lɪtij əʃʊ́rəns prǽktɪs ɪn sɔ́ftwɛ̀ər dəvɛ́ləpmənt ðət fówkəsɪz ɒn vɛ́ərɪfajɪŋ ðət ríjsənt kówd tʃéjndʒɪz hǽvən ædvɜ́rslij əfɛ́ktɪd əɡzɪ́stɪŋ fʌ̀ŋkʃənǽlɪtij. ðə tɜ́rm 'rəɡrɛ́ʃən' rəfɜ́rz tə ðə ajdíjə ðət sɔ́ftwɛ̀ər kən 'rɪɡrɛ́s' ɔr múwv bǽkwərd ɪn kwɑ́lɪtij wɛ́n tʃéjndʒɪz ɑr méjd. ǽftər dəvɛ́ləpərz fɪ́ks bʌ́ɡz ɔr ǽd núw fíjtʃərz, rəɡrɛ́ʃən tɛ́sts rʌ́n ə səlɛ́kʃən əv əɡzɪ́stɪŋ tɛ́st kéjsɪz tə ənʃʊ́r ɛ́vrijθɪ̀ŋ ðət wɜ́rkt bəfɔ́r stɪ́l wɜ́rks prɒ́pərlij. ðɪs ɪz krúwʃəl bəkɒ́z sɔ́ftwɛ̀ər sɪ́stəmz ɑr kɒ́mplɛks ənd ɪ̀ntərkənɛ́ktɪd—tʃéjndʒɪz ɪn wʌ́n ɛ́ərijə kən ʌ̀nəkspɛ́ktɪdlij ɪ́mpækt ʌ́ðərz. rəɡrɛ́ʃən tɛ́stɪŋ kən bij mǽnjuwəl bʌt ɪz ɔ́fən ɔ́təmèjtɪd tə əfɪ́ʃəntlij vɛ́ərɪfaj sɪ́stəm stəbɪ́lɪtij ǽftər ijtʃ mɒ̀dɪfɪkéjʃən. ɪt sɜ́rvz æz ə séjftij nɛ́t ðət kǽtʃɪz ʌ̀nfɔrsíjn sájd əfɛ́kts əv tʃéjndʒɪz, hɛ́lpɪŋ mejntéjn sɔ́ftwɛ̀ər rəlàjəbɪ́lɪtij θruwáwt ɪts dəvɛ́ləpmənt lájfsàjkəl."
    },
    {
        "Question": "What type of testing specifically evaluates a system's responsiveness, stability, and resource usage under various workloads?",
        "RightAnswer": "Performance Testing",
        "WrongAnswers": [
            "Unit Testing",
            "Integration Testing",
            "Accessibility Testing",
            "Penetration Testing",
            "Regression Testing"
        ],
        "Explanation": "Performance Testing is a specialized approach in software engineering that focuses on determining how a system behaves and responds under various conditions. Unlike functional testing which verifies what a system does, performance testing examines how well it operates. This includes measuring response times, throughput rates, resource utilization levels, and the overall stability and scalability of the application under different load conditions. For example, it might assess how quickly a website responds when thousands of users access it simultaneously or how efficiently a database handles large volumes of transactions. Performance testing helps development teams identify bottlenecks, determine capacity limits, and ensure that software meets specific performance requirements before deployment. Common types include load testing, stress testing, endurance testing, and spike testing, each examining different aspects of system performance under various conditions.",
        "trans_Question": "wɒt tájp əv tɛ́stɪŋ spəsɪ́fɪklij əvǽljuwèjts ə sɪ́stəm'z rəspɒ́nsɪvnəs, stəbɪ́lɪtij, ənd ríjsɔrs júwsɪdʒ ʌ́ndər vɛ́ərijəs wɜ́rklòwdz?",
        "trans_RightAnswer": "pərfɔ́rməns tɛ́stɪŋ",
        "trans_WrongAnswers": [
            "júwnɪt tɛ́stɪŋ",
            "ɪntəɡrejʃən tɛ́stɪŋ",
            "æ̀ksɛsɪbɪ́lɪtij tɛ́stɪŋ",
            "pɛ̀nətréjʃən tɛ́stɪŋ",
            "rəɡrɛ́ʃən tɛ́stɪŋ"
        ],
        "trans_Explanation": "pərfɔ́rməns tɛ́stɪŋ ɪz ə spɛ́ʃəlàjzd əprówtʃ ɪn sɔ́ftwɛ̀ər ɛ̀ndʒɪnɪ́ərɪŋ ðət fówkəsɪz ɒn dətɜ́rmɪnɪŋ háw ə sɪ́stəm bəhéjvz ənd rəspɒ́ndz ʌ́ndər vɛ́ərijəs kəndɪ́ʃənz. ʌ̀nlájk fʌ́ŋkʃənəl tɛ́stɪŋ wɪ́tʃ vɛ́ərɪfajz wɒt ə sɪ́stəm dʌz, pərfɔ́rməns tɛ́stɪŋ əɡzǽmɪnz háw wɛ́l ɪt ɒ́pərèjts. ðɪs ɪnklúwdz mɛ́ʒərɪŋ rəspɒ́ns tájmz, θrúwpʊ̀t réjts, ríjsɔrs jùwtɪlɪzéjʃən lɛ́vəlz, ənd ðə ówvərɔ̀l stəbɪ́lɪtij ənd skéjləbɪ́lɪtij əv ðə æ̀plɪkéjʃən ʌ́ndər dɪ́fərənt lówd kəndɪ́ʃənz. fɔr əɡzǽmpəl, ɪt majt əsɛ́s háw kwɪ́klij ə wɛ́bsàjt rəspɒ́ndz wɛ́n θáwzəndz əv júwzərz ǽksɛ̀s ɪt sàjməltéjnijəslij ɔr háw əfɪ́ʃəntlij ə déjtəbèjs hǽndəlz lɑ́rdʒ vɒ́ljuwmz əv trænzǽkʃənz. pərfɔ́rməns tɛ́stɪŋ hɛ́lps dəvɛ́ləpmənt tíjmz ajdɛ́ntɪfàj bɒ́təlnɛ̀ks, dətɜ́rmɪn kəpǽsɪtij lɪ́mɪts, ənd ənʃʊ́r ðət sɔ́ftwɛ̀ər míjts spəsɪ́fɪk pərfɔ́rməns rəkwájərmənts bəfɔ́r dəplɔ́jmənt. kɒ́mən tájps ɪnklúwd lówd tɛ́stɪŋ, strɛ́s tɛ́stɪŋ, ɛ́ndərəns tɛ́stɪŋ, ənd spájk tɛ́stɪŋ, ijtʃ əɡzǽmɪnɪŋ dɪ́fərənt ǽspɛkts əv sɪ́stəm pərfɔ́rməns ʌ́ndər vɛ́ərijəs kəndɪ́ʃənz."
    },
    {
        "Question": "Which software development practice involves deliberately attempting to find vulnerabilities in a system by simulating potential attacks and evaluating defense mechanisms?",
        "RightAnswer": "Security Testing",
        "WrongAnswers": [
            "Regression Testing",
            "Usability Analysis",
            "Performance Profiling",
            "Code Refactoring",
            "Dependency Injection"
        ],
        "Explanation": "Security Testing is a specialized evaluation process designed to reveal vulnerabilities, weaknesses, and potential entry points in software systems before malicious actors can exploit them. Unlike standard functional testing that verifies if a system works correctly, security testing deliberately attempts to make the system fail in unexpected ways. Testers adopt an adversarial mindset, employing techniques like penetration testing, vulnerability scanning, and ethical hacking to identify security flaws. These might include improper authentication mechanisms, data exposure risks, injection vulnerabilities, or insecure configurations. Security testing has become increasingly crucial as systems grow more interconnected and cyber threats become more sophisticated. It serves as a proactive defense mechanism that helps organizations protect sensitive data, maintain user trust, and comply with regulatory requirements by identifying and addressing security issues early in the development lifecycle.",
        "trans_Question": "wɪ́tʃ sɔ́ftwɛ̀ər dəvɛ́ləpmənt prǽktɪs ɪnvɒ́lvz dəlɪ́bərətlij ətɛ́mptɪŋ tə fájnd vʌ̀lnərəbɪ́lɪtijz ɪn ə sɪ́stəm baj sɪ́mjəlèjtɪŋ pətɛ́nʃəl ətǽks ənd əvǽljuwèjtɪŋ dəfɛ́ns mɛ́kənɪzəmz?",
        "trans_RightAnswer": "səkjʊ́rɪtij tɛ́stɪŋ",
        "trans_WrongAnswers": [
            "rəɡrɛ́ʃən tɛ́stɪŋ",
            "jùwzəbɪ́lɪtij ənǽlɪsɪs",
            "pərfɔ́rməns prówfàjlɪŋ",
            "kówd rijfǽktərɪŋ",
            "dəpɛ́ndənsij ɪndʒɛ́kʃən"
        ],
        "trans_Explanation": "səkjʊ́rɪtij tɛ́stɪŋ ɪz ə spɛ́ʃəlàjzd əvæ̀ljuwéjʃən prɒ́sɛs dəzájnd tə rəvíjl vʌ̀lnərəbɪ́lɪtijz, wíjknəsɪz, ənd pətɛ́nʃəl ɛ́ntrij pɔ́jnts ɪn sɔ́ftwɛ̀ər sɪ́stəmz bəfɔ́r məlɪ́ʃəs ǽktərz kən ɛ́ksplɔ̀jt ðɛm. ʌ̀nlájk stǽndərd fʌ́ŋkʃənəl tɛ́stɪŋ ðət vɛ́ərɪfajz ɪf ə sɪ́stəm wɜ́rks kərɛ́ktlij, səkjʊ́rɪtij tɛ́stɪŋ dəlɪ́bərətlij ətɛ́mpts tə méjk ðə sɪ́stəm féjl ɪn ʌ̀nəkspɛ́ktɪd wéjz. tɛ́stɪz ədɒ́pt ən æ̀dvərsɛ́ərijəl májndsɛ̀t, ɛmplɔ́jɪŋ tɛkníjks lájk pɛ̀nətréjʃən tɛ́stɪŋ, vʌ̀lnərəbɪ́lɪtij skǽnɪŋ, ənd ɛ́θɪkəl hǽkɪŋ tə ajdɛ́ntɪfàj səkjʊ́rɪtij flɔ́z. ðijz majt ɪnklúwd ɪ̀mprɒ́pər ɔθɛ̀ntɪkéjʃən mɛ́kənɪzəmz, déjtə əkspówʒər rɪ́sks, ɪndʒɛ́kʃən vʌ̀lnərəbɪ́lɪtijz, ɔr ɪ́nsəkjʊr kənfɪ̀ɡjəréjʃənz. səkjʊ́rɪtij tɛ́stɪŋ həz bəkʌ́m ɪnkríjsɪŋɡlij krúwʃəl æz sɪ́stəmz ɡrów mɔr ɪ̀ntərkənɛ́ktɪd ənd sájbər θrɛ́ts bəkʌ́m mɔr səfɪ́stɪkèjtɪd. ɪt sɜ́rvz æz ə pròwǽktɪv dəfɛ́ns mɛ́kənɪzəm ðət hɛ́lps ɔ̀rɡənɪzéjʃənz prətɛ́kt sɛ́nsɪtɪv déjtə, mejntéjn júwzər trʌ́st, ənd kəmpláj wɪð rɛ́ɡjələtɔrij rəkwájərmənts baj ajdɛ́ntɪfàjɪŋ ənd ədrɛ́sɪŋ səkjʊ́rɪtij ɪ́ʃuwz ɜ́rlij ɪn ðə dəvɛ́ləpmənt lájfsàjkəl."
    },
    {
        "Question": "Which evaluation method involves real users completing typical tasks with a system while observers collect data on their performance and satisfaction?",
        "RightAnswer": "Usability Testing",
        "WrongAnswers": [
            "Heuristic Evaluation",
            "Code Refactoring",
            "Functional Testing",
            "Stress Testing",
            "Data Mining"
        ],
        "Explanation": "Usability Testing is a critical evaluation technique in user experience design where actual end users are observed as they interact with a product, application, or website to complete specific tasks. During these sessions, evaluators collect data on user behavior including time on task, error rates, task completion success, and subjective satisfaction. Unlike other testing methods that focus on technical functionality, usability testing specifically examines how easily users can learn and use a system to achieve their goals. This hands-on approach reveals real-world interaction problems that might otherwise go unnoticed by developers who are too familiar with the system. Usability testing can range from formal lab studies with specialized equipment to more informal guerrilla testing sessions. The insights gained help teams create more intuitive, efficient, and satisfying user experiences by identifying friction points and opportunities for improvement through the users' perspective.",
        "trans_Question": "wɪ́tʃ əvæ̀ljuwéjʃən mɛ́θəd ɪnvɒ́lvz ríjəl júwzərz kəmplíjtɪŋ tɪ́pɪkəl tǽsks wɪð ə sɪ́stəm wájl əbzɜ́rvərz kəlɛ́kt déjtə ɒn ðɛər pərfɔ́rməns ənd sæ̀tɪsfǽkʃən?",
        "trans_RightAnswer": "jùwzəbɪ́lɪtij tɛ́stɪŋ",
        "trans_WrongAnswers": [
            "hjʊrɪ́stɪk əvæ̀ljuwéjʃən",
            "kówd rijfǽktərɪŋ",
            "fʌ́ŋkʃənəl tɛ́stɪŋ",
            "strɛ́s tɛ́stɪŋ",
            "déjtə májnɪŋ"
        ],
        "trans_Explanation": "jùwzəbɪ́lɪtij tɛ́stɪŋ ɪz ə krɪ́tɪkəl əvæ̀ljuwéjʃən tɛkníjk ɪn júwzər əkspɪ́ərijəns dəzájn wɛ́ər ǽktʃəl ɛ́nd júwzərz ɑr əbzɜ́rvd æz ðej ɪ̀ntərǽkt wɪð ə prɒ́dəkt, æ̀plɪkéjʃən, ɔr wɛ́bsàjt tə kəmplíjt spəsɪ́fɪk tǽsks. dʊ́rɪŋ ðijz sɛ́ʃənz, ɪvǽljəwèjtərz kəlɛ́kt déjtə ɒn júwzər bəhéjvjər ɪnklúwdɪŋ tájm ɒn tǽsk, ɛ́ərər réjts, tǽsk kəmplíjʃən səksɛ́s, ənd sʌbdʒɛ́ktɪv sæ̀tɪsfǽkʃən. ʌ̀nlájk ʌ́ðər tɛ́stɪŋ mɛ́θədz ðət fówkəs ɒn tɛ́knɪkəl fʌ̀ŋkʃənǽlɪtij, jùwzəbɪ́lɪtij tɛ́stɪŋ spəsɪ́fɪklij əɡzǽmɪnz háw íjzəlij júwzərz kən lɜ́rn ənd juwz ə sɪ́stəm tə ətʃíjv ðɛər ɡówlz. ðɪs hǽndz-ɒn əprówtʃ rəvíjlz ríjəl-wɜ́rld ɪ̀ntərǽkʃən prɒ́bləmz ðət majt ʌ́ðərwàjz ɡow ʌ̀nnówtɪst baj dəvɛ́ləpərz huw ɑr túw fəmɪ́ljər wɪð ðə sɪ́stəm. jùwzəbɪ́lɪtij tɛ́stɪŋ kən réjndʒ frəm fɔ́rməl lǽb stʌ́dijz wɪð spɛ́ʃəlàjzd əkwɪ́pmənt tə mɔr ɪnfɔ́rməl ɡərɪ́lə tɛ́stɪŋ sɛ́ʃənz. ðə ɪ́nsàjts ɡéjnd hɛ́lp tíjmz krijéjt mɔr ɪntúwɪtɪv, əfɪ́ʃənt, ənd sǽtɪsfàjɪŋ júwzər əkspɪ́ərijənsijz baj ajdɛ́ntɪfàjɪŋ frɪ́kʃən pɔ́jnts ənd ɒ̀pərtúwnɪtijz fɔr ɪmprúwvmənt θrúw ðə júwzərz' pərspɛ́ktɪv."
    },
    {
        "Question": "Which software development practice involves creating scripts that can verify code functionality without manual intervention?",
        "RightAnswer": "Automated Testing",
        "WrongAnswers": [
            "Recursive Debugging",
            "Continuous Deployment",
            "Static Analysis",
            "Code Refactoring",
            "Version Control"
        ],
        "Explanation": "Automated Testing is a software development practice where test cases are converted into scripts that automatically execute without human intervention. These tests verify that code functions correctly, detect bugs, and ensure that new changes don't break existing functionality. Unlike manual testing, which requires human testers to execute test cases step by step, automated tests can run repeatedly, consistently, and much faster. Automated Testing is foundational to modern development methodologies like Continuous Integration, where code changes are verified automatically upon submission. The practice includes various levels such as unit tests that verify individual components, integration tests that check component interactions, and end-to-end tests that validate entire workflows. By implementing Automated Testing, development teams can release higher quality software more frequently while reducing the time spent on repetitive testing tasks.",
        "trans_Question": "wɪ́tʃ sɔ́ftwɛ̀ər dəvɛ́ləpmənt prǽktɪs ɪnvɒ́lvz krijéjtɪŋ skrɪ́pts ðət kən vɛ́ərɪfaj kówd fʌ̀ŋkʃənǽlɪtij wɪðáwt mǽnjuwəl ɪ̀ntərvɛ́nʃən?",
        "trans_RightAnswer": "ɔ́təmèjtɪd tɛ́stɪŋ",
        "trans_WrongAnswers": [
            "rəkɜ́rsɪv dijbʌ́ɡɪŋ",
            "kəntɪ́njuwəs dəplɔ́jmənt",
            "stǽtɪk ənǽlɪsɪs",
            "kówd rijfǽktərɪŋ",
            "vɜ́rʒən kəntrówl"
        ],
        "trans_Explanation": "ɔ́təmèjtɪd tɛ́stɪŋ ɪz ə sɔ́ftwɛ̀ər dəvɛ́ləpmənt prǽktɪs wɛ́ər tɛ́st kéjsɪz ɑr kənvɜ́rtɪd ɪntə skrɪ́pts ðət ɔ̀təmǽtɪklij ɛ́ksəkjùwt wɪðáwt hjúwmən ɪ̀ntərvɛ́nʃən. ðijz tɛ́sts vɛ́ərɪfaj ðət kówd fʌ́ŋkʃənz kərɛ́ktlij, dətɛ́kt bʌ́ɡz, ənd ənʃʊ́r ðət núw tʃéjndʒɪz dównt bréjk əɡzɪ́stɪŋ fʌ̀ŋkʃənǽlɪtij. ʌ̀nlájk mǽnjuwəl tɛ́stɪŋ, wɪ́tʃ rəkwájərz hjúwmən tɛ́stɪz tə ɛ́ksəkjùwt tɛ́st kéjsɪz stɛ́p baj stɛ́p, ɔ́təmèjtɪd tɛ́sts kən rʌ́n rəpíjtɪdlij, kənsɪ́stəntlij, ənd mʌtʃ fǽstər. ɔ́təmèjtɪd tɛ́stɪŋ ɪz fawndéjʃənəl tə mɒ́dərn dəvɛ́ləpmənt mɛ̀θowdɒ́lədʒijz lájk kəntɪ́njuwəs ɪntəɡrejʃən, wɛ́ər kówd tʃéjndʒɪz ɑr vɛ́ərɪfajd ɔ̀təmǽtɪklij əpɒ́n səbmɪ́ʃən. ðə prǽktɪs ɪnklúwdz vɛ́ərijəs lɛ́vəlz sʌtʃ æz júwnɪt tɛ́sts ðət vɛ́ərɪfaj ɪndɪvɪ́dʒəwəl kəmpównənts, ɪntəɡrejʃən tɛ́sts ðət tʃɛ́k kəmpównənt ɪ̀ntərǽkʃənz, ənd ɛ́nd-tə-ɛ́nd tɛ́sts ðət vǽlɪdèjt əntájər wɜ́rkflòwz. baj ɪ́mpləmɛ̀ntɪŋ ɔ́təmèjtɪd tɛ́stɪŋ, dəvɛ́ləpmənt tíjmz kən rəlíjs hájər kwɑ́lɪtij sɔ́ftwɛ̀ər mɔr fríjkwəntlij wájl rədjúwsɪŋ ðə tájm spɛ́nt ɒn rəpɛ́tɪtɪv tɛ́stɪŋ tǽsks."
    },
    {
        "Question": "Which technical infrastructure provides developers with a standardized approach for creating, executing, and reporting automated software tests?",
        "RightAnswer": "Test Automation Framework",
        "WrongAnswers": [
            "Code Validation Engine",
            "Quality Assurance Protocol",
            "System Integration Pipeline",
            "Software Verification Suite",
            "Continuous Assessment Platform"
        ],
        "Explanation": "A Test Automation Framework is a comprehensive set of guidelines, practices, tools, and components designed to streamline the process of automated testing. It provides a structured architecture that enables testers and developers to create maintainable, reusable test scripts with minimal effort. The framework typically includes features for handling test data, logging results, generating reports, and managing test environments. Rather than forcing testers to build automation solutions from scratch for each project, a well-designed Test Automation Framework offers reusable functions, consistent standards, and integrated tools that significantly reduce the complexity and time required for automated testing. Common types include data-driven, keyword-driven, hybrid, and behavior-driven frameworks, each serving different testing needs and approaches. By implementing a Test Automation Framework, organizations can achieve more reliable testing, better collaboration between team members, and ultimately higher software quality with faster delivery cycles.",
        "trans_Question": "wɪ́tʃ tɛ́knɪkəl ɪnfrəstrʌ́ktʃər prəvájdz dəvɛ́ləpərz wɪð ə stǽndərdàjzd əprówtʃ fɔr krijéjtɪŋ, ɛ́ksəkjùwtɪŋ, ənd rijpɔ́rtɪŋ ɔ́təmèjtɪd sɔ́ftwɛ̀ər tɛ́sts?",
        "trans_RightAnswer": "tɛ́st ɔtəméjʃən fréjmwɜ̀rk",
        "trans_WrongAnswers": [
            "kówd væ̀lɪdéjʃən ɛ́ndʒɪn",
            "kwɑ́lɪtij əʃʊ́rəns prówtəkɒ̀l",
            "sɪ́stəm ɪntəɡrejʃən pájplàjn",
            "sɔ́ftwɛ̀ər vɛ̀ərɪfɪkéjʃən swíjt",
            "kəntɪ́njuwəs əsɛ́smənt plǽtfɔ̀rm"
        ],
        "trans_Explanation": "ə tɛ́st ɔtəméjʃən fréjmwɜ̀rk ɪz ə kɒ̀mprəhɛ́nsɪv sɛ́t əv ɡájdlàjnz, prǽktɪsɪz, túwlz, ənd kəmpównənts dəzájnd tə stríjmlàjn ðə prɒ́sɛs əv ɔ́təmèjtɪd tɛ́stɪŋ. ɪt prəvájdz ə strʌ́ktʃərd ɑ́rkɪtɛ̀ktʃər ðət ɛnéjbəlz tɛ́stɪz ənd dəvɛ́ləpərz tə krijéjt mejntéjnəbəl, rijúwzəbəl tɛ́st skrɪ́pts wɪð mɪ́nɪməl ɛ́fərt. ðə fréjmwɜ̀rk tɪ́pɪkəlij ɪnklúwdz fíjtʃərz fɔr hǽndəlɪŋ tɛ́st déjtə, lɔ́ɡɪŋ rəzʌ́lts, dʒɛ́nərèjtɪŋ rijpɔ́rts, ənd mǽnɪdʒɪŋ tɛ́st ənvájərənmənts. rǽðər ðʌn fɔ́rsɪŋ tɛ́stɪz tə bɪ́ld ɔtəméjʃən səlúwʃənz frəm skrǽtʃ fɔr ijtʃ prɒ́dʒɛkt, ə wɛ́l-dəzájnd tɛ́st ɔtəméjʃən fréjmwɜ̀rk ɔ́fərz rijúwzəbəl fʌ́ŋkʃənz, kənsɪ́stənt stǽndərdz, ənd ɪ́ntəɡrejtɪd túwlz ðət sɪɡnɪ́fɪkəntlij rədjúws ðə kəmplɛ́ksɪtij ənd tájm rəkwájərd fɔr ɔ́təmèjtɪd tɛ́stɪŋ. kɒ́mən tájps ɪnklúwd déjtə-drɪ́vən, kíjwɜ̀rd-drɪ́vən, hájbrɪd, ənd bəhéjvjər-drɪ́vən fréjmwɜ̀rks, ijtʃ sɜ́rvɪŋ dɪ́fərənt tɛ́stɪŋ níjdz ənd əprówtʃɪz. baj ɪ́mpləmɛ̀ntɪŋ ə tɛ́st ɔtəméjʃən fréjmwɜ̀rk, ɔ̀rɡənɪzéjʃənz kən ətʃíjv mɔr rəlájəbəl tɛ́stɪŋ, bɛ́tər kəlæ̀bəréjʃən bijtwíjn tíjm mɛ́mbərz, ənd ʌ́ltɪmətlij hájər sɔ́ftwɛ̀ər kwɑ́lɪtij wɪð fǽstər dəlɪ́vərij sájkəlz."
    },
    {
        "Question": "In testing software, what is the term for creating simulated objects that mimic the behavior of real dependencies to isolate the code being tested?",
        "RightAnswer": "Mocking",
        "WrongAnswers": [
            "Faking",
            "Spoofing",
            "Shadowing",
            "Virtualizing",
            "Emulating"
        ],
        "Explanation": "Mocking is a technique used in software testing where developers create simulated objects called 'mocks' that mimic the behavior of real system components. These mocks replace actual dependencies like databases, web services, or complex objects that might be slow, unavailable, or difficult to set up for testing. By using mocks, developers can isolate the specific code they want to test, control all external interactions, verify how their code interacts with dependencies, and create predictable testing environments. Mocking frameworks like Mockito (Java), Moq (.NET), or Jest (JavaScript) make it easier to create these test doubles. The key benefit of mocking is that it allows testing components in isolation, leading to faster, more reliable tests that focus on specific functionality rather than being affected by external systems.",
        "trans_Question": "ɪn tɛ́stɪŋ sɔ́ftwɛ̀ər, wɒt ɪz ðə tɜ́rm fɔr krijéjtɪŋ sɪ́mjəlèjtɪd ɒ́bdʒɛkts ðət mɪ́mɪk ðə bəhéjvjər əv ríjəl dəpɛ́ndənsijz tə ájsəlèjt ðə kówd bíjɪŋ tɛ́stɪd?",
        "trans_RightAnswer": "mɒ́kɪŋ",
        "trans_WrongAnswers": [
            "féjkɪŋ",
            "spúwfɪŋ",
            "ʃǽdowɪŋ",
            "vɜ́rtʃuwəlajzɪŋ",
            "ɛ́mjəlèjtɪŋ"
        ],
        "trans_Explanation": "mɒ́kɪŋ ɪz ə tɛkníjk júwzd ɪn sɔ́ftwɛ̀ər tɛ́stɪŋ wɛ́ər dəvɛ́ləpərz krijéjt sɪ́mjəlèjtɪd ɒ́bdʒɛkts kɔ́ld 'mɒ́ks' ðət mɪ́mɪk ðə bəhéjvjər əv ríjəl sɪ́stəm kəmpównənts. ðijz mɒ́ks rìjpléjs ǽktʃəl dəpɛ́ndənsijz lájk déjtəbèjsɪz, wɛ́b sɜ́rvɪsɪz, ɔr kɒ́mplɛks ɒ́bdʒɛkts ðət majt bij slów, ʌ̀nəvéjləbəl, ɔr dɪ́fɪkəlt tə sɛ́t ʌp fɔr tɛ́stɪŋ. baj júwzɪŋ mɒ́ks, dəvɛ́ləpərz kən ájsəlèjt ðə spəsɪ́fɪk kówd ðej wɒ́nt tə tɛ́st, kəntrówl ɔl əkstɜ́rnəl ɪ̀ntərǽkʃənz, vɛ́ərɪfaj háw ðɛər kówd ɪ̀ntərǽkts wɪð dəpɛ́ndənsijz, ənd krijéjt prədɪ́ktəbəl tɛ́stɪŋ ənvájərənmənts. mɒ́kɪŋ fréjmwɜ̀rks lájk mɒkíjtow (dʒɒ́və), mɒk (.NET), ɔr dʒɛ́st (dʒɒ́vəskrɪ̀pt) méjk ɪt íjzijər tə krijéjt ðijz tɛ́st dʌ́bəlz. ðə kíj bɛ́nəfɪt əv mɒ́kɪŋ ɪz ðət ɪt əláwz tɛ́stɪŋ kəmpównənts ɪn àjsəléjʃən, líjdɪŋ tə fǽstər, mɔr rəlájəbəl tɛ́sts ðət fówkəs ɒn spəsɪ́fɪk fʌ̀ŋkʃənǽlɪtij rǽðər ðʌn bíjɪŋ əfɛ́ktɪd baj əkstɜ́rnəl sɪ́stəmz."
    },
    {
        "Question": "Which software development metric measures how much of a program's source code is executed during testing to identify untested parts of a codebase?",
        "RightAnswer": "Code Coverage",
        "WrongAnswers": [
            "Cyclomatic Complexity",
            "Technical Debt",
            "Code Refactoring",
            "Program Tracing",
            "Execution Profiling"
        ],
        "Explanation": "Code Coverage is a critical metric in software testing that quantifies what percentage of a program's source code has been executed during testing. It helps development teams identify which parts of their codebase remain untested, potentially harboring undetected bugs. There are several types of coverage measurements, including statement coverage (which lines were executed), branch coverage (which decision paths were taken), function coverage (which functions were called), and condition coverage (which boolean sub-expressions were evaluated). A high code coverage percentage indicates comprehensive testing, though it doesn't necessarily guarantee quality, as it measures only if code was executed, not if it was tested effectively. Modern development environments often include tools that generate visual reports highlighting covered and uncovered sections of code with different colors, helping teams prioritize additional testing efforts strategically.",
        "trans_Question": "wɪ́tʃ sɔ́ftwɛ̀ər dəvɛ́ləpmənt mɛ́trɪk mɛ́ʒərz háw mʌtʃ əv ə prówɡræ̀m'z sɔ́rs kówd ɪz ɛ́ksəkjùwtɪd dʊ́rɪŋ tɛ́stɪŋ tə ajdɛ́ntɪfàj ʌ̀ntɛ́stɪd pɑ́rts əv ə kówdbèjs?",
        "trans_RightAnswer": "kówd kʌ́vərɪdʒ",
        "trans_WrongAnswers": [
            "sàjklowmǽtɪk kəmplɛ́ksɪtij",
            "tɛ́knɪkəl dɛ́t",
            "kówd rijfǽktərɪŋ",
            "prówɡræ̀m tréjsɪŋ",
            "ɛ̀ksəkjúwʃən prówfàjlɪŋ"
        ],
        "trans_Explanation": "kówd kʌ́vərɪdʒ ɪz ə krɪ́tɪkəl mɛ́trɪk ɪn sɔ́ftwɛ̀ər tɛ́stɪŋ ðət kwɑ́ntɪfajz wɒt pərsɛ́ntɪdʒ əv ə prówɡræ̀m'z sɔ́rs kówd həz bɪn ɛ́ksəkjùwtɪd dʊ́rɪŋ tɛ́stɪŋ. ɪt hɛ́lps dəvɛ́ləpmənt tíjmz ajdɛ́ntɪfàj wɪ́tʃ pɑ́rts əv ðɛər kówdbèjs rəméjn ʌ̀ntɛ́stɪd, pətɛ́nʃəlij hɑ́rbərɪŋ ʌ̀ndətɛ́ktɪd bʌ́ɡz. ðɛər ɑr sɛ́vərəl tájps əv kʌ́vərɪdʒ mɛ́ʒərmənts, ɪnklúwdɪŋ stéjtmənt kʌ́vərɪdʒ (wɪ́tʃ lájnz wɜ́r ɛ́ksəkjùwtɪd), brǽntʃ kʌ́vərɪdʒ (wɪ́tʃ dəsɪ́ʒən pǽðz wɜ́r téjkən), fʌ́ŋkʃən kʌ́vərɪdʒ (wɪ́tʃ fʌ́ŋkʃənz wɜ́r kɔ́ld), ənd kəndɪ́ʃən kʌ́vərɪdʒ (wɪ́tʃ buwlíjən sʌ́b-əksprɛ́ʃənz wɜ́r əvǽljuwèjtɪd). ə háj kówd kʌ́vərɪdʒ pərsɛ́ntɪdʒ ɪ́ndɪkèjts kɒ̀mprəhɛ́nsɪv tɛ́stɪŋ, ðów ɪt dʌ́zənt nɛ̀səsɛ́ərɪlij ɡɛ̀ərəntíj kwɑ́lɪtij, æz ɪt mɛ́ʒərz ównlij ɪf kówd wɒz ɛ́ksəkjùwtɪd, nɒt ɪf ɪt wɒz tɛ́stɪd əfɛ́ktɪvlij. mɒ́dərn dəvɛ́ləpmənt ənvájərənmənts ɔ́fən ɪnklúwd túwlz ðət dʒɛ́nərèjt vɪ́ʒəwəl rijpɔ́rts hájlàjtɪŋ kʌ́vərd ənd ʌ̀nkʌ́vərd sɛ́kʃənz əv kówd wɪð dɪ́fərənt kʌ́lərz, hɛ́lpɪŋ tíjmz prajɔ́rɪtajz ədɪ́ʃənəl tɛ́stɪŋ ɛ́fərts strətíjdʒɪklij."
    },
    {
        "Question": "Which technique involves analyzing the behavior and performance characteristics of software to identify bottlenecks and inefficiencies?",
        "RightAnswer": "Profiling",
        "WrongAnswers": [
            "Debugging",
            "Refactoring",
            "Unit Testing",
            "Version Control",
            "Code Linting"
        ],
        "Explanation": "Profiling is a dynamic program analysis technique that measures various aspects of software execution such as memory usage, CPU utilization, function call frequency, and execution time. Unlike debugging which focuses on finding and fixing errors, profiling concentrates on identifying performance bottlenecks and resource consumption patterns. Developers use profiling tools to collect metrics during program execution, helping them understand which parts of their code are consuming the most resources or taking the longest to execute. This information allows programmers to make targeted optimizations, improving application efficiency and responsiveness. Profiling is essential in performance-critical applications and is commonly used when fine-tuning algorithms, optimizing database queries, or enhancing user experience in resource-intensive software.",
        "trans_Question": "wɪ́tʃ tɛkníjk ɪnvɒ́lvz ǽnəlàjzɪŋ ðə bəhéjvjər ənd pərfɔ́rməns kæ̀rəktərɪ́stɪks əv sɔ́ftwɛ̀ər tə ajdɛ́ntɪfàj bɒ́təlnɛ̀ks ənd ɪ̀nəfɪ́ʃənsijz?",
        "trans_RightAnswer": "prówfàjlɪŋ",
        "trans_WrongAnswers": [
            "dijbʌ́ɡɪŋ",
            "rijfǽktərɪŋ",
            "júwnɪt tɛ́stɪŋ",
            "vɜ́rʒən kəntrówl",
            "kówd lɪ́ntɪŋ"
        ],
        "trans_Explanation": "prówfàjlɪŋ ɪz ə dajnǽmɪk prówɡræ̀m ənǽlɪsɪs tɛkníjk ðət mɛ́ʒərz vɛ́ərijəs ǽspɛkts əv sɔ́ftwɛ̀ər ɛ̀ksəkjúwʃən sʌtʃ æz mɛ́mərij júwsɪdʒ, CPU jùwtɪlɪzéjʃən, fʌ́ŋkʃən kɔ́l fríjkwənsij, ənd ɛ̀ksəkjúwʃən tájm. ʌ̀nlájk dijbʌ́ɡɪŋ wɪ́tʃ fówkəsɪz ɒn fájndɪŋ ənd fɪ́ksɪŋ ɛ́ərərz, prówfàjlɪŋ kɒ́nsəntrèjts ɒn ajdɛ́ntɪfàjɪŋ pərfɔ́rməns bɒ́təlnɛ̀ks ənd ríjsɔrs kənsʌ́mpʃən pǽtərnz. dəvɛ́ləpərz juwz prówfàjlɪŋ túwlz tə kəlɛ́kt mɛ́trɪks dʊ́rɪŋ prówɡræ̀m ɛ̀ksəkjúwʃən, hɛ́lpɪŋ ðɛm ʌ̀ndərstǽnd wɪ́tʃ pɑ́rts əv ðɛər kówd ɑr kənsúwmɪŋ ðə mówst ríjsɔrsɪz ɔr téjkɪŋ ðə lɔ́ŋɡəst tə ɛ́ksəkjùwt. ðɪs ɪnfərméjʃən əláwz prówɡræ̀mərz tə méjk tɑ́rɡətɪd ɒ̀ptɪmɪzéjʃənz, ɪmprúwvɪŋ æ̀plɪkéjʃən əfɪ́ʃənsij ənd rəspɒ́nsɪvnəs. prówfàjlɪŋ ɪz əsɛ́nʃəl ɪn pərfɔ́rməns-krɪ́tɪkəl æ̀plɪkéjʃənz ənd ɪz kɒ́mənlij júwzd wɛ́n fájn-túwnɪŋ ǽlɡərɪ̀ðəmz, ɒ́ptɪmàjzɪŋ déjtəbèjs kwɛ́ərijz, ɔr ɛnhǽnsɪŋ júwzər əkspɪ́ərijəns ɪn ríjsɔrs-ɪntɛ́nsɪv sɔ́ftwɛ̀ər."
    },
    {
        "Question": "What term describes the systematic process of identifying, analyzing, and resolving errors or defects in computer programs to make them work as intended?",
        "RightAnswer": "Debugging",
        "WrongAnswers": [
            "Decoding",
            "Decompiling",
            "Refactoring",
            "Error Handling",
            "Troubleshooting Networks"
        ],
        "Explanation": "Debugging is the methodical process of finding and fixing problems within computer code. When programmers write software, errors (often called 'bugs') inevitably occur. These can range from simple syntax mistakes that prevent code from running to subtle logical flaws that cause incorrect behavior. Debugging involves identifying where these issues exist, understanding why they're happening, and implementing solutions. Programmers use specialized tools called debuggers that allow them to pause program execution, inspect variable values, and trace through code line by line. Effective debugging requires analytical thinking, patience, and problem-solving skills. It's often described as detective work, where developers follow clues and test hypotheses until they discover the root cause of an issue. The term originated from a famous incident where an actual moth was found trapped in a computer relay, causing a malfunction—hence removing the insect was literally 'debugging' the system.",
        "trans_Question": "wɒt tɜ́rm dəskrájbz ðə sɪ̀stəmǽtɪk prɒ́sɛs əv ajdɛ́ntɪfàjɪŋ, ǽnəlàjzɪŋ, ənd rijzɒ́lvɪŋ ɛ́ərərz ɔr díjfɛkts ɪn kəmpjúwtər prówɡræ̀mz tə méjk ðɛm wɜ́rk æz ɪntɛ́ndɪd?",
        "trans_RightAnswer": "dijbʌ́ɡɪŋ",
        "trans_WrongAnswers": [
            "dəkówdɪŋ",
            "dìjkəmpájlɪŋ",
            "rijfǽktərɪŋ",
            "ɛ́ərər hǽndəlɪŋ",
            "trʌ́bəlʃùwtɪŋ nɛ́twɜ̀rks"
        ],
        "trans_Explanation": "dijbʌ́ɡɪŋ ɪz ðə məθɒ́dɪkəl prɒ́sɛs əv fájndɪŋ ənd fɪ́ksɪŋ prɒ́bləmz wɪðɪ́n kəmpjúwtər kówd. wɛ́n prówɡræ̀mərz rájt sɔ́ftwɛ̀ər, ɛ́ərərz (ɔ́fən kɔ́ld 'bʌ́ɡz') ɪ̀nɛ́vɪtəblij əkɜ́r. ðijz kən réjndʒ frəm sɪ́mpəl sɪ́ntæ̀ks mɪstéjks ðət prəvɛ́nt kówd frəm rʌ́nɪŋ tə sʌ́təl lɒ́dʒɪkəl flɔ́z ðət kɒ́z ɪ̀nkərɛ́kt bəhéjvjər. dijbʌ́ɡɪŋ ɪnvɒ́lvz ajdɛ́ntɪfàjɪŋ wɛ́ər ðijz ɪ́ʃuwz əɡzɪ́st, ʌ̀ndərstǽndɪŋ wáj ðɛ́ər hǽpənɪŋ, ənd ɪ́mpləmɛ̀ntɪŋ səlúwʃənz. prówɡræ̀mərz juwz spɛ́ʃəlàjzd túwlz kɔ́ld dijbʌ́ɡərz ðət əláw ðɛm tə pɔ́z prówɡræ̀m ɛ̀ksəkjúwʃən, ɪnspɛ́kt vɛ́ərijəbəl vǽljuwz, ənd tréjs θrúw kówd lájn baj lájn. əféktɪv dijbʌ́ɡɪŋ rəkwájərz æ̀nəlɪ́tɪkəl θɪ́ŋkɪŋ, péjʃəns, ənd prɒ́bləm-sɒ́lvɪŋ skɪ́lz. ɪt's ɔ́fən dəskrájbd æz dətɛ́ktɪv wɜ́rk, wɛ́ər dəvɛ́ləpərz fɒ́low klúwz ənd tɛ́st hajpɒ́θəsìjz əntɪ́l ðej dɪskʌ́vər ðə rúwt kɒ́z əv ən ɪ́ʃuw. ðə tɜ́rm ərɪ́dʒɪnèjtɪd frəm ə féjməs ɪ́nsɪdənt wɛ́ər ən ǽktʃəl mɔ́θ wɒz fáwnd trǽpt ɪn ə kəmpjúwtər ríjlaj, kɒ́zɪŋ ə mælfʌ́ŋkʃən—hɛ́ns rijmúwvɪŋ ðə ɪ́nsɛ̀kt wɒz lɪ́tərəlij 'dijbʌ́ɡɪŋ' ðə sɪ́stəm."
    },
    {
        "Question": "Which software engineering practice involves recording information about a program's execution to help with debugging, monitoring, and analysis?",
        "RightAnswer": "Logging",
        "WrongAnswers": [
            "Caching",
            "Profiling",
            "Versioning",
            "Partitioning",
            "Memory Mapping"
        ],
        "Explanation": "Logging is the systematic recording of events, activities, or observations that occur during the execution of a software application. These records, called logs, serve as a digital paper trail that developers can use to understand what happened within their application at specific points in time. Logs typically include timestamps, severity levels (such as info, warning, error), and descriptive messages about what was happening. Logging is essential for troubleshooting issues, monitoring application health, analyzing user behavior, and ensuring security compliance. When something goes wrong, developers often say 'check the logs' because these records can reveal what actions led to a failure and under what conditions. Modern logging systems can collect, aggregate, and visualize log data across distributed systems, making it easier to gain insights from potentially millions of log entries. Effective logging strikes a balance between capturing enough information to be useful without degrading application performance or creating excessive data storage needs.",
        "trans_Question": "wɪ́tʃ sɔ́ftwɛ̀ər ɛ̀ndʒɪnɪ́ərɪŋ prǽktɪs ɪnvɒ́lvz rəkɔ́rdɪŋ ɪnfərméjʃən əbawt ə prówɡræ̀m'z ɛ̀ksəkjúwʃən tə hɛ́lp wɪð dijbʌ́ɡɪŋ, mɒ́nɪtərɪŋ, ənd ənǽlɪsɪs?",
        "trans_RightAnswer": "lɔ́ɡɪŋ",
        "trans_WrongAnswers": [
            "kǽʃɪŋ",
            "prówfàjlɪŋ",
            "vɜ́rʒənɪŋ",
            "pɑrtɪ́ʃənɪŋ",
            "mɛ́mərij mǽpɪŋ"
        ],
        "trans_Explanation": "lɔ́ɡɪŋ ɪz ðə sɪ̀stəmǽtɪk rəkɔ́rdɪŋ əv əvɛ́nts, æktɪ́vɪtijz, ɔr ɒ̀bzərvéjʃənz ðət əkɜ́r dʊ́rɪŋ ðə ɛ̀ksəkjúwʃən əv ə sɔ́ftwɛ̀ər æ̀plɪkéjʃən. ðijz rɛ́kərdz, kɔ́ld lɔ́ɡz, sɜ́rv æz ə dɪ́dʒɪtəl péjpər tréjl ðət dəvɛ́ləpərz kən juwz tə ʌ̀ndərstǽnd wɒt hǽpənd wɪðɪ́n ðɛər æ̀plɪkéjʃən æt spəsɪ́fɪk pɔ́jnts ɪn tájm. lɔ́ɡz tɪ́pɪkəlij ɪnklúwd tájmstæ̀mps, səvɛ́ərɪtij lɛ́vəlz (sʌtʃ æz ɪ́nfow, wɔ́rnɪŋ, ɛ́ərər), ənd dəskrɪ́ptɪv mɛ́sɪdʒɪz əbawt wɒt wɒz hǽpənɪŋ. lɔ́ɡɪŋ ɪz əsɛ́nʃəl fɔr trʌ́bəlʃùwtɪŋ ɪ́ʃuwz, mɒ́nɪtərɪŋ æ̀plɪkéjʃən hɛ́lθ, ǽnəlàjzɪŋ júwzər bəhéjvjər, ənd ɛnʃʊ́rɪŋ səkjʊ́rɪtij kəmplájəns. wɛ́n sʌ́mθɪŋ ɡówz rɔ́ŋ, dəvɛ́ləpərz ɔ́fən séj 'tʃɛ́k ðə lɔ́ɡz' bəkɒ́z ðijz rɛ́kərdz kən rəvíjl wɒt ǽkʃənz lɛ́d tə ə féjljər ənd ʌ́ndər wɒt kəndɪ́ʃənz. mɒ́dərn lɔ́ɡɪŋ sɪ́stəmz kən kəlɛ́kt, ǽɡrəɡejt, ənd vɪ́ʒwəlàjz lɔ́ɡ déjtə əkrɔ́s dɪstrɪ́bjətɪd sɪ́stəmz, méjkɪŋ ɪt íjzijər tə ɡéjn ɪ́nsàjts frəm pətɛ́nʃəlij mɪ́ljənz əv lɔ́ɡ ɛ́ntrijz. əféktɪv lɔ́ɡɪŋ strájks ə bǽləns bijtwíjn kǽptʃərɪŋ ənʌ́f ɪnfərméjʃən tə bij júwsfəl wɪðáwt dəɡréjdɪŋ æ̀plɪkéjʃən pərfɔ́rməns ɔr krijéjtɪŋ əksɛ́sɪv déjtə stɔ́rɪdʒ níjdz."
    },
    {
        "Question": "In programming, what term describes the mechanism that allows a program to detect, report, and recover from errors during execution without crashing?",
        "RightAnswer": "Exception Handling",
        "WrongAnswers": [
            "Error Masking",
            "Fault Tolerance Engineering",
            "Runtime Recovery",
            "Graceful Degradation",
            "Bug Trapping"
        ],
        "Explanation": "Exception Handling is a fundamental concept in computer programming that provides a structured way to detect and respond to unexpected conditions or errors during program execution. Rather than allowing a program to crash when it encounters an error, exception handling creates a safety net that catches these problems, called exceptions, and allows the programmer to define specific responses to different types of errors. The process typically involves three key components: try blocks that contain code that might cause an error, catch blocks that specify what to do when particular exceptions occur, and finally blocks that execute cleanup code regardless of whether an exception was thrown. This approach helps create more robust software by separating error-handling logic from normal program flow, making code more readable and maintainable while improving the user experience by preventing abrupt program terminations.",
        "trans_Question": "ɪn prówɡræ̀mɪŋ, wɒt tɜ́rm dəskrájbz ðə mɛ́kənɪzəm ðət əláwz ə prówɡræ̀m tə dətɛ́kt, rijpɔ́rt, ənd rəkʌ́vər frəm ɛ́ərərz dʊ́rɪŋ ɛ̀ksəkjúwʃən wɪðáwt krǽʃɪŋ?",
        "trans_RightAnswer": "əksɛ́pʃən hǽndəlɪŋ",
        "trans_WrongAnswers": [
            "ɛ́ərər mǽskɪŋ",
            "fɔ́lt tɒ́lərəns ɛ̀ndʒɪnɪ́ərɪŋ",
            "rʌ́ntàjm rəkʌ́vərij",
            "ɡréjsfəl dɛ̀ɡrədéjʃən",
            "bʌ́ɡ trǽpɪŋ"
        ],
        "trans_Explanation": "əksɛ́pʃən hǽndəlɪŋ ɪz ə fʌ̀ndəmɛ́ntəl kɒ́nsɛpt ɪn kəmpjúwtər prówɡræ̀mɪŋ ðət prəvájdz ə strʌ́ktʃərd wej tə dətɛ́kt ənd rəspɒ́nd tə ʌ̀nəkspɛ́ktɪd kəndɪ́ʃənz ɔr ɛ́ərərz dʊ́rɪŋ prówɡræ̀m ɛ̀ksəkjúwʃən. rǽðər ðʌn əláwɪŋ ə prówɡræ̀m tə krǽʃ wɛ́n ɪt ənkáwntərz ən ɛ́ərər, əksɛ́pʃən hǽndəlɪŋ krijéjts ə séjftij nɛ́t ðət kǽtʃɪz ðijz prɒ́bləmz, kɔ́ld əksɛ́pʃənz, ənd əláwz ðə prówɡræ̀mər tə dəfájn spəsɪ́fɪk rəspɒ́nsɪz tə dɪ́fərənt tájps əv ɛ́ərərz. ðə prɒ́sɛs tɪ́pɪkəlij ɪnvɒ́lvz θríj kíj kəmpównənts: tráj blɒ́ks ðət kəntéjn kówd ðət majt kɒ́z ən ɛ́ərər, kǽtʃ blɒ́ks ðət spɛ́sɪfàj wɒt tə dúw wɛ́n pərtɪ́kjələr əksɛ́pʃənz əkɜ́r, ənd fájnəlij blɒ́ks ðət ɛ́ksəkjùwt klíjnʌ̀p kówd rəɡɑ́rdləs əv wɛ́ðər ən əksɛ́pʃən wɒz θrówn. ðɪs əprówtʃ hɛ́lps krijéjt mɔr rowbʌ́st sɔ́ftwɛ̀ər baj sɛ́pərèjtɪŋ ɛ́ərər-hǽndəlɪŋ lɒ́dʒɪk frəm nɔ́rməl prówɡræ̀m flów, méjkɪŋ kówd mɔr ríjdəbəl ənd mejntéjnəbəl wájl ɪmprúwvɪŋ ðə júwzər əkspɪ́ərijəns baj prəvɛ́ntɪŋ əbrʌ́pt prówɡræ̀m tɜ̀rmɪnéjʃənz."
    },
    {
        "Question": "Which concept in computer science involves hiding complex implementation details and exposing only the essential interface to users, allowing programmers to work with high-level representations rather than low-level details?",
        "RightAnswer": "Data Abstraction",
        "WrongAnswers": [
            "Data Encapsulation",
            "Data Polymorphism",
            "Data Normalization",
            "Function Overloading",
            "Data Serialization"
        ],
        "Explanation": "Data Abstraction is a fundamental concept in computer science that involves representing complex data in a simplified manner by hiding the implementation details and exposing only the essential features or behaviors. This creates a separation between what data is and how it is implemented or stored. For example, when you use a List in programming, you can add items, remove items, or check the size without needing to understand how these operations are implemented internally. The power of data abstraction lies in its ability to manage complexity by allowing programmers to focus on the high-level functionality rather than low-level implementation details. This concept is central to object-oriented programming and abstract data types, promoting code reusability, maintainability, and flexibility. Data abstraction essentially provides a 'what' versus 'how' separation: users of the abstraction need only understand what it does, not how it accomplishes its task.",
        "trans_Question": "wɪ́tʃ kɒ́nsɛpt ɪn kəmpjúwtər sájəns ɪnvɒ́lvz hájdɪŋ kɒ́mplɛks ɪ̀mpləmɛntéjʃən díjtejlz ənd əkspówzɪŋ ównlij ðə əsɛ́nʃəl ɪ́ntərfèjs tə júwzərz, əláwɪŋ prówɡræ̀mərz tə wɜ́rk wɪð háj-lɛ́vəl rɛ̀prəzəntéjʃənz rǽðər ðʌn lów-lɛ́vəl díjtejlz?",
        "trans_RightAnswer": "déjtə æbstrǽkʃən",
        "trans_WrongAnswers": [
            "déjtə ɛnkǽpsəlèjʃən",
            "déjtə pɒ̀lijmɔ́rfɪzm",
            "déjtə nɔ̀rməlɪzéjʃən",
            "fʌ́ŋkʃən ówvərlòwdɪŋ",
            "déjtə sɪ̀ərìjəlɪzéjʃən"
        ],
        "trans_Explanation": "déjtə æbstrǽkʃən ɪz ə fʌ̀ndəmɛ́ntəl kɒ́nsɛpt ɪn kəmpjúwtər sájəns ðət ɪnvɒ́lvz rɛ̀prəzɛ́ntɪŋ kɒ́mplɛks déjtə ɪn ə sɪ́mpləfajd mǽnər baj hájdɪŋ ðə ɪ̀mpləmɛntéjʃən díjtejlz ənd əkspówzɪŋ ównlij ðə əsɛ́nʃəl fíjtʃərz ɔr bəhéjvjərz. ðɪs krijéjts ə sɛ̀pərèjʃən bijtwíjn wɒt déjtə ɪz ənd háw ɪt ɪz ɪ́mpləmɛ̀ntɪd ɔr stɔ́rd. fɔr əɡzǽmpəl, wɛ́n juw juwz ə lɪ́st ɪn prówɡræ̀mɪŋ, juw kən ǽd ájtəmz, rijmúwv ájtəmz, ɔr tʃɛ́k ðə sájz wɪðáwt níjdɪŋ tə ʌ̀ndərstǽnd háw ðijz ɒ̀pəréjʃənz ɑr ɪ́mpləmɛ̀ntɪd ɪ̀ntɜ́rnəlij. ðə páwər əv déjtə æbstrǽkʃən lájz ɪn ɪts əbɪ́lɪtij tə mǽnɪdʒ kəmplɛ́ksɪtij baj əláwɪŋ prówɡræ̀mərz tə fówkəs ɒn ðə háj-lɛ́vəl fʌ̀ŋkʃənǽlɪtij rǽðər ðʌn lów-lɛ́vəl ɪ̀mpləmɛntéjʃən díjtejlz. ðɪs kɒ́nsɛpt ɪz sɛ́ntrəl tə ɒ́bdʒəkt-ɔ́rijɛ̀ntɪd prówɡræ̀mɪŋ ənd ǽbstræ̀kt déjtə tájps, prəmówtɪŋ kówd rìjùwzəbɪ́lɪtij, mejntéjnəbɪ́lɪtij, ənd flɛ̀ksɪbɪ́lɪtij. déjtə æbstrǽkʃən əsɛ́nʃəlij prəvájdz ə 'wɒt' vɜ́rsəs 'háw' sɛ̀pərèjʃən: júwzərz əv ðə æbstrǽkʃən níjd ównlij ʌ̀ndərstǽnd wɒt ɪt dʌz, nɒt háw ɪt əkɒ́mplɪʃɪz ɪts tǽsk."
    },
    {
        "Question": "What term describes established guidelines and concepts that software developers follow to create maintainable, flexible, and efficient systems, such as SOLID, DRY, and separation of concerns?",
        "RightAnswer": "Design Principle",
        "WrongAnswers": [
            "Implementation Pattern",
            "Coding Convention",
            "Architecture Framework",
            "Development Methodology",
            "Programming Paradigm"
        ],
        "Explanation": "A Design Principle in computer science refers to a fundamental guideline or rule that helps developers create better software systems. Unlike rigid rules, design principles offer proven approaches to solving common problems in software architecture and coding. They guide decisions about how components should interact, responsibilities should be assigned, and code should be structured. Famous examples include SOLID (Single Responsibility, Open-Closed, Liskov Substitution, Interface Segregation, and Dependency Inversion), DRY (Don't Repeat Yourself), and separation of concerns. These principles aim to make software more maintainable, extensible, testable, and understandable. Rather than focusing on specific implementations, design principles provide conceptual frameworks that apply across different programming languages and technologies. They represent decades of collective wisdom from the software engineering community about what makes code robust and sustainable over time.",
        "trans_Question": "wɒt tɜ́rm dəskrájbz əstǽblɪʃt ɡájdlàjnz ənd kɒ́nsɛpts ðət sɔ́ftwɛ̀ər dəvɛ́ləpərz fɒ́low tə krijéjt mejntéjnəbəl, flɛ́ksɪbəl, ənd əfɪ́ʃənt sɪ́stəmz, sʌtʃ æz SOLID, DRY, ənd sɛ̀pərèjʃən əv kənsɜ́rnz?",
        "trans_RightAnswer": "dəzájn prɪ́nsɪpəl",
        "trans_WrongAnswers": [
            "ɪ̀mpləmɛntéjʃən pǽtərn",
            "kówdɪŋ kənvɛ́nʃən",
            "ɑ́rkɪtɛ̀ktʃər fréjmwɜ̀rk",
            "dəvɛ́ləpmənt mɛ̀θədɒ́lədʒij",
            "prówɡræ̀mɪŋ pǽrədàjm"
        ],
        "trans_Explanation": "ə dəzájn prɪ́nsɪpəl ɪn kəmpjúwtər sájəns rəfɜ́rz tə ə fʌ̀ndəmɛ́ntəl ɡájdlàjn ɔr rúwl ðət hɛ́lps dəvɛ́ləpərz krijéjt bɛ́tər sɔ́ftwɛ̀ər sɪ́stəmz. ʌ̀nlájk rɪ́dʒɪd rúwlz, dəzájn prɪ́nsɪpəlz ɔ́fər prúwvən əprówtʃɪz tə sɒ́lvɪŋ kɒ́mən prɒ́bləmz ɪn sɔ́ftwɛ̀ər ɑ́rkɪtɛ̀ktʃər ənd kówdɪŋ. ðej ɡájd dəsɪ́ʒənz əbawt háw kəmpównənts ʃʊd ɪ̀ntərǽkt, rəspɒ̀nsɪbɪ́lɪtijz ʃʊd bij əsájnd, ənd kówd ʃʊd bij strʌ́ktʃərd. féjməs əɡzǽmpəlz ɪnklúwd SOLID (sɪ́ŋɡəl rəspɒ̀nsɪbɪ́lɪtij, ówpən-klówzd, lɪ́skɔv sʌ̀bstɪtjúwʃən, ɪ́ntərfèjs sɛ̀ɡrəɡéjʃən, ənd dəpɛ́ndənsij ɪnvɜ́rʒən), DRY (dównt rəpíjt jɔrsɛ́lf), ənd sɛ̀pərèjʃən əv kənsɜ́rnz. ðijz prɪ́nsɪpəlz éjm tə méjk sɔ́ftwɛ̀ər mɔr mejntéjnəbəl, ɛ̀kstɛ́ndɪbəl, tɛ́stəbəl, ənd ʌ̀ndərstǽndəbəl. rǽðər ðʌn fówkəsɪŋ ɒn spəsɪ́fɪk ɪ̀mpləmɛntéjʃənz, dəzájn prɪ́nsɪpəlz prəvájd kənsɛ́ptʃuwəl fréjmwɜ̀rks ðət əpláj əkrɔ́s dɪ́fərənt prówɡræ̀mɪŋ lǽŋɡwədʒɪz ənd tɛknɒ́lədʒijz. ðej rɛ̀prəzɛ́nt dɛ́kejdz əv kəlɛ́ktɪv wɪ́zdəm frəm ðə sɔ́ftwɛ̀ər ɛ̀ndʒɪnɪ́ərɪŋ kəmjúwnɪtij əbawt wɒt méjks kówd rowbʌ́st ənd səstéjnəbəl ówvər tájm."
    },
    {
        "Question": "What design principles were introduced by Robert C. Martin to create more maintainable, understandable, and flexible software in object-oriented programming?",
        "RightAnswer": "SOLID Principles",
        "WrongAnswers": [
            "ACID Properties",
            "Design Patterns Framework",
            "GRASP Guidelines",
            "Clean Code Directives",
            "Agile Development Tenets"
        ],
        "Explanation": "SOLID Principles represent five fundamental design principles in object-oriented programming introduced by Robert C. Martin. The acronym stands for Single Responsibility Principle (a class should have only one reason to change), Open-Closed Principle (software entities should be open for extension but closed for modification), Liskov Substitution Principle (objects of a superclass should be replaceable with objects of subclasses without affecting program correctness), Interface Segregation Principle (many client-specific interfaces are better than one general-purpose interface), and Dependency Inversion Principle (depend on abstractions, not concretions). These principles help developers create code that is easier to maintain, understand, and extend over time. By following SOLID principles, software becomes more modular, less coupled, and more resistant to bugs when changes are made, ultimately leading to higher quality software systems that can evolve with changing requirements.",
        "trans_Question": "wɒt dəzájn prɪ́nsɪpəlz wɜ́r ɪntrədúwst baj rówbərt C. mɑ́rtɪn tə krijéjt mɔr mejntéjnəbəl, ʌ̀ndərstǽndəbəl, ənd flɛ́ksɪbəl sɔ́ftwɛ̀ər ɪn ɒ́bdʒəkt-ɔ́rijɛ̀ntɪd prówɡræ̀mɪŋ?",
        "trans_RightAnswer": "SOLID prɪ́nsɪpəlz",
        "trans_WrongAnswers": [
            "ACID prɒ́pərtijz",
            "dəzájn pǽtərnz fréjmwɜ̀rk",
            "GRASP ɡájdlàjnz",
            "klíjn kówd dɪərɛ́ktɪvz",
            "ǽdʒəl dəvɛ́ləpmənt tɛ́nəts"
        ],
        "trans_Explanation": "SOLID prɪ́nsɪpəlz rɛ̀prəzɛ́nt fájv fʌ̀ndəmɛ́ntəl dəzájn prɪ́nsɪpəlz ɪn ɒ́bdʒəkt-ɔ́rijɛ̀ntɪd prówɡræ̀mɪŋ ɪntrədúwst baj rówbərt C. mɑ́rtɪn. ðə ǽkrənɪm stǽndz fɔr sɪ́ŋɡəl rəspɒ̀nsɪbɪ́lɪtij prɪ́nsɪpəl (ə klǽs ʃʊd həv ównlij wʌ́n ríjzən tə tʃéjndʒ), ówpən-klówzd prɪ́nsɪpəl (sɔ́ftwɛ̀ər ɛ́ntɪtijz ʃʊd bij ówpən fɔr əkstɛ́nʃən bʌt klówzd fɔr mɒ̀dɪfɪkéjʃən), lɪ́skɔv sʌ̀bstɪtjúwʃən prɪ́nsɪpəl (ɒ́bdʒɛkts əv ə súwpərklæ̀s ʃʊd bij rìjpléjsəbəl wɪð ɒ́bdʒɛkts əv sʌ́bklæ̀sɪz wɪðáwt əfɛ́ktɪŋ prówɡræ̀m kərɛ́ktnəs), ɪ́ntərfèjs sɛ̀ɡrəɡéjʃən prɪ́nsɪpəl (mɛ́nij klájənt-spəsɪ́fɪk ɪ́ntərfèjsɪz ɑr bɛ́tər ðʌn wʌ́n dʒɛ́nərəl-pɜ́rpəs ɪ́ntərfèjs), ənd dəpɛ́ndənsij ɪnvɜ́rʒən prɪ́nsɪpəl (dəpɛ́nd ɒn æbstrǽkʃənz, nɒt kənkríjʃənz). ðijz prɪ́nsɪpəlz hɛ́lp dəvɛ́ləpərz krijéjt kówd ðət ɪz íjzijər tə mejntéjn, ʌ̀ndərstǽnd, ənd əkstɛ́nd ówvər tájm. baj fɒ́lowɪŋ SOLID prɪ́nsɪpəlz, sɔ́ftwɛ̀ər bəkʌ́mz mɔr mɒ́dʒələr, lɛ́s kʌ́pəld, ənd mɔr rəzɪ́stənt tə bʌ́ɡz wɛ́n tʃéjndʒɪz ɑr méjd, ʌ́ltɪmətlij líjdɪŋ tə hájər kwɑ́lɪtij sɔ́ftwɛ̀ər sɪ́stəmz ðət kən əvɒ́lv wɪð tʃéjndʒɪŋ rəkwájərmənts."
    },
    {
        "Question": "Which principle in software engineering encourages developers to avoid duplicating code by abstracting common functionality?",
        "RightAnswer": "DRY (Don't Repeat Yourself)",
        "WrongAnswers": [
            "KISS (Keep It Simple, Stupid)",
            "YAGNI (You Aren't Gonna Need It)",
            "SOLID (Single Responsibility Principle)",
            "WET (Write Everything Twice)",
            "FIFO (First In, First Out)"
        ],
        "Explanation": "DRY, which stands for 'Don't Repeat Yourself,' is a fundamental principle in software development that advocates reducing repetition in code. The core idea is that every piece of knowledge or logic should have a single, unambiguous representation within a system. When developers follow the DRY principle, they extract common functionality into reusable components, functions, or classes, rather than copying and pasting the same code in multiple places. This approach not only makes code more maintainable (as changes only need to be made in one place), but also reduces the risk of inconsistencies and bugs that can emerge when duplicate code evolves differently over time. The principle was popularized in the book 'The Pragmatic Programmer' and has become a cornerstone of good software design, encouraging modularity, abstraction, and efficient code organization.",
        "trans_Question": "wɪ́tʃ prɪ́nsɪpəl ɪn sɔ́ftwɛ̀ər ɛ̀ndʒɪnɪ́ərɪŋ ənkɜ́rɪdʒɪz dəvɛ́ləpərz tə əvɔ́jd dúwplɪkèjtɪŋ kówd baj ǽbstræktɪŋ kɒ́mən fʌ̀ŋkʃənǽlɪtij?",
        "trans_RightAnswer": "DRY (dównt rəpíjt jɔrsɛ́lf)",
        "trans_WrongAnswers": [
            "KISS (kíjp ɪt sɪ́mpəl, stúwpɪd)",
            "YAGNI (juw ɑrənt ɡɒ́nə níjd ɪt)",
            "SOLID (sɪ́ŋɡəl rəspɒ̀nsɪbɪ́lɪtij prɪ́nsɪpəl)",
            "WET (rájt ɛ́vrijθɪ̀ŋ twájs)",
            "FIFO (fɜ́rst ɪn, fɜ́rst awt)"
        ],
        "trans_Explanation": "DRY, wɪ́tʃ stǽndz fɔr 'dównt rəpíjt jɔrsɛ́lf,' ɪz ə fʌ̀ndəmɛ́ntəl prɪ́nsɪpəl ɪn sɔ́ftwɛ̀ər dəvɛ́ləpmənt ðət ǽdvəkejts rədjúwsɪŋ rɛ̀pətɪ́ʃən ɪn kówd. ðə kɔ́r ajdíjə ɪz ðət ɛvərij píjs əv nɒ́lɪdʒ ɔr lɒ́dʒɪk ʃʊd həv ə sɪ́ŋɡəl, ʌ̀næmbɪ́ɡjəwəs rɛ̀prəzɛntéjʃən wɪðɪ́n ə sɪ́stəm. wɛ́n dəvɛ́ləpərz fɒ́low ðə DRY prɪ́nsɪpəl, ðej ɛ́kstrəkt kɒ́mən fʌ̀ŋkʃənǽlɪtij ɪntə rijúwzəbəl kəmpównənts, fʌ́ŋkʃənz, ɔr klǽsɪz, rǽðər ðʌn kɒ́pijɪŋ ənd péjstɪŋ ðə séjm kówd ɪn mʌ́ltɪpəl pléjsɪz. ðɪs əprówtʃ nɒt ównlij méjks kówd mɔr mejntéjnəbəl (æz tʃéjndʒɪz ównlij níjd tə bij méjd ɪn wʌ́n pléjs), bʌt ɔ́lsow rədjúwsɪz ðə rɪ́sk əv ɪ̀ŋkɒ́nsɪstɛ̀nsijz ənd bʌ́ɡz ðət kən əmɜ́rdʒ wɛ́n dúwplɪkèjt kówd əvɒ́lvz dɪ́fərɛ́ntlij ówvər tájm. ðə prɪ́nsɪpəl wɒz pɒ́pjələràjzd ɪn ðə bʊ́k 'ðə præɡmǽtɪk prówɡræ̀mər' ənd həz bəkʌ́m ə kɔ́rnərstòwn əv ɡʊ́d sɔ́ftwɛ̀ər dəzájn, ənkɜ́rɪdʒɪŋ mɒ́djəlǽrɪtij, æbstrǽkʃən, ənd əfɪ́ʃənt kówd ɔ̀rɡənɪzéjʃən."
    },
    {
        "Question": "Which design principle advocates for simplicity and straightforwardness when creating software systems to improve maintainability and reduce errors?",
        "RightAnswer": "KISS (Keep It Simple, Stupid)",
        "WrongAnswers": [
            "DRY (Don't Repeat Yourself)",
            "YAGNI (You Aren't Gonna Need It)",
            "SOLID (Single responsibility, Open-closed, Liskov substitution, Interface segregation, Dependency inversion)",
            "MVP (Minimum Viable Product)",
            "RAD (Rapid Application Development)"
        ],
        "Explanation": "KISS, which stands for 'Keep It Simple, Stupid,' is a fundamental design principle in computer science that emphasizes simplicity as a key goal in software development. It suggests that systems work best when they are kept simple rather than made complex. The principle encourages developers to avoid unnecessary complexity, to write clear and straightforward code, and to solve problems in the most uncomplicated way possible. KISS recognizes that simplicity leads to more maintainable code, fewer bugs, and easier collaboration among team members. This principle is often considered when making architectural decisions, designing algorithms, or writing functions. While many developers might be tempted to create elaborate solutions to showcase their technical prowess, KISS reminds us that the most elegant solution is often the simplest one that accomplishes the task effectively.",
        "trans_Question": "wɪ́tʃ dəzájn prɪ́nsɪpəl ǽdvəkejts fɔr sɪmplɪ́sɪtij ənd strèjtfɔ́rwərdnəs wɛ́n krijéjtɪŋ sɔ́ftwɛ̀ər sɪ́stəmz tə ɪmprúwv mejntéjnəbɪ́lɪtij ənd rədjúws ɛ́ərərz?",
        "trans_RightAnswer": "KISS (kíjp ɪt sɪ́mpəl, stúwpɪd)",
        "trans_WrongAnswers": [
            "DRY (dównt rəpíjt jɔrsɛ́lf)",
            "YAGNI (juw ɑrənt ɡɒ́nə níjd ɪt)",
            "SOLID (sɪ́ŋɡəl rəspɒ̀nsɪbɪ́lɪtij, ówpən-klówzd, lɪ́skɔv sʌ̀bstɪtjúwʃən, ɪ́ntərfèjs sɛ̀ɡrəɡéjʃən, dəpɛ́ndənsij ɪnvɜ́rʒən)",
            "MVP (mɪ́nɪməm vájəbəl prɒ́dəkt)",
            "RAD (rǽpɪd æ̀plɪkéjʃən dəvɛ́ləpmənt)"
        ],
        "trans_Explanation": "KISS, wɪ́tʃ stǽndz fɔr 'kíjp ɪt sɪ́mpəl, stúwpɪd,' ɪz ə fʌ̀ndəmɛ́ntəl dəzájn prɪ́nsɪpəl ɪn kəmpjúwtər sájəns ðət ɛ́mfəsajzɪz sɪmplɪ́sɪtij æz ə kíj ɡówl ɪn sɔ́ftwɛ̀ər dəvɛ́ləpmənt. ɪt sədʒɛ́sts ðət sɪ́stəmz wɜ́rk bɛ́st wɛ́n ðej ɑr kɛ́pt sɪ́mpəl rǽðər ðʌn méjd kɒ́mplɛks. ðə prɪ́nsɪpəl ənkɜ́rɪdʒɪz dəvɛ́ləpərz tə əvɔ́jd ʌ̀nnɛ́səsɛ̀ərij kəmplɛ́ksɪtij, tə rájt klɪ́ər ənd stréjtfɔ́rwərd kówd, ənd tə sɒ́lv prɒ́bləmz ɪn ðə mówst ʌ̀nkɒ́mplɪkèjtɪd wej pɒ́sɪbəl. KISS rɛ́kəɡnàjzɪz ðət sɪmplɪ́sɪtij líjdz tə mɔr mejntéjnəbəl kówd, fjúwər bʌ́ɡz, ənd íjzijər kəlæ̀bəréjʃən əmʌ́ŋ tíjm mɛ́mbərz. ðɪs prɪ́nsɪpəl ɪz ɔ́fən kənsɪ́dərd wɛ́n méjkɪŋ ɑ̀rkɪtɛ́ktʃərəl dəsɪ́ʒənz, dəzájnɪŋ ǽlɡərɪ̀ðəmz, ɔr rájtɪŋ fʌ́ŋkʃənz. wájl mɛ́nij dəvɛ́ləpərz majt bij tɛ́mptɪd tə krijéjt əlǽbərət səlúwʃənz tə ʃówkèjs ðɛər tɛ́knɪkəl práwəs, KISS rijmájndz US ðət ðə mówst ɛ́ləɡənt səlúwʃən ɪz ɔ́fən ðə sɪ́mpləst wʌ́n ðət əkɒ́mplɪʃɪz ðə tǽsk əfɛ́ktɪvlij."
    },
    {
        "Question": "Which software development principle advises against implementing features that might be needed in the future but aren't currently required?",
        "RightAnswer": "YAGNI (You Aren't Gonna Need It)",
        "WrongAnswers": [
            "DRY (Don't Repeat Yourself)",
            "KISS (Keep It Simple, Stupid)",
            "FIFO (First In, First Out)",
            "SOLID (Single Responsibility, Open-closed, Liskov substitution, Interface segregation, Dependency inversion)",
            "GRASP (General Responsibility Assignment Software Patterns)"
        ],
        "Explanation": "YAGNI, which stands for 'You Aren't Gonna Need It', is a principle in software development that cautions against adding functionality until it is necessary. This principle emerged from Extreme Programming practices and suggests that developers should focus only on implementing current requirements rather than trying to anticipate future needs. By adhering to YAGNI, developers avoid spending time on features that may never be used, reduce code complexity, prevent feature creep, and minimize maintenance overhead. This approach helps maintain simpler, more focused codebases and often results in more efficient development processes. YAGNI complements other principles like Minimum Viable Product (MVP) by encouraging teams to build only what is immediately necessary and then iterate based on actual user feedback.",
        "trans_Question": "wɪ́tʃ sɔ́ftwɛ̀ər dəvɛ́ləpmənt prɪ́nsɪpəl ædvájzɪz əɡéjnst ɪ́mpləmɛ̀ntɪŋ fíjtʃərz ðət majt bij níjdɪd ɪn ðə fjúwtʃər bʌt ɑrənt kɜ́rəntlij rəkwájərd?",
        "trans_RightAnswer": "YAGNI (juw ɑrənt ɡɒ́nə níjd ɪt)",
        "trans_WrongAnswers": [
            "DRY (dównt rəpíjt jɔrsɛ́lf)",
            "KISS (kíjp ɪt sɪ́mpəl, stúwpɪd)",
            "FIFO (fɜ́rst ɪn, fɜ́rst awt)",
            "SOLID (sɪ́ŋɡəl rəspɒ̀nsɪbɪ́lɪtij, ówpən-klówzd, lɪ́skɔv sʌ̀bstɪtjúwʃən, ɪ́ntərfèjs sɛ̀ɡrəɡéjʃən, dəpɛ́ndənsij ɪnvɜ́rʒən)",
            "GRASP (dʒɛ́nərəl rəspɒ̀nsɪbɪ́lɪtij əsájnmənt sɔ́ftwɛ̀ər pǽtərnz)"
        ],
        "trans_Explanation": "YAGNI, wɪ́tʃ stǽndz fɔr 'juw ɑrənt ɡɒ́nə níjd ɪt', ɪz ə prɪ́nsɪpəl ɪn sɔ́ftwɛ̀ər dəvɛ́ləpmənt ðət kɔ́ʃənz əɡéjnst ǽdɪŋ fʌ̀ŋkʃənǽlɪtij əntɪ́l ɪt ɪz nɛ́səsɛ̀ərij. ðɪs prɪ́nsɪpəl əmɜ́rdʒd frəm əkstríjm prówɡræ̀mɪŋ prǽktɪsɪz ənd sədʒɛ́sts ðət dəvɛ́ləpərz ʃʊd fówkəs ównlij ɒn ɪ́mpləmɛ̀ntɪŋ kɑ́rənt rəkwájərmənts rǽðər ðʌn trájɪŋ tə æntɪ́sɪpèjt fjúwtʃər níjdz. baj ədhɪ́ərɪŋ tə YAGNI, dəvɛ́ləpərz əvɔ́jd spɛ́ndɪŋ tájm ɒn fíjtʃərz ðət mej nɛ́vər bij júwzd, rədjúws kówd kəmplɛ́ksɪtij, prəvɛ́nt fíjtʃər kríjp, ənd mɪ́nɪmàjz méjntənəns ówvərhɛ́d. ðɪs əprówtʃ hɛ́lps mejntéjn sɪ́mplər, mɔr fówkəst kówdbèjsɪz ənd ɔ́fən rəzʌ́lts ɪn mɔr əfɪ́ʃənt dəvɛ́ləpmənt prɒ́sɛsɪz. YAGNI kɒ́mpləmənts ʌ́ðər prɪ́nsɪpəlz lájk mɪ́nɪməm vájəbəl prɒ́dəkt (MVP) baj ənkɜ́rɪdʒɪŋ tíjmz tə bɪ́ld ównlij wɒt ɪz ɪmíjdijətlij nɛ́səsɛ̀ərij ənd ðɛn ɪ́tərejt béjst ɒn ǽktʃəl júwzər fíjdbæ̀k."
    },
    {
        "Question": "What is the term for the process of restructuring existing computer code without changing its external behavior, with the goal of improving internal code quality and maintainability?",
        "RightAnswer": "Code Refactoring",
        "WrongAnswers": [
            "Feature Implementation",
            "Bug Patching",
            "Code Optimization",
            "Syntax Highlighting",
            "Version Migration"
        ],
        "Explanation": "Code Refactoring is a disciplined technique in software development where developers improve the internal structure of existing source code without altering its external behavior. Think of it as renovating a house without changing its facade. The primary goals of refactoring include improving code readability, reducing complexity, enhancing maintainability, and making the code more extensible for future changes. Common refactoring techniques include extracting duplicate code into reusable methods, renaming variables for clarity, simplifying conditional expressions, and reorganizing class hierarchies. Refactoring is often performed as part of regular development cycles or before adding new features to ensure the codebase remains healthy and manageable over time. While it may not introduce new features or fix bugs directly, it creates a more robust foundation that makes these tasks easier in the future.",
        "trans_Question": "wɒt ɪz ðə tɜ́rm fɔr ðə prɒ́sɛs əv rijstrʌ́ktʃərɪŋ əɡzɪ́stɪŋ kəmpjúwtər kówd wɪðáwt tʃéjndʒɪŋ ɪts əkstɜ́rnəl bəhéjvjər, wɪð ðə ɡówl əv ɪmprúwvɪŋ ɪ̀ntɜ́rnəl kówd kwɑ́lɪtij ənd mejntéjnəbɪ́lɪtij?",
        "trans_RightAnswer": "kówd rijfǽktərɪŋ",
        "trans_WrongAnswers": [
            "fíjtʃər ɪ̀mpləmɛntéjʃən",
            "bʌ́ɡ pǽtʃɪŋ",
            "kówd ɒptɪmɪzéjʃən",
            "sɪ́ntæ̀ks hájlàjtɪŋ",
            "vɜ́rʒən majɡréjʃən"
        ],
        "trans_Explanation": "kówd rijfǽktərɪŋ ɪz ə dɪ́sɪplɪnd tɛkníjk ɪn sɔ́ftwɛ̀ər dəvɛ́ləpmənt wɛ́ər dəvɛ́ləpərz ɪmprúwv ðə ɪ̀ntɜ́rnəl strʌ́ktʃər əv əɡzɪ́stɪŋ sɔ́rs kówd wɪðáwt ɔ́ltərɪŋ ɪts əkstɜ́rnəl bəhéjvjər. θɪ́ŋk əv ɪt æz rɛ́nəvèjtɪŋ ə haws wɪðáwt tʃéjndʒɪŋ ɪts fəsɒ́d. ðə prájmɛ̀ərij ɡówlz əv rijfǽktərɪŋ ɪnklúwd ɪmprúwvɪŋ kówd rìjdəbɪ́lɪtij, rədjúwsɪŋ kəmplɛ́ksɪtij, ɛnhǽnsɪŋ mejntéjnəbɪ́lɪtij, ənd méjkɪŋ ðə kówd mɔr ɛ̀kstɛ́ndɪbəl fɔr fjúwtʃər tʃéjndʒɪz. kɒ́mən rijfǽktərɪŋ tɛkníjks ɪnklúwd əkstrǽktɪŋ dúwplɪkèjt kówd ɪntə rijúwzəbəl mɛ́θədz, rijnéjmɪŋ vɛ́ərijəbəlz fɔr klɛ́ərɪtij, sɪ́mpləfajɪŋ kəndɪ́ʃənəl əksprɛ́ʃənz, ənd rijɔ́rɡənàjzɪŋ klǽs hájərɑ̀rkijz. rijfǽktərɪŋ ɪz ɔ́fən pərfɔ́rmd æz pɑ́rt əv rɛ́ɡjələr dəvɛ́ləpmənt sájkəlz ɔr bəfɔ́r ǽdɪŋ núw fíjtʃərz tə ənʃʊ́r ðə kówdbèjs rəméjnz hɛ́lθij ənd mǽnədʒəbəl ówvər tájm. wájl ɪt mej nɒt ɪntrədúws núw fíjtʃərz ɔr fɪ́ks bʌ́ɡz dɪərɛ́klij, ɪt krijéjts ə mɔr rowbʌ́st fawndéjʃən ðət méjks ðijz tǽsks íjzijər ɪn ðə fjúwtʃər."
    },
    {
        "Question": "What term do software developers use to describe characteristics in code that, while not bugs, indicate potential design problems and maintenance issues?",
        "RightAnswer": "Code Smell",
        "WrongAnswers": [
            "Bug Precursor",
            "Technical Deficit",
            "Design Fragrance",
            "Syntax Odor",
            "Implementation Aroma"
        ],
        "Explanation": "A Code Smell refers to certain characteristics or patterns in source code that suggest there might be deeper problems with the design or implementation. While code smells are not bugs or errors that cause immediate program failure, they often indicate weaknesses that could make the software harder to maintain, extend, or debug over time. Examples include excessively long methods, duplicate code, large classes with too many responsibilities, or excessive parameter lists. The term was popularized by Kent Beck and Martin Fowler and uses the metaphor of smell to suggest that, just as bad odors can alert us to problems, these code characteristics serve as warning signs that prompt developers to consider refactoring. Recognizing and addressing code smells is an important practice in maintaining clean, maintainable, and robust code.",
        "trans_Question": "wɒt tɜ́rm dúw sɔ́ftwɛ̀ər dəvɛ́ləpərz juwz tə dəskrájb kæ̀rəktərɪ́stɪks ɪn kówd ðət, wájl nɒt bʌ́ɡz, ɪ́ndɪkèjt pətɛ́nʃəl dəzájn prɒ́bləmz ənd méjntənəns ɪ́ʃuwz?",
        "trans_RightAnswer": "kówd smɛ́l",
        "trans_WrongAnswers": [
            "bʌ́ɡ prijkɜ́rsər",
            "tɛ́knɪkəl dɛ́fɪsɪt",
            "dəzájn fréjɡrəns",
            "sɪ́ntæ̀ks ówdər",
            "ɪ̀mpləmɛntéjʃən ərówmə"
        ],
        "trans_Explanation": "ə kówd smɛ́l rəfɜ́rz tə sɜ́rtən kæ̀rəktərɪ́stɪks ɔr pǽtərnz ɪn sɔ́rs kówd ðət sədʒɛ́st ðɛər majt bij díjpər prɒ́bləmz wɪð ðə dəzájn ɔr ɪ̀mpləmɛntéjʃən. wájl kówd smɛ́lz ɑr nɒt bʌ́ɡz ɔr ɛ́ərərz ðət kɒ́z ɪmíjdijət prówɡræ̀m féjljər, ðej ɔ́fən ɪ́ndɪkèjt wíjknəsɪz ðət kʊ́d méjk ðə sɔ́ftwɛ̀ər hɑ́rdər tə mejntéjn, əkstɛ́nd, ɔr dijbʌ́ɡ ówvər tájm. əɡzǽmpəlz ɪnklúwd əksɛ́sɪvlij lɔ́ŋ mɛ́θədz, dúwplɪkèjt kówd, lɑ́rdʒ klǽsɪz wɪð túw mɛ́nij rəspɒ̀nsɪbɪ́lɪtijz, ɔr əksɛ́sɪv pərǽmətər lɪ́sts. ðə tɜ́rm wɒz pɒ́pjələràjzd baj kɛ́nt bɛ́k ənd mɑ́rtɪn fáwlər ənd júwsɪz ðə mɛ́təfɔr əv smɛ́l tə sədʒɛ́st ðət, dʒəst æz bǽd ówdərz kən əlɜ́rt US tə prɒ́bləmz, ðijz kówd kæ̀rəktərɪ́stɪks sɜ́rv æz wɔ́rnɪŋ sájnz ðət prɒ́mpt dəvɛ́ləpərz tə kənsɪ́dər rijfǽktərɪŋ. rɛ́kəɡnàjzɪŋ ənd ədrɛ́sɪŋ kówd smɛ́lz ɪz ən ɪmpɔ́rtənt prǽktɪs ɪn mejntéjnɪŋ klíjn, mejntéjnəbəl, ənd rowbʌ́st kówd."
    },
    {
        "Question": "What is the common term in software development that describes the future consequences and extra work that arise when choosing expedient but suboptimal code solutions over better approaches that would take longer to implement?",
        "RightAnswer": "Technical Debt",
        "WrongAnswers": [
            "Code Liability",
            "Implementation Deficit",
            "Developer's Burden",
            "Software Mortgage",
            "Engineering Overhead"
        ],
        "Explanation": "Technical Debt is a metaphor that compares the consequences of taking shortcuts in software development to financial debt. When developers implement quick, suboptimal solutions to meet deadlines rather than using better approaches that take longer, they incur 'debt' that must eventually be 'repaid' through additional work. Just as financial debt accumulates interest, unaddressed technical debt makes future changes increasingly difficult and expensive. The concept extends beyond code to include outdated documentation, postponed testing, insufficient comments, and architectural compromises. Like financial debt, some technical debt is strategic and acceptable when taken consciously, while unintentional technical debt often results from inexperience or poor practices. Software teams must balance immediate delivery needs against long-term maintenance costs, with regular 'repayment' through refactoring and improvements to maintain a healthy, evolvable codebase.",
        "trans_Question": "wɒt ɪz ðə kɒ́mən tɜ́rm ɪn sɔ́ftwɛ̀ər dəvɛ́ləpmənt ðət dəskrájbz ðə fjúwtʃər kɒ́nsəkwɛ̀nsɪz ənd ɛ́kstrə wɜ́rk ðət ərájz wɛ́n tʃúwzɪŋ əkspíjdijənt bʌt sʌbɒ́ptɪməl kówd səlúwʃənz ówvər bɛ́tər əprówtʃɪz ðət wʊd téjk lɔ́ŋɡər tə ɪ́mpləmənt?",
        "trans_RightAnswer": "tɛ́knɪkəl dɛ́t",
        "trans_WrongAnswers": [
            "kówd làjəbɪ́lɪtij",
            "ɪ̀mpləmɛntéjʃən dɛ́fɪsɪt",
            "dəvɛ́ləpər'z bɜ́rdən",
            "sɔ́ftwɛ̀ər mɔ́rɡɪdʒ",
            "ɛ̀ndʒɪnɪ́ərɪŋ ówvərhɛ́d"
        ],
        "trans_Explanation": "tɛ́knɪkəl dɛ́t ɪz ə mɛ́təfɔr ðət kəmpɛ́ərz ðə kɒ́nsəkwɛ̀nsɪz əv téjkɪŋ ʃɔ́rtkʌ̀ts ɪn sɔ́ftwɛ̀ər dəvɛ́ləpmənt tə fàjnǽnʃəl dɛ́t. wɛ́n dəvɛ́ləpərz ɪ́mpləmənt kwɪ́k, sʌbɒ́ptɪməl səlúwʃənz tə míjt dɛ́dlàjnz rǽðər ðʌn júwzɪŋ bɛ́tər əprówtʃɪz ðət téjk lɔ́ŋɡər, ðej ɪnkɜ́r 'dɛ́t' ðət mʌst əvɛ́ntʃuwəlij bij 'rijpéjd' θrúw ədɪ́ʃənəl wɜ́rk. dʒəst æz fàjnǽnʃəl dɛ́t əkjúwmjəlèjts ɪ́ntərəst, ʌ̀nədrɛ́st tɛ́knɪkəl dɛ́t méjks fjúwtʃər tʃéjndʒɪz ɪnkríjsɪŋɡlij dɪ́fɪkəlt ənd əkspɛ́nsɪv. ðə kɒ́nsɛpt əkstɛ́ndz bìjɔ́nd kówd tə ɪnklúwd áwtdèjtɪd dɒ̀kjəmɛntéjʃən, powspównd tɛ́stɪŋ, ɪ̀nsəfɪ́ʃənt kɒ́mɛnts, ənd ɑ̀rkɪtɛ́ktʃərəl kɒ́mprəmajzɪz. lájk fàjnǽnʃəl dɛ́t, sʌm tɛ́knɪkəl dɛ́t ɪz strətíjdʒɪk ənd æksɛ́ptəbəl wɛ́n téjkən kɒ́nʃəslij, wájl ʌ̀nɪntɛ́nʃənəl tɛ́knɪkəl dɛ́t ɔ́fən rəzʌ́lts frəm ɪ̀nəkspɪ́ərijəns ɔr pɔ́r prǽktɪsɪz. sɔ́ftwɛ̀ər tíjmz mʌst bǽləns ɪmíjdijət dəlɪ́vərij níjdz əɡéjnst lɔ́ŋ-tɜ́rm méjntənəns kɒ́sts, wɪð rɛ́ɡjələr 'rijpéjmənt' θrúw rijfǽktərɪŋ ənd ɪmprúwvmənts tə mejntéjn ə hɛ́lθij, ɪvɒ́lvəbəl kówdbèjs."
    },
    {
        "Question": "What is the term for the comprehensive written materials and resources that explain how to use software, including guides, tutorials, and reference materials?",
        "RightAnswer": "Documentation",
        "WrongAnswers": [
            "Pseudocode",
            "Codebase",
            "Annotation",
            "Repository",
            "Protocol"
        ],
        "Explanation": "Documentation in computer science refers to written text or illustrations that accompany software or hardware, explaining how it works, how to use it, or how it was designed. Good documentation serves multiple purposes: it helps users understand how to operate the software, assists developers in maintaining or extending the code, provides technical specifications, and preserves institutional knowledge. Documentation can take many forms, including user manuals, API references, code comments, tutorials, and technical specifications. In professional software development, thorough documentation is considered a best practice as it reduces the learning curve for new users, minimizes support requests, and makes the codebase more maintainable over time. The quality and completeness of documentation often significantly impacts the adoption and longevity of software products.",
        "trans_Question": "wɒt ɪz ðə tɜ́rm fɔr ðə kɒ̀mprəhɛ́nsɪv rɪ́tən mətɪ́ərijəlz ənd ríjsɔrsɪz ðət əkspléjn háw tə juwz sɔ́ftwɛ̀ər, ɪnklúwdɪŋ ɡájdz, tuwtɔ́rijəlz, ənd rɛ́fərəns mətɪ́ərijəlz?",
        "trans_RightAnswer": "dɒ̀kjəmɛntéjʃən",
        "trans_WrongAnswers": [
            "súwdəkowd",
            "kówdbèjs",
            "æ̀nətéjʃən",
            "rijpɒ́zɪtɔ̀rij",
            "prówtəkɒ̀l"
        ],
        "trans_Explanation": "dɒ̀kjəmɛntéjʃən ɪn kəmpjúwtər sájəns rəfɜ́rz tə rɪ́tən tɛ́kst ɔr ɪ̀ləstréjʃənz ðət əkʌ́mpənij sɔ́ftwɛ̀ər ɔr hɑ́rdwɛ̀ər, əkspléjnɪŋ háw ɪt wɜ́rks, háw tə juwz ɪt, ɔr háw ɪt wɒz dəzájnd. ɡʊ́d dɒ̀kjəmɛntéjʃən sɜ́rvz mʌ́ltɪpəl pɜ́rpəsɪz: ɪt hɛ́lps júwzərz ʌ̀ndərstǽnd háw tə ɒ́pərèjt ðə sɔ́ftwɛ̀ər, əsɪ́sts dəvɛ́ləpərz ɪn mejntéjnɪŋ ɔr əkstɛ́ndɪŋ ðə kówd, prəvájdz tɛ́knɪkəl spɛ̀sɪfɪkéjʃənz, ənd prəzɜ́rvz ɪnstɪtúwʃənəl nɒ́lɪdʒ. dɒ̀kjəmɛntéjʃən kən téjk mɛ́nij fɔ́rmz, ɪnklúwdɪŋ júwzər mǽnjuwəlz, API rɛ́fərənsɪz, kówd kɒ́mɛnts, tuwtɔ́rijəlz, ənd tɛ́knɪkəl spɛ̀sɪfɪkéjʃənz. ɪn prəfɛ́ʃənəl sɔ́ftwɛ̀ər dəvɛ́ləpmənt, θɜ́row dɒ̀kjəmɛntéjʃən ɪz kənsɪ́dərd ə bɛ́st prǽktɪs æz ɪt rədjúwsɪz ðə lɜ́rnɪŋ kɜ́rv fɔr núw júwzərz, mɪ́nɪmàjzɪz səpɔ́rt rəkwɛ́s, ənd méjks ðə kówdbèjs mɔr mejntéjnəbəl ówvər tájm. ðə kwɑ́lɪtij ənd kəmplíjtnəs əv dɒ̀kjəmɛntéjʃən ɔ́fən sɪɡnɪ́fɪkəntlij ɪ́mpækts ðə ədɒ́pʃən ənd lɔndʒɛ́vɪtij əv sɔ́ftwɛ̀ər prɒ́dəkts."
    },
    {
        "Question": "What visual representation tool is widely used in programming to illustrate the sequence of steps in an algorithm or process, often containing various shapes connected by arrows to show execution flow?",
        "RightAnswer": "Flowchart",
        "WrongAnswers": [
            "Pseudocode",
            "Decision Table",
            "Entity Relationship Diagram",
            "Class Diagram",
            "Data Dictionary"
        ],
        "Explanation": "A flowchart is a graphical representation that illustrates the sequence of operations or steps in a process, algorithm, or program. It uses standardized symbols like rectangles for processing steps, diamonds for decision points, and arrows to show the flow direction. Flowcharts help programmers visualize the logic of algorithms before writing code, making them valuable for planning, documenting, and debugging software. They break down complex processes into manageable, visual components that are easier to understand than written descriptions alone. Flowcharts are particularly useful for communicating program structure to non-technical stakeholders and serve as an important tool in software development, system analysis, and process improvement activities.",
        "trans_Question": "wɒt vɪ́ʒəwəl rɛ̀prəzɛntéjʃən túwl ɪz wájdlij júwzd ɪn prówɡræ̀mɪŋ tə ɪ́ləstrèjt ðə síjkwəns əv stɛ́ps ɪn ən ǽlɡərɪ̀ðəm ɔr prɒ́sɛs, ɔ́fən kəntéjnɪŋ vɛ́ərijəs ʃéjps kənɛ́ktɪd baj ǽrowz tə ʃów ɛ̀ksəkjúwʃən flów?",
        "trans_RightAnswer": "flówtʃɑ̀rt",
        "trans_WrongAnswers": [
            "súwdəkowd",
            "dəsɪ́ʒən téjbəl",
            "ɛ́ntɪtij rəléjʃənʃɪ̀p dájəɡræ̀m",
            "klǽs dájəɡræ̀m",
            "déjtə dɪ́kʃənɛ̀ərij"
        ],
        "trans_Explanation": "ə flówtʃɑ̀rt ɪz ə ɡrǽfɪkəl rɛ̀prəzɛntéjʃən ðət ɪ́ləstrèjts ðə síjkwəns əv ɒ̀pəréjʃənz ɔr stɛ́ps ɪn ə prɒ́sɛs, ǽlɡərɪ̀ðəm, ɔr prówɡræ̀m. ɪt júwsɪz stǽndərdàjzd sɪ́mbəlz lájk rɛ́ktæ̀ŋɡəlz fɔr prɒ́sɛsɪŋ stɛ́ps, dájməndz fɔr dəsɪ́ʒən pɔ́jnts, ənd ǽrowz tə ʃów ðə flów dɪərɛ́kʃən. flówtʃɑ̀rts hɛ́lp prówɡræ̀mərz vɪ́ʒwəlàjz ðə lɒ́dʒɪk əv ǽlɡərɪ̀ðəmz bəfɔ́r rájtɪŋ kówd, méjkɪŋ ðɛm vǽljəbəl fɔr plǽnɪŋ, dɒ́kjəməntɪŋ, ənd dijbʌ́ɡɪŋ sɔ́ftwɛ̀ər. ðej bréjk dawn kɒ́mplɛks prɒ́sɛsɪz ɪntə mǽnədʒəbəl, vɪ́ʒəwəl kəmpównənts ðət ɑr íjzijər tə ʌ̀ndərstǽnd ðʌn rɪ́tən dəskrɪ́pʃənz əlówn. flówtʃɑ̀rts ɑr pərtɪ́kjələrlij júwsfəl fɔr kəmjúwnɪkèjtɪŋ prówɡræ̀m strʌ́ktʃər tə nɒn-tɛ́knɪkəl stéjkhòwldərz ənd sɜ́rv æz ən ɪmpɔ́rtənt túwl ɪn sɔ́ftwɛ̀ər dəvɛ́ləpmənt, sɪ́stəm ənǽlɪsɪs, ənd prɒ́sɛs ɪmprúwvmənt æktɪ́vɪtijz."
    },
    {
        "Question": "What is the name for the informal, human-readable notation that describes an algorithm's steps without using strict programming syntax rules?",
        "RightAnswer": "Pseudocode",
        "WrongAnswers": [
            "Wireframing",
            "Markup language",
            "Flowcharting",
            "Binary code",
            "Metadata syntax"
        ],
        "Explanation": "Pseudocode is an informal and human-readable way of describing a program or algorithm, serving as a bridge between natural language and actual programming code. Unlike real programming languages, pseudocode does not adhere to strict syntax rules, allowing programmers to express logic in a flexible, intuitive manner without worrying about language-specific details. It helps in planning and communicating the essential structure and flow of an algorithm before implementation, making it easier for both programmers and non-programmers to understand the conceptual approach. Pseudocode often borrows familiar programming constructs like loops, conditionals, and variable assignments, but presents them in a more natural, readable format. Developers frequently use pseudocode during the design phase to work through complex logic problems and to document their thinking process.",
        "trans_Question": "wɒt ɪz ðə néjm fɔr ðə ɪnfɔ́rməl, hjúwmən-ríjdəbəl nowtéjʃən ðət dəskrájbz ən ǽlɡərɪ̀ðəm'z stɛ́ps wɪðáwt júwzɪŋ strɪ́kt prówɡræ̀mɪŋ sɪ́ntæ̀ks rúwlz?",
        "trans_RightAnswer": "súwdəkowd",
        "trans_WrongAnswers": [
            "wájərfrèjmɪŋ",
            "mɑ́rkʌ̀p lǽŋɡwədʒ",
            "flowtʃɑ́rtɪŋ",
            "bájnərij kówd",
            "mɛ̀tədéjtə sɪ́ntæ̀ks"
        ],
        "trans_Explanation": "súwdəkowd ɪz ən ɪnfɔ́rməl ənd hjúwmən-ríjdəbəl wej əv dəskrájbɪŋ ə prówɡræ̀m ɔr ǽlɡərɪ̀ðəm, sɜ́rvɪŋ æz ə brɪ́dʒ bijtwíjn nǽtʃərəl lǽŋɡwədʒ ənd ǽktʃəl prówɡræ̀mɪŋ kówd. ʌ̀nlájk ríjəl prówɡræ̀mɪŋ lǽŋɡwədʒɪz, súwdəkowd dʌz nɒt ədhɪ́ər tə strɪ́kt sɪ́ntæ̀ks rúwlz, əláwɪŋ prówɡræ̀mərz tə əksprɛ́s lɒ́dʒɪk ɪn ə flɛ́ksɪbəl, ɪntúwɪtɪv mǽnər wɪðáwt wɜ́rijɪŋ əbawt lǽŋɡwədʒ-spəsɪ́fɪk díjtejlz. ɪt hɛ́lps ɪn plǽnɪŋ ənd kəmjúwnɪkèjtɪŋ ðə əsɛ́nʃəl strʌ́ktʃər ənd flów əv ən ǽlɡərɪ̀ðəm bəfɔ́r ɪ̀mpləmɛntéjʃən, méjkɪŋ ɪt íjzijər fɔr bówθ prówɡræ̀mərz ənd nɒn-prówɡræ̀mərz tə ʌ̀ndərstǽnd ðə kənsɛ́ptʃuwəl əprówtʃ. súwdəkowd ɔ́fən bɑ́rowz fəmɪ́ljər prówɡræ̀mɪŋ kɒ́nstrəkts lájk lúwps, kəndɪ́ʃənəlz, ənd vɛ́ərijəbəl əsájnmənts, bʌt prɛ́zənts ðɛm ɪn ə mɔr nǽtʃərəl, ríjdəbəl fɔ́rmæ̀t. dəvɛ́ləpərz fríjkwəntlij juwz súwdəkowd dʊ́rɪŋ ðə dəzájn féjz tə wɜ́rk θrúw kɒ́mplɛks lɒ́dʒɪk prɒ́bləmz ənd tə dɒ́kjəmɛnt ðɛər θɪ́ŋkɪŋ prɒ́sɛs."
    },
    {
        "Question": "What term describes the high-level structure of a software system, consisting of its components, their relationships, and the principles guiding its design and evolution?",
        "RightAnswer": "Software Architecture",
        "WrongAnswers": [
            "Code Compilation",
            "System Programming",
            "Data Encryption",
            "Version Control",
            "Object Inheritance"
        ],
        "Explanation": "Software Architecture refers to the fundamental organization of a software system, embodied in its components, their relationships to each other and the environment, and the principles guiding its design and evolution. It represents the design decisions that are most difficult to change later in development. Unlike low-level implementation details, architecture focuses on the broader structure that enables quality attributes such as performance, security, maintainability, and scalability. A well-crafted software architecture serves as a blueprint that guides development teams, facilitates communication among stakeholders, and ensures that the system fulfills both its functional requirements and non-functional characteristics. Architects consider tradeoffs between competing concerns and select appropriate architectural styles and patterns such as client-server, microservices, or layered architectures based on project requirements.",
        "trans_Question": "wɒt tɜ́rm dəskrájbz ðə háj-lɛ́vəl strʌ́ktʃər əv ə sɔ́ftwɛ̀ər sɪ́stəm, kənsɪ́stɪŋ əv ɪts kəmpównənts, ðɛər rəléjʃənʃɪ̀ps, ənd ðə prɪ́nsɪpəlz ɡájdɪŋ ɪts dəzájn ənd ɛ̀vəlúwʃən?",
        "trans_RightAnswer": "sɔ́ftwɛ̀ər ɑ́rkɪtɛ̀ktʃər",
        "trans_WrongAnswers": [
            "kówd kɒ̀mpɪléjʃən",
            "sɪ́stəm prówɡræ̀mɪŋ",
            "déjtə ɛnkrɪ́pʃən",
            "vɜ́rʒən kəntrówl",
            "ɒ́bdʒəkt ɪnhɛ́ərɪtəns"
        ],
        "trans_Explanation": "sɔ́ftwɛ̀ər ɑ́rkɪtɛ̀ktʃər rəfɜ́rz tə ðə fʌ̀ndəmɛ́ntəl ɔ̀rɡənɪzéjʃən əv ə sɔ́ftwɛ̀ər sɪ́stəm, əmbɒ́dijd ɪn ɪts kəmpównənts, ðɛər rəléjʃənʃɪ̀ps tə ijtʃ ʌ́ðər ənd ðə ənvájərənmənt, ənd ðə prɪ́nsɪpəlz ɡájdɪŋ ɪts dəzájn ənd ɛ̀vəlúwʃən. ɪt rɛ̀prəzɛ́nts ðə dəzájn dəsɪ́ʒənz ðət ɑr mówst dɪ́fɪkəlt tə tʃéjndʒ léjtər ɪn dəvɛ́ləpmənt. ʌ̀nlájk lów-lɛ́vəl ɪ̀mpləmɛntéjʃən díjtejlz, ɑ́rkɪtɛ̀ktʃər fówkəsɪz ɒn ðə brɔ́dər strʌ́ktʃər ðət ɛnéjbəlz kwɑ́lɪtij ǽtrəbjùwts sʌtʃ æz pərfɔ́rməns, səkjʊ́rɪtij, mejntéjnəbɪ́lɪtij, ənd skéjləbɪ́lɪtij. ə wɛ́l-krǽftɪd sɔ́ftwɛ̀ər ɑ́rkɪtɛ̀ktʃər sɜ́rvz æz ə blúwprɪ̀nt ðət ɡájdz dəvɛ́ləpmənt tíjmz, fəsɪ́lətèjts kəmjùwnɪkéjʃən əmʌ́ŋ stéjkhòwldərz, ənd ənʃʊ́rz ðət ðə sɪ́stəm fʊlfɪ́lz bówθ ɪts fʌ́ŋkʃənəl rəkwájərmənts ənd nɒn-fʌ́ŋkʃənəl kæ̀rəktərɪ́stɪks. ɑ́rkɪtɛ̀kts kənsɪ́dər tréjdɔ̀fs bijtwíjn kəmpíjtɪŋ kənsɜ́rnz ənd səlɛ́kt əprówprijèjt ɑ̀rkɪtɛ́ktʃərəl stájlz ənd pǽtərnz sʌtʃ æz klájənt-sɜ́rvər, májkrowsɜ́rvɪsɪz, ɔr léjərd ɑ́rkɪtɛ̀ktʃərz béjst ɒn prɒ́dʒɛkt rəkwájərmənts."
    },
    {
        "Question": "What is the term for a system's ability to handle growing amounts of work by adding resources to the system, with minimal disruption to existing operations?",
        "RightAnswer": "Scalability",
        "WrongAnswers": [
            "Elasticity",
            "Redundancy",
            "Latency",
            "Throughput",
            "Fault tolerance"
        ],
        "Explanation": "Scalability refers to a system's capacity to grow and manage increased demand while maintaining performance. In computer science, a scalable system can adapt to increasing workloads by adding more resources (like processors, memory, or servers) without requiring a complete redesign. There are two main types: vertical scalability (scaling up) involves adding resources to a single node, while horizontal scalability (scaling out) involves adding more nodes to a system. Well-designed scalable architectures are crucial for applications that expect growth in users, data volume, or transaction rates. Companies like Google, Amazon, and Facebook rely heavily on scalable systems to serve millions of users simultaneously. Scalability is not just about handling peak loads but doing so efficiently, maintaining performance metrics, and often balancing cost considerations against performance needs.",
        "trans_Question": "wɒt ɪz ðə tɜ́rm fɔr ə sɪ́stəm'z əbɪ́lɪtij tə hǽndəl ɡrówɪŋ əmáwnts əv wɜ́rk baj ǽdɪŋ ríjsɔrsɪz tə ðə sɪ́stəm, wɪð mɪ́nɪməl dɪsrʌ́pʃən tə əɡzɪ́stɪŋ ɒ̀pəréjʃənz?",
        "trans_RightAnswer": "skéjləbɪ́lɪtij",
        "trans_WrongAnswers": [
            "əlæ̀stɪ́sɪtij",
            "rədʌ́ndənsij",
            "léjtənsij",
            "θrúwpʊ̀t",
            "fɔ́lt tɒ́lərəns"
        ],
        "trans_Explanation": "skéjləbɪ́lɪtij rəfɜ́rz tə ə sɪ́stəm'z kəpǽsɪtij tə ɡrów ənd mǽnɪdʒ ɪnkríjst dəmǽnd wájl mejntéjnɪŋ pərfɔ́rməns. ɪn kəmpjúwtər sájəns, ə skéjləbəl sɪ́stəm kən ədǽpt tə ɪnkríjsɪŋ wɜ́rklòwdz baj ǽdɪŋ mɔr ríjsɔrsɪz (lájk prɒ́sɛsərz, mɛ́mərij, ɔr sɜ́rvərz) wɪðáwt rijkwájərɪŋ ə kəmplíjt rìjdəzájn. ðɛər ɑr túw méjn tájps: vɜ́rtɪkəl skéjləbɪ́lɪtij (skéjlɪŋ ʌp) ɪnvɒ́lvz ǽdɪŋ ríjsɔrsɪz tə ə sɪ́ŋɡəl nówd, wájl hɔ̀rɪzɒ́ntəl skéjləbɪ́lɪtij (skéjlɪŋ awt) ɪnvɒ́lvz ǽdɪŋ mɔr nówdz tə ə sɪ́stəm. wɛ́l-dəzájnd skéjləbəl ɑ́rkɪtɛ̀ktʃərz ɑr krúwʃəl fɔr æ̀plɪkéjʃənz ðət əkspɛ́kt ɡrówθ ɪn júwzərz, déjtə vɒ́ljuwm, ɔr trænzǽkʃən réjts. kʌ́mpənìjz lájk ɡúwɡəl, əmǽzɒn, ənd féjsbʊ̀k rəláj hɛ́vɪlij ɒn skéjləbəl sɪ́stəmz tə sɜ́rv mɪ́ljənz əv júwzərz sàjməltéjnijəslij. skéjləbɪ́lɪtij ɪz nɒt dʒəst əbawt hǽndəlɪŋ píjk lówdz bʌt dúwɪŋ sow əfɪ́ʃəntlij, mejntéjnɪŋ pərfɔ́rməns mɛ́trɪks, ənd ɔ́fən bǽlənsɪŋ kɒ́st kənsɪ̀dəréjʃənz əɡéjnst pərfɔ́rməns níjdz."
    },
    {
        "Question": "What term describes a system's ability to consistently perform its intended functions without failure for a specified period of time under stated conditions?",
        "RightAnswer": "Reliability",
        "WrongAnswers": [
            "Scalability",
            "Efficiency",
            "Transparency",
            "Modularity",
            "Portability"
        ],
        "Explanation": "Reliability in computer science refers to the capability of a system or component to perform its required functions under specified conditions for a stated period of time without failure. It encompasses several aspects including fault tolerance, error handling, and resilience against unexpected inputs or environmental changes. A reliable system minimizes downtime, maintains data integrity, and ensures consistent performance even when parts of the system fail. Reliability is often measured through metrics such as mean time between failures, availability percentage, and failure rate. It's a critical quality attribute for mission-critical systems like banking applications, medical devices, and aerospace systems where failures could have serious consequences. Engineers improve reliability through redundancy, thorough testing, defensive programming, and robust error recovery mechanisms.",
        "trans_Question": "wɒt tɜ́rm dəskrájbz ə sɪ́stəm'z əbɪ́lɪtij tə kənsɪ́stəntlij pərfɔ́rm ɪts ɪntɛ́ndɪd fʌ́ŋkʃənz wɪðáwt féjljər fɔr ə spɛ́sɪfàjd pɪ́ərijəd əv tájm ʌ́ndər stéjtɪd kəndɪ́ʃənz?",
        "trans_RightAnswer": "rəlàjəbɪ́lɪtij",
        "trans_WrongAnswers": [
            "skéjləbɪ́lɪtij",
            "əfɪ́ʃənsij",
            "trænspɛ́ərənsij",
            "mɒ́djəlǽrɪtij",
            "pɔ̀rtəbɪ́lɪtij"
        ],
        "trans_Explanation": "rəlàjəbɪ́lɪtij ɪn kəmpjúwtər sájəns rəfɜ́rz tə ðə kèjpəbɪ́lɪtij əv ə sɪ́stəm ɔr kəmpównənt tə pərfɔ́rm ɪts rəkwájərd fʌ́ŋkʃənz ʌ́ndər spɛ́sɪfàjd kəndɪ́ʃənz fɔr ə stéjtɪd pɪ́ərijəd əv tájm wɪðáwt féjljər. ɪt ɛnkʌ́mpəsɪz sɛ́vərəl ǽspɛkts ɪnklúwdɪŋ fɔ́lt tɒ́lərəns, ɛ́ərər hǽndəlɪŋ, ənd rəzɪ́lijəns əɡéjnst ʌ̀nəkspɛ́ktɪd ɪ́npʊ̀ts ɔr ənvàjərənmɛ́ntəl tʃéjndʒɪz. ə rəlájəbəl sɪ́stəm mɪ́nɪmàjzɪz dáwntàjm, mejntéjnz déjtə ɪntɛ́ɡrɪtij, ənd ənʃʊ́rz kənsɪ́stənt pərfɔ́rməns íjvən wɛ́n pɑ́rts əv ðə sɪ́stəm féjl. rəlàjəbɪ́lɪtij ɪz ɔ́fən mɛ́ʒərd θrúw mɛ́trɪks sʌtʃ æz míjn tájm bijtwíjn féjljərz, əvèjləbɪ́lɪtij pərsɛ́ntɪdʒ, ənd féjljər réjt. ɪt's ə krɪ́tɪkəl kwɑ́lɪtij ǽtrɪbjuwt fɔr mɪ́ʃən-krɪ́tɪkəl sɪ́stəmz lájk bǽŋkɪŋ æ̀plɪkéjʃənz, mɛ́dɪkəl dəvájsɪz, ənd ɛ́ərowspèjs sɪ́stəmz wɛ́ər féjljərz kʊ́d həv sɪ́ərijəs kɒ́nsəkwɛ̀nsɪz. ɛ̀ndʒɪnɪ́ərz ɪmprúwv rəlàjəbɪ́lɪtij θrúw rədʌ́ndənsij, θɜ́row tɛ́stɪŋ, dəfɛ́nsɪv prówɡræ̀mɪŋ, ənd rowbʌ́st ɛ́ərər rəkʌ́vərij mɛ́kənɪzəmz."
    },
    {
        "Question": "Which term refers to a system's ability to remain operational and accessible for users when needed, often measured as a percentage of total time?",
        "RightAnswer": "Availability",
        "WrongAnswers": [
            "Durability",
            "Latency",
            "Throughput",
            "Compatibility",
            "Responsiveness"
        ],
        "Explanation": "Availability in computer science refers to the degree to which a system, service, or resource is accessible and usable upon demand by authorized users. It's typically measured as a percentage of uptime over a given period, with high-availability systems often targeting 99.9% uptime or higher (known as 'three nines'). Availability is a fundamental aspect of system reliability and is affected by factors such as hardware failures, software bugs, network issues, and maintenance activities. To increase availability, engineers implement redundancy, failover mechanisms, load balancing, and distributed architectures. In mission-critical applications like banking or healthcare, availability becomes particularly crucial as downtime can have significant consequences. It forms one part of the CIA triad (Confidentiality, Integrity, Availability) in information security, highlighting its importance in ensuring systems can be accessed when needed.",
        "trans_Question": "wɪ́tʃ tɜ́rm rəfɜ́rz tə ə sɪ́stəm'z əbɪ́lɪtij tə rəméjn ɒ̀pəréjʃənəl ənd æksɛ́sɪbəl fɔr júwzərz wɛ́n níjdɪd, ɔ́fən mɛ́ʒərd æz ə pərsɛ́ntɪdʒ əv tówtəl tájm?",
        "trans_RightAnswer": "əvèjləbɪ́lɪtij",
        "trans_WrongAnswers": [
            "dərəbɪ́lɪtij",
            "léjtənsij",
            "θrúwpʊ̀t",
            "kəmpæ̀tɪbɪ́lɪtij",
            "rəspɒ́nsɪvnəs"
        ],
        "trans_Explanation": "əvèjləbɪ́lɪtij ɪn kəmpjúwtər sájəns rəfɜ́rz tə ðə dəɡríj tə wɪ́tʃ ə sɪ́stəm, sɜ́rvɪs, ɔr ríjsɔrs ɪz æksɛ́sɪbəl ənd júwzəbəl əpɒ́n dəmǽnd baj ɔ́θəràjzd júwzərz. ɪt's tɪ́pɪkəlij mɛ́ʒərd æz ə pərsɛ́ntɪdʒ əv ʌ́ptàjm ówvər ə ɡɪ́vən pɪ́ərijəd, wɪð háj-əvèjləbɪ́lɪtij sɪ́stəmz ɔ́fən tɑ́rɡətɪŋ 99.9% ʌ́ptàjm ɔr hájər (nówn æz 'θríj nájnz'). əvèjləbɪ́lɪtij ɪz ə fʌ̀ndəmɛ́ntəl ǽspɛkt əv sɪ́stəm rəlàjəbɪ́lɪtij ənd ɪz əfɛ́ktɪd baj fǽktərz sʌtʃ æz hɑ́rdwɛ̀ər féjljərz, sɔ́ftwɛ̀ər bʌ́ɡz, nɛ́twɜ̀rk ɪ́ʃuwz, ənd méjntənəns æktɪ́vɪtijz. tə ɪnkríjs əvèjləbɪ́lɪtij, ɛ̀ndʒɪnɪ́ərz ɪ́mpləmənt rədʌ́ndənsij, féjlowvər mɛ́kənɪzəmz, lówd bǽlənsɪŋ, ənd dɪstrɪ́bjətɪd ɑ́rkɪtɛ̀ktʃərz. ɪn mɪ́ʃən-krɪ́tɪkəl æ̀plɪkéjʃənz lájk bǽŋkɪŋ ɔr hɛ́lθkɛ̀ər, əvèjləbɪ́lɪtij bəkʌ́mz pərtɪ́kjələrlij krúwʃəl æz dáwntàjm kən həv sɪɡnɪ́fɪkənt kɒ́nsəkwɛ̀nsɪz. ɪt fɔ́rmz wʌ́n pɑ́rt əv ðə CIA trájæ̀d (kɒ̀nfɪdɛ́nʃijǽlɪtij, ɪntɛ́ɡrɪtij, əvèjləbɪ́lɪtij) ɪn ɪnfərméjʃən səkjʊ́rɪtij, hájlàjtɪŋ ɪts ɪmpɔ́rtəns ɪn ɛnʃʊ́rɪŋ sɪ́stəmz kən bij ǽksɛ̀st wɛ́n níjdɪd."
    },
    {
        "Question": "Which computing concept specifically describes a system's ability to continue operating properly even when hardware or software components fail?",
        "RightAnswer": "Fault Tolerance",
        "WrongAnswers": [
            "Load Balancing",
            "Error Correction",
            "Redundant Architecture",
            "System Resilience",
            "Failure Recovery"
        ],
        "Explanation": "Fault Tolerance refers to a system's capability to continue functioning correctly even when one or more of its components fail. Rather than shutting down entirely when something goes wrong, fault-tolerant systems implement strategies to detect faults, work around them, and continue delivering services. This is achieved through various techniques such as redundancy (having backup components), error detection and correction mechanisms, and isolation of failing components. For example, a fault-tolerant database might store multiple copies of data across different physical servers so that if one server crashes, the system can automatically switch to another without losing data or interrupting service. Fault tolerance is especially crucial in mission-critical applications like air traffic control systems, banking networks, or medical devices where failure could have serious consequences. It represents a fundamental design philosophy where system reliability takes precedence over occasional component failures.",
        "trans_Question": "wɪ́tʃ kəmpjúwtɪŋ kɒ́nsɛpt spəsɪ́fɪklij dəskrájbz ə sɪ́stəm'z əbɪ́lɪtij tə kəntɪ́njuw ɒ́pərèjtɪŋ prɒ́pərlij íjvən wɛ́n hɑ́rdwɛ̀ər ɔr sɔ́ftwɛ̀ər kəmpównənts féjl?",
        "trans_RightAnswer": "fɔ́lt tɒ́lərəns",
        "trans_WrongAnswers": [
            "lówd bǽlənsɪŋ",
            "ɛ́ərər kərɛ́kʃən",
            "rədʌ́ndənt ɑ́rkɪtɛ̀ktʃər",
            "sɪ́stəm rəzɪ́lijəns",
            "féjljər rəkʌ́vərij"
        ],
        "trans_Explanation": "fɔ́lt tɒ́lərəns rəfɜ́rz tə ə sɪ́stəm'z kèjpəbɪ́lɪtij tə kəntɪ́njuw fʌ́ŋkʃənɪŋ kərɛ́ktlij íjvən wɛ́n wʌ́n ɔr mɔr əv ɪts kəmpównənts féjl. rǽðər ðʌn ʃʌ́tɪŋ dawn əntájərlij wɛ́n sʌ́mθɪŋ ɡówz rɔ́ŋ, fɔ́lt-tɒ́lərənt sɪ́stəmz ɪ́mpləmənt strǽtədʒijz tə dətɛ́kt fɔ́lts, wɜ́rk əráwnd ðɛm, ənd kəntɪ́njuw dəlɪ́vərɪŋ sɜ́rvɪsɪz. ðɪs ɪz ətʃíjvd θrúw vɛ́ərijəs tɛkníjks sʌtʃ æz rədʌ́ndənsij (hǽvɪŋ bǽkʌ̀p kəmpównənts), ɛ́ərər dətɛ́kʃən ənd kərɛ́kʃən mɛ́kənɪzəmz, ənd àjsəléjʃən əv féjlɪŋ kəmpównənts. fɔr əɡzǽmpəl, ə fɔ́lt-tɒ́lərənt déjtəbèjs majt stɔ́r mʌ́ltɪpəl kɒ́pijz əv déjtə əkrɔ́s dɪ́fərənt fɪ́zɪkəl sɜ́rvərz sow ðət ɪf wʌ́n sɜ́rvər krǽʃɪz, ðə sɪ́stəm kən ɔ̀təmǽtɪklij swɪ́tʃ tə ənʌ́ðər wɪðáwt lúwzɪŋ déjtə ɔr ɪ̀ntərʌ́ptɪŋ sɜ́rvɪs. fɔ́lt tɒ́lərəns ɪz əspɛ́ʃəlij krúwʃəl ɪn mɪ́ʃən-krɪ́tɪkəl æ̀plɪkéjʃənz lájk ɛ́ər trǽfɪk kəntrówl sɪ́stəmz, bǽŋkɪŋ nɛ́twɜ̀rks, ɔr mɛ́dɪkəl dəvájsɪz wɛ́ər féjljər kʊ́d həv sɪ́ərijəs kɒ́nsəkwɛ̀nsɪz. ɪt rɛ̀prəzɛ́nts ə fʌ̀ndəmɛ́ntəl dəzájn fɪlɒ́səfij wɛ́ər sɪ́stəm rəlàjəbɪ́lɪtij téjks prɛ́sədəns ówvər əkéjʒənəl kəmpównənt féjljərz."
    },
    {
        "Question": "Which performance evaluation technique deliberately puts a system under increasing amounts of simulated user activity to determine when and how it will break?",
        "RightAnswer": "Load Testing",
        "WrongAnswers": [
            "Unit Testing",
            "Security Scanning",
            "Stress Mapping",
            "Functional Decomposition",
            "Regression Analysis"
        ],
        "Explanation": "Load Testing is a performance evaluation technique in computer science where systems are deliberately subjected to varying levels of simulated user traffic or data volume to evaluate their behavior under expected and peak conditions. Unlike basic functional testing that verifies correctness, load testing focuses on measuring response times, throughput rates, and resource utilization patterns when multiple users access the system simultaneously. Software engineers use load testing to identify bottlenecks, determine maximum operational capacity, and ensure the system maintains acceptable performance levels under heavy demand. This practice is especially critical for web applications, databases, and network services that need to handle large numbers of concurrent users. Modern load testing often employs automated tools that can simulate thousands of virtual users interacting with a system, allowing development teams to identify performance thresholds before deploying to production environments.",
        "trans_Question": "wɪ́tʃ pərfɔ́rməns əvæ̀ljuwéjʃən tɛkníjk dəlɪ́bərətlij pʊ́ts ə sɪ́stəm ʌ́ndər ɪnkríjsɪŋ əmáwnts əv sɪ́mjəlèjtɪd júwzər æktɪ́vɪtij tə dətɜ́rmɪn wɛ́n ənd háw ɪt wɪl bréjk?",
        "trans_RightAnswer": "lówd tɛ́stɪŋ",
        "trans_WrongAnswers": [
            "júwnɪt tɛ́stɪŋ",
            "səkjʊ́rɪtij skǽnɪŋ",
            "strɛ́s mǽpɪŋ",
            "fʌ́ŋkʃənəl dìjkəmpəzɪ́ʃən",
            "rəɡrɛ́ʃən ənǽlɪsɪs"
        ],
        "trans_Explanation": "lówd tɛ́stɪŋ ɪz ə pərfɔ́rməns əvæ̀ljuwéjʃən tɛkníjk ɪn kəmpjúwtər sájəns wɛ́ər sɪ́stəmz ɑr dəlɪ́bərətlij sʌbdʒɛ́ktɪd tə vɛ́ərijɪŋ lɛ́vəlz əv sɪ́mjəlèjtɪd júwzər trǽfɪk ɔr déjtə vɒ́ljuwm tə əvǽljuwèjt ðɛər bəhéjvjər ʌ́ndər əkspɛ́ktɪd ənd píjk kəndɪ́ʃənz. ʌ̀nlájk béjsɪk fʌ́ŋkʃənəl tɛ́stɪŋ ðət vɛ́ərɪfajz kərɛ́ktnəs, lówd tɛ́stɪŋ fówkəsɪz ɒn mɛ́ʒərɪŋ rəspɒ́ns tájmz, θrúwpʊ̀t réjts, ənd ríjsɔrs jùwtɪlɪzéjʃən pǽtərnz wɛ́n mʌ́ltɪpəl júwzərz ǽksɛ̀s ðə sɪ́stəm sàjməltéjnijəslij. sɔ́ftwɛ̀ər ɛ̀ndʒɪnɪ́ərz juwz lówd tɛ́stɪŋ tə ajdɛ́ntɪfàj bɒ́təlnɛ̀ks, dətɜ́rmɪn mǽksɪməm ɒ̀pəréjʃənəl kəpǽsɪtij, ənd ənʃʊ́r ðə sɪ́stəm mejntéjnz æksɛ́ptəbəl pərfɔ́rməns lɛ́vəlz ʌ́ndər hɛ́vij dəmǽnd. ðɪs prǽktɪs ɪz əspɛ́ʃəlij krɪ́tɪkəl fɔr wɛ́b æ̀plɪkéjʃənz, déjtəbèjsɪz, ənd nɛ́twɜ̀rk sɜ́rvɪsɪz ðət níjd tə hǽndəl lɑ́rdʒ nʌ́mbərz əv kənkɜ́rənt júwzərz. mɒ́dərn lówd tɛ́stɪŋ ɔ́fən ɛmplɔ́jz ɔ́təmèjtɪd túwlz ðət kən sɪ́mjəlèjt θáwzəndz əv vɜ́rtʃuwəl júwzərz ɪ̀ntərǽktɪŋ wɪð ə sɪ́stəm, əláwɪŋ dəvɛ́ləpmənt tíjmz tə ajdɛ́ntɪfàj pərfɔ́rməns θrɛ́ʃòwldz bəfɔ́r dəplɔ́jɪŋ tə prədʌ́kʃən ənvájərənmənts."
    },
    {
        "Question": "What technology isolates applications with their dependencies into standardized units for consistent deployment across different computing environments?",
        "RightAnswer": "Containerization",
        "WrongAnswers": [
            "Virtualization",
            "Sandboxing",
            "Microservicing",
            "Encapsulation",
            "Package Management"
        ],
        "Explanation": "Containerization is a lightweight virtualization technique that packages an application and all its dependencies, libraries, and configuration files together into a single, standalone executable unit called a container. Unlike traditional virtual machines, containers share the host system's operating system kernel, making them more efficient and portable. Containerization solves the 'it works on my machine' problem by ensuring consistent application behavior across development, testing, and production environments. Popular containerization platforms include Docker and Kubernetes. This approach has revolutionized software deployment by enabling applications to run reliably and consistently regardless of the infrastructure, simplifying scalability, and improving resource utilization.",
        "trans_Question": "wɒt tɛknɒ́lədʒij ájsəlèjts æ̀plɪkéjʃənz wɪð ðɛər dəpɛ́ndənsijz ɪntə stǽndərdàjzd júwnɪts fɔr kənsɪ́stənt dəplɔ́jmənt əkrɔ́s dɪ́fərənt kəmpjúwtɪŋ ənvájərənmənts?",
        "trans_RightAnswer": "kəntéjnəràjzɪzéjʃən",
        "trans_WrongAnswers": [
            "vɜ̀rtʃuwəlɪzéjʃən",
            "sǽndbɒ̀ksɪŋ",
            "màjkrowsɜ́rvɪsɪŋ",
            "ɛnkǽpsəlèjʃən",
            "pǽkɪdʒ mǽnədʒmənt"
        ],
        "trans_Explanation": "kəntéjnəràjzɪzéjʃən ɪz ə lájtwéjt vɜ̀rtʃuwəlɪzéjʃən tɛkníjk ðət pǽkɪdʒɪz ən æ̀plɪkéjʃən ənd ɔl ɪts dəpɛ́ndənsijz, lájbrɛərìjz, ənd kənfɪ̀ɡjəréjʃən fájlz təɡɛ́ðər ɪntə ə sɪ́ŋɡəl, stǽndəlòwn ɛ́ksəkjùwtəbəl júwnɪt kɔ́ld ə kəntéjnər. ʌ̀nlájk trədɪ́ʃənəl vɜ́rtʃuwəl məʃíjnz, kəntéjnərz ʃɛ́ər ðə hówst sɪ́stəm'z ɒ́pərèjtɪŋ sɪ́stəm kɜ́rnəl, méjkɪŋ ðɛm mɔr əfɪ́ʃənt ənd pɔ́rtəbəl. kəntéjnəràjzɪzéjʃən sɒ́lvz ðə 'ɪt wɜ́rks ɒn máj məʃíjn' prɒ́bləm baj ɛnʃʊ́rɪŋ kənsɪ́stənt æ̀plɪkéjʃən bəhéjvjər əkrɔ́s dəvɛ́ləpmənt, tɛ́stɪŋ, ənd prədʌ́kʃən ənvájərənmənts. pɒ́pjələr kəntéjnəràjzɪzéjʃən plǽtfɔ̀rmz ɪnklúwd dɒ́kər ənd kuwbərnɛ́tɪs. ðɪs əprówtʃ həz rɛ̀vəlúwʃənàjzd sɔ́ftwɛ̀ər dəplɔ́jmənt baj ɛnéjbəlɪŋ æ̀plɪkéjʃənz tə rʌ́n rəlájəblij ənd kənsɪ́stəntlij rəɡɑ́rdləs əv ðə ɪnfrəstrʌ́ktʃər, sɪ́mpləfajɪŋ skéjləbɪ́lɪtij, ənd ɪmprúwvɪŋ ríjsɔrs jùwtɪlɪzéjʃən."
    },
    {
        "Question": "Which technology allows developers to package applications with all their dependencies into standardized units called containers for consistent deployment across different computing environments?",
        "RightAnswer": "Docker",
        "WrongAnswers": [
            "Jenkins",
            "Kubernetes",
            "Terraform",
            "Ansible",
            "Vagrant"
        ],
        "Explanation": "Docker is a platform that uses containerization technology to simplify application deployment. It allows developers to package an application along with all its libraries, dependencies, and configuration files into a standardized unit called a container. These containers are isolated from each other and the underlying system, ensuring that applications run consistently regardless of the environment. Docker achieves this through lightweight virtualization that shares the host system's kernel, making containers more efficient than traditional virtual machines. Developers particularly value Docker for enabling the 'build once, run anywhere' approach, which streamlines development workflows, improves collaboration, and eliminates the common 'it works on my machine' problem. Since its introduction in 2013, Docker has become fundamental to modern DevOps practices and cloud-native application development.",
        "trans_Question": "wɪ́tʃ tɛknɒ́lədʒij əláwz dəvɛ́ləpərz tə pǽkɪdʒ æ̀plɪkéjʃənz wɪð ɔl ðɛər dəpɛ́ndənsijz ɪntə stǽndərdàjzd júwnɪts kɔ́ld kəntéjnərz fɔr kənsɪ́stənt dəplɔ́jmənt əkrɔ́s dɪ́fərənt kəmpjúwtɪŋ ənvájərənmənts?",
        "trans_RightAnswer": "dɒ́kər",
        "trans_WrongAnswers": [
            "dʒɛ́ŋkɪnz",
            "kuwbərnɛ́tɪs",
            "tɛərəfɔrm",
            "ǽnsɪbəl",
            "véjɡrənt"
        ],
        "trans_Explanation": "dɒ́kər ɪz ə plǽtfɔ̀rm ðət júwsɪz kəntéjnəràjzɪzéjʃən tɛknɒ́lədʒij tə sɪ́mpləfaj æ̀plɪkéjʃən dəplɔ́jmənt. ɪt əláwz dəvɛ́ləpərz tə pǽkɪdʒ ən æ̀plɪkéjʃən əlɔ́ŋ wɪð ɔl ɪts lájbrɛərìjz, dəpɛ́ndənsijz, ənd kənfɪ̀ɡjəréjʃən fájlz ɪntə ə stǽndərdàjzd júwnɪt kɔ́ld ə kəntéjnər. ðijz kəntéjnərz ɑr ájsəlèjtɪd frəm ijtʃ ʌ́ðər ənd ðə ʌ̀ndərlájɪŋ sɪ́stəm, ɛnʃʊ́rɪŋ ðət æ̀plɪkéjʃənz rʌ́n kənsɪ́stəntlij rəɡɑ́rdləs əv ðə ənvájərənmənt. dɒ́kər ətʃíjvz ðɪs θrúw lájtwéjt vɜ̀rtʃuwəlɪzéjʃən ðət ʃɛ́ərz ðə hówst sɪ́stəm'z kɜ́rnəl, méjkɪŋ kəntéjnərz mɔr əfɪ́ʃənt ðʌn trədɪ́ʃənəl vɜ́rtʃuwəl məʃíjnz. dəvɛ́ləpərz pərtɪ́kjələrlij vǽljuw dɒ́kər fɔr ɛnéjbəlɪŋ ðə 'bɪ́ld wʌ́ns, rʌ́n ɛ́nijwɛ̀ər' əprówtʃ, wɪ́tʃ stríjmlàjnz dəvɛ́ləpmənt wɜ́rkflòwz, ɪmprúwvz kəlæ̀bəréjʃən, ənd əlɪ́mɪnèjts ðə kɒ́mən 'ɪt wɜ́rks ɒn máj məʃíjn' prɒ́bləm. sɪns ɪts ɪntrədʌ́kʃən ɪn 2013, dɒ́kər həz bəkʌ́m fʌ̀ndəmɛ́ntəl tə mɒ́dərn dɛ́vɒps prǽktɪsɪz ənd kláwd-néjtɪv æ̀plɪkéjʃən dəvɛ́ləpmənt."
    },
    {
        "Question": "Which open-source platform automates containerized application deployment, scaling, and management using a declarative configuration approach and self-healing capabilities?",
        "RightAnswer": "Kubernetes",
        "WrongAnswers": [
            "Docker Swarm",
            "Apache Mesos",
            "Jenkins",
            "Terraform",
            "Ansible"
        ],
        "Explanation": "Kubernetes is an open-source container orchestration platform designed to automate the deployment, scaling, and management of containerized applications. Originally developed by Google and now maintained by the Cloud Native Computing Foundation, Kubernetes provides a framework to run distributed systems resiliently. It handles scheduling containers across a cluster, ensures applications run as intended, manages workload distribution, and implements self-healing by automatically restarting failed containers or replacing them when nodes malfunction. Kubernetes abstracts away the underlying infrastructure, allowing developers to focus on designing applications rather than worrying about the specific environment in which they run. With features like horizontal scaling, service discovery, load balancing, automated rollouts and rollbacks, and configuration management, Kubernetes has become the industry standard for container orchestration in both development environments and large-scale production systems.",
        "trans_Question": "wɪ́tʃ ówpən-sɔ́rs plǽtfɔ̀rm ɔ́təmèjts kəntéjnəràjzd æ̀plɪkéjʃən dəplɔ́jmənt, skéjlɪŋ, ənd mǽnədʒmənt júwzɪŋ ə dəklǽrətɪv kənfɪ̀ɡjəréjʃən əprówtʃ ənd sɛ́lf-híjlɪŋ kèjpəbɪ́lɪtijz?",
        "trans_RightAnswer": "kuwbərnɛ́tɪs",
        "trans_WrongAnswers": [
            "dɒ́kər swɔ́rm",
            "əpǽtʃij míjsows",
            "dʒɛ́ŋkɪnz",
            "tɛərəfɔrm",
            "ǽnsɪbəl"
        ],
        "trans_Explanation": "kuwbərnɛ́tɪs ɪz ən ówpən-sɔ́rs kəntéjnər ɔ̀rkəstréjʃən plǽtfɔ̀rm dəzájnd tə ɔ́təmèjt ðə dəplɔ́jmənt, skéjlɪŋ, ənd mǽnədʒmənt əv kəntéjnəràjzd æ̀plɪkéjʃənz. ərɪ́dʒɪnəlij dəvɛ́ləpt baj ɡúwɡəl ənd náw mejntéjnd baj ðə kláwd néjtɪv kəmpjúwtɪŋ fawndéjʃən, kuwbərnɛ́tɪs prəvájdz ə fréjmwɜ̀rk tə rʌ́n dɪstrɪ́bjətɪd sɪ́stəmz rɪzɪ́ljəntlij. ɪt hǽndəlz skɛ́dʒuwlɪŋ kəntéjnərz əkrɔ́s ə klʌ́stər, ənʃʊ́rz æ̀plɪkéjʃənz rʌ́n æz ɪntɛ́ndɪd, mǽnɪdʒɪz wɜ́rklòwd dɪ̀strəbjúwʃən, ənd ɪ́mpləmənts sɛ́lf-híjlɪŋ baj ɔ̀təmǽtɪklij rijstɑ́rtɪŋ féjld kəntéjnərz ɔr rəpléjsɪŋ ðɛm wɛ́n nówdz mælfʌ́ŋkʃən. kuwbərnɛ́tɪs ǽbstrækts əwéj ðə ʌ̀ndərlájɪŋ ɪnfrəstrʌ́ktʃər, əláwɪŋ dəvɛ́ləpərz tə fówkəs ɒn dəzájnɪŋ æ̀plɪkéjʃənz rǽðər ðʌn wɜ́rijɪŋ əbawt ðə spəsɪ́fɪk ənvájərənmənt ɪn wɪ́tʃ ðej rʌ́n. wɪð fíjtʃərz lájk hɔ̀rɪzɒ́ntəl skéjlɪŋ, sɜ́rvɪs dɪ̀skʌ́vrij, lówd bǽlənsɪŋ, ɔ́təmèjtɪd rówlàwts ənd rówlbæ̀ks, ənd kənfɪ̀ɡjəréjʃən mǽnədʒmənt, kuwbərnɛ́tɪs həz bəkʌ́m ðə ɪ́ndəstrij stǽndərd fɔr kəntéjnər ɔ̀rkəstréjʃən ɪn bówθ dəvɛ́ləpmənt ənvájərənmənts ənd lɑ́rdʒ-skéjl prədʌ́kʃən sɪ́stəmz."
    },
    {
        "Question": "Which computing paradigm harnesses quantum mechanical phenomena such as superposition and entanglement to perform calculations that would be practically impossible for classical computers?",
        "RightAnswer": "Quantum Computing",
        "WrongAnswers": [
            "Parallel Computing",
            "Cloud Computing",
            "Neuromorphic Computing",
            "Edge Computing",
            "Molecular Computing"
        ],
        "Explanation": "Quantum Computing represents a revolutionary approach to computation that leverages the principles of quantum mechanics rather than classical physics. Unlike traditional computers that use bits which must be either 0 or 1, quantum computers use quantum bits or 'qubits' that can exist in multiple states simultaneously thanks to a property called superposition. Additionally, qubits can be 'entangled,' meaning the state of one qubit instantly affects another, regardless of distance. These unique properties allow quantum computers to process vast amounts of possibilities simultaneously, potentially solving certain complex problems exponentially faster than classical computers. This makes quantum computing particularly promising for applications like cryptography, optimization problems, drug discovery, and material science simulation. While still in its early stages of development, quantum computing is considered one of the most significant frontiers in computer science, with the potential to transform fields that require enormous computational power.",
        "trans_Question": "wɪ́tʃ kəmpjúwtɪŋ pǽrədàjm hɑ́rnəsɪz kwɑ́ntəm məkǽnɪkəl fənɒ́mənə sʌtʃ æz sùwpərpəzɪ́ʃən ənd əntǽŋɡəlmənt tə pərfɔ́rm kæ̀lkjəléjʃənz ðət wʊd bij prǽktɪkəlij ɪ̀mpɒ́sɪbəl fɔr klǽsɪkəl kəmpjúwtərz?",
        "trans_RightAnswer": "kwɑ́ntəm kəmpjúwtɪŋ",
        "trans_WrongAnswers": [
            "pǽrəlɛ̀l kəmpjúwtɪŋ",
            "kláwd kəmpjúwtɪŋ",
            "nʊ́rowmɔ̀rfɪk kəmpjúwtɪŋ",
            "ɛ́dʒ kəmpjúwtɪŋ",
            "məlɛ́kjələr kəmpjúwtɪŋ"
        ],
        "trans_Explanation": "kwɑ́ntəm kəmpjúwtɪŋ rɛ̀prəzɛ́nts ə rɛ̀vəlúwʃənɛ̀ərij əprówtʃ tə kɒ̀mpjətéjʃən ðət lɛ́vərɪdʒɪz ðə prɪ́nsɪpəlz əv kwɑ́ntəm məkǽnɪks rǽðər ðʌn klǽsɪkəl fɪ́zɪks. ʌ̀nlájk trədɪ́ʃənəl kəmpjúwtərz ðət juwz bɪ́ts wɪ́tʃ mʌst bij ájðər 0 ɔr 1, kwɑ́ntəm kəmpjúwtərz juwz kwɑ́ntəm bɪ́ts ɔr 'kjúwbɪts' ðət kən əɡzɪ́st ɪn mʌ́ltɪpəl stéjts sàjməltéjnijəslij θǽŋks tə ə prɒ́pərtij kɔ́ld sùwpərpəzɪ́ʃən. ədɪ́ʃənʌ̀lij, kjúwbɪts kən bij 'əntǽŋɡəld,' míjnɪŋ ðə stéjt əv wʌ́n kjúwbɪt ɪ́nstəntlij əfɛ́kts ənʌ́ðər, rəɡɑ́rdləs əv dɪ́stəns. ðijz juwnɪ́k prɒ́pərtijz əláw kwɑ́ntəm kəmpjúwtərz tə prɒ́sɛs vǽst əmáwnts əv pɒ̀sɪbɪ́lɪtijz sàjməltéjnijəslij, pətɛ́nʃəlij sɒ́lvɪŋ sɜ́rtən kɒ́mplɛks prɒ́bləmz ɛ̀kspownɛ́nʃəlij fǽstər ðʌn klǽsɪkəl kəmpjúwtərz. ðɪs méjks kwɑ́ntəm kəmpjúwtɪŋ pərtɪ́kjələrlij prɒ́mɪsɪŋ fɔr æ̀plɪkéjʃənz lájk krɪptɒ́ɡrəfij, ɒptɪmɪzéjʃən prɒ́bləmz, drʌ́ɡ dɪ̀skʌ́vrij, ənd mətɪ́ərijəl sájəns sɪ̀mjəléjʃən. wájl stɪ́l ɪn ɪts ɜ́rlij stéjdʒɪz əv dəvɛ́ləpmənt, kwɑ́ntəm kəmpjúwtɪŋ ɪz kənsɪ́dərd wʌ́n əv ðə mówst sɪɡnɪ́fɪkənt frəntɪ́ərz ɪn kəmpjúwtər sájəns, wɪð ðə pətɛ́nʃəl tə trǽnsfɔrm fíjldz ðət rəkwájər ənɔ́rməs kɒ̀mpjuwtéjʃənəl páwər."
    }
]